{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/js/my.js","path":"js/my.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/click_show_text.js","path":"js/click_show_text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/gzh.jpg","path":"medias/gzh.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xiaojike.jpg","path":"medias/avatars/xiaojike.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/yuanzhi.jpg","path":"medias/avatars/yuanzhi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/me.png","path":"medias/avatars/me.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/wawayu.jpg","path":"medias/avatars/wawayu.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.png","path":"medias/featureimages/9.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/img/Arrow.cur","path":"medias/img/Arrow.cur","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/img/beian.png","path":"medias/img/beian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/8.jpg","path":"medias/banner/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/m3thy1.jpg","path":"medias/avatars/m3thy1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/7.jpg","path":"medias/banner/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/img/background.jpg","path":"medias/img/background.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/img/front.jpg","path":"medias/img/front.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1627563282000},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1627563282000},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1627563282000},{"_id":"themes/matery/_config.yml","hash":"9f2aa6e05a4272adbea1315e9bafb2fadbef874c","modified":1674802206163},{"_id":"source/404.md","hash":"40a92ede52a9148113a426dc0f8073445d36296e","modified":1656151480433},{"_id":"source/CNAME","hash":"d6111121838e9456dd442981d83be0e3d0d2fd78","modified":1660140883502},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1627563282000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"205cdc81fee46f8ac039a3264cf27cb6c60c87ac","modified":1659691641852},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1627563282000},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1627563282000},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1656074022039},{"_id":"themes/matery/layout/archive.ejs","hash":"dfbdc96f8174caa33cf26f140956e06f06c50476","modified":1659692362034},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1627563282000},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1627563282000},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1659692099704},{"_id":"themes/matery/layout/layout.ejs","hash":"6bcb2e53ab9e2a68b1c9c6d5ebef47f02864c03d","modified":1660707561109},{"_id":"themes/matery/layout/friends.ejs","hash":"b168cff8305ee8b4155a5e8909345959b5c73e1f","modified":1659612944594},{"_id":"themes/matery/layout/post.ejs","hash":"686291fdf7bf9bf9117b2cd9119957d918e8e381","modified":1656154753124},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1627563282000},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1627563282000},{"_id":"source/_data/musics.json","hash":"32bc061f34721b4ff55f880de1d0ec5787acd2f9","modified":1627563282000},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1627563282000},{"_id":"source/categories/index.md","hash":"707093962dcbbae1eeff0c51d832aafd41154a9c","modified":1656500529096},{"_id":"themes/matery/source/favicon.png","hash":"0865f9b44bc75189ee938182a577b7fe7a95bf7d","modified":1659599516000},{"_id":"source/_data/friends.json","hash":"bc3d040981f91f9ad7f2a2c1e045e60a3b0a0fbf","modified":1674033139478},{"_id":"source/archives/index.md","hash":"814041a5312c91b04726154df2c47bee9900c3ef","modified":1672894370822},{"_id":"source/_posts/2021大二上期末练习题.md","hash":"d3776e15097481dd55b74003f9e524fff630682c","modified":1669610717609},{"_id":"source/_posts/2021年度总结.md","hash":"4122c6ff339e90ccd096dead7d91adc9574a711f","modified":1674119828591},{"_id":"source/_posts/2022年度总结.md","hash":"898c39d0fd809e7ffff796fc034f36b98a2faf3c","modified":1674119837218},{"_id":"source/_posts/2022牛客多校1.md","hash":"3e9910d440298f609c533716cc481210c7f50081","modified":1661094079641},{"_id":"source/_posts/2022杭电Static Query on Tree树链剖分.md","hash":"aa4a4ac941c963e0252b313fe97ec32a21fbdc4d","modified":1659597418134},{"_id":"source/_posts/2022牛客多校2补题.md","hash":"5553214399f6452d7dd075a396e70e7071a96ffe","modified":1661264282870},{"_id":"source/_posts/C-STL超全总结.md","hash":"0339c427b6cbd265ca3e669c938b38a6220b9490","modified":1660092300621},{"_id":"source/_posts/2022牛客多校补题3.md","hash":"038e568cb1a8cac2b8e7c1c121e8accbc01cae81","modified":1662561094224},{"_id":"source/_posts/ABC-266-A-G.md","hash":"c0df6f1f8a2451e093e88963320e7695e938c3c7","modified":1661821847267},{"_id":"source/_posts/CF1055C-Lucky-Days裴蜀定理.md","hash":"3f10f6ba3a84e050fb5106488d1f447762c74a53","modified":1660051787188},{"_id":"source/_posts/CF1076E.Vasya and a Tree树上差分.md","hash":"be2a4f134a883649e52eef5cb10daac4b567c685","modified":1659595634627},{"_id":"source/_posts/C-STL超全总结汇总版.md","hash":"12660b34ae0d89d50028dfa3e8ca3b7f04afc75d","modified":1674117379352},{"_id":"source/_posts/CF1181C-Flag-子矩阵数量统计.md","hash":"c27fc5219e267cdff5ce1ea79bab49c3e328519f","modified":1659597356732},{"_id":"source/_posts/Pytorch深度学习入门知识总结.md","hash":"9ed19f5e566e0b0088cfb339f22dc89483a9b79e","modified":1671026517133},{"_id":"source/_posts/git命令总结.md","hash":"7bfcf94cebfdce04c2c0e1ef667db17e16f4adba","modified":1659596956215},{"_id":"source/_posts/docker总结.md","hash":"53d07e431376b98ea37934edb9db4702f8e01671","modified":1659769818145},{"_id":"source/_posts/nginx命令汇总.md","hash":"089b473936596c31627f179857d55d3e2e64284c","modified":1663862306508},{"_id":"source/_posts/《动手学深度学习》笔记.md","hash":"4ff4da5311ad4c990af0486933f1da0c1fa6b316","modified":1674016573941},{"_id":"source/_posts/树上拓扑序计数.md","hash":"10559b14b5f8c3e766be291b404344341fc0cf97","modified":1660962478280},{"_id":"source/_posts/机器学习基础知识总结.md","hash":"2965593df196f974f432889d488e75f3b46262cd","modified":1675826296171},{"_id":"source/_posts/树链剖分模板.md","hash":"4b7552ecb8da85861978d81f14e1f4bd36ae4ab6","modified":1659596624667},{"_id":"source/_posts/组合数学常用公式.md","hash":"2abe37a83f5c36c007f09e507bbb970e2cd0dc7c","modified":1675915262208},{"_id":"source/_posts/容斥定理.md","hash":"2ad76373ec524a6b7f24cdac4c011898f0c4e556","modified":1659597247542},{"_id":"source/_posts/阶乘逆元和线性逆元.md","hash":"b0f5f2c6141a7f09fc190dfc92b3683795626362","modified":1675439098875},{"_id":"source/friends/index.md","hash":"61a45abbdd6630071a1a8a3e662f271156eb37e9","modified":1674463872741},{"_id":"source/contact/index.md","hash":"516ac787227e8bc66d380d2cbb22c57f897f4735","modified":1673002715559},{"_id":"source/tags/index.md","hash":"fd4410cfc9cdfc26aedf233e4e7fc0f1e6e8a334","modified":1659608811541},{"_id":"source/about/index.md","hash":"1f418786991c5e1961367e98ebf211eca464239c","modified":1673702957020},{"_id":"themes/matery/source/js/my.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1674392670095},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1627563282000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1627563282000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"7f971a1c70c102230a8b74b37b5de37ba03ba245","modified":1659688296596},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1627563282000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1627563282000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1659440736060},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"d5993b48232e30d1a955d8f0d9eb92e4589c5751","modified":1659581339660},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"9b1671c6e4fb670f563729b50646ad370658d15a","modified":1670927669954},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1627563282000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"162afee3afef00ddf371efb8ba84964576ccec9d","modified":1674734717158},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1627563282000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1627563282000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1674389499652},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"a0f8aebe13b63288dcb738f4723f1bb39f5193e4","modified":1659610717848},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1627563282000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"3119b8523cccef5d35b0de15703e795396dd02be","modified":1659609263750},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1674390584467},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1627563282000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1627563282000},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1627563282000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1627563282000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"e2865b3003ec07892e9112692e7ec786ee926ae8","modified":1627563282000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"fcc0c35af7e1aa7dd2b74dba0afebcf940d0c66b","modified":1673534100166},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1627563282000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"a633cc4e66af124e63f64fd66673423dee3e35d4","modified":1672719214543},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1627563282000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1627563282000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1627563282000},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1627563282000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1627563282000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1627563282000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1627563282000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1627563282000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1627563282000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1627563282000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1627563282000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1627563282000},{"_id":"themes/matery/source/js/click_show_text.js","hash":"ff1e79dd1d2fb133258d1a0bedc71c8193803140","modified":1660988917004},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1627563282000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1627563282000},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1627563282000},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1627563282000},{"_id":"themes/matery/source/css/my.css","hash":"56daaa254ca74b60b23f68b9864962bed49b71f2","modified":1674392905738},{"_id":"themes/matery/source/css/matery.css","hash":"0ff81e8d98e760e87abd6b7979127b70c734de5c","modified":1674392916608},{"_id":"source/_posts/2022年度总结/image-20230101121441216.png","hash":"b913826771940dee9095161f55ca67b955b47ba9","modified":1672546481223},{"_id":"source/_posts/2022年度总结/image-20230101121342445.png","hash":"82497f2b7629487d56e0cb5ff3d33b52452fbff3","modified":1672546422462},{"_id":"source/_posts/2022年度总结/image-20230101121415331.png","hash":"6dd5aa55a5fb871e266cda734b96993d8a30389e","modified":1672546455340},{"_id":"source/_posts/2022牛客多校补题3/image-20220907221918311.png","hash":"cdba7a8ed51d3b9b73c0c51fdc8064f98b19ff32","modified":1662560860751},{"_id":"source/_posts/2022牛客多校补题3/image-20220907222225218.png","hash":"96df5f727fccd3dda14694c289f2f31d39df1b54","modified":1662560860753},{"_id":"source/_posts/2022牛客多校1/image-20220821221513603.png","hash":"a8929fc161fd9214f212ef319c4a676d8e804603","modified":1661093968369},{"_id":"source/_posts/CF1181C-Flag-子矩阵数量统计/image-20220629160509729.png","hash":"37d00c57bd7e1bf207b7072cb4bd9d51bdc27e2a","modified":1656489909746},{"_id":"source/_posts/git命令详解/webp.webp","hash":"2a9c699c7ff95fc73bc698bc1acafe7fbab10004","modified":1656555435528},{"_id":"source/_posts/容斥定理/a188f738744e4afb8c5f7e745640cdd9.png","hash":"9e986fb00efd3e80aa35c475dca9ac99079e456b","modified":1656149787693},{"_id":"source/_posts/机器学习基础知识总结/1203675-20180109152428254-718844217.png","hash":"e782b9204cdd55dfca3a45a2bb573ba1bbb964a2","modified":1672645103112},{"_id":"source/_posts/机器学习基础知识总结/1.jpg","hash":"7d8a72a5e32ca436911481f441c172e257bc1f38","modified":1672131895445},{"_id":"source/_posts/机器学习基础知识总结/image-20230102153203878.png","hash":"4cadb85a7c028245cf77b0785276cf486b1a1460","modified":1672644723884},{"_id":"source/_posts/机器学习基础知识总结/image-20230102153230935.png","hash":"c6595090a425ca410bb4b8bbb2273630b2cf83d4","modified":1672644750941},{"_id":"source/_posts/机器学习基础知识总结/image-20230208111655893.png","hash":"b19d3a1b4cf85bdec5ffef38bc8398875600e178","modified":1675826215906},{"_id":"source/_posts/阶乘逆元和线性逆元/2c464c75c8094783bf3d3099ab888e3b.png","hash":"503e57b4f152a745225787fdd09bd7754f3d63ad","modified":1656156533645},{"_id":"source/_posts/阶乘逆元和线性逆元/67dacbcfb1d0428e874f2faff1a0a75a.png","hash":"1c1b67d0c38d04dbf626bc15d028686fc0fd9e85","modified":1656156533576},{"_id":"themes/matery/source/medias/gzh.jpg","hash":"065fbf04e4792d4bca7cf2d33c962a05f225451c","modified":1614691596647},{"_id":"themes/matery/source/medias/logo.png","hash":"0865f9b44bc75189ee938182a577b7fe7a95bf7d","modified":1659599516000},{"_id":"source/_posts/2022杭电Static Query on Tree树链剖分/image-20220722223108042.png","hash":"a65d21aad914885c01910481519f7f545ece8c21","modified":1658500268074},{"_id":"source/_posts/机器学习基础知识总结/2.png","hash":"064cdb89a4192dbd6b9511c60de969703c0e8386","modified":1672370809577},{"_id":"source/_posts/机器学习基础知识总结/image-20221228161134519.png","hash":"614c09829b87a30d0268dd102d58bf422fc24e60","modified":1672215094542},{"_id":"source/_posts/机器学习基础知识总结/image-20221228161724190.png","hash":"e564d2814bf3c3019e979cc9101948ee7938fe0b","modified":1672215444210},{"_id":"source/_posts/机器学习基础知识总结/image-20221228171310763.png","hash":"e793677fbf58670e44341a46aed6e5b8b3dfb56b","modified":1672218790788},{"_id":"source/_posts/机器学习基础知识总结/image-20221230143921870.png","hash":"89703150ab518ff866916886284e03c3e74a734a","modified":1672382361892},{"_id":"source/_posts/机器学习基础知识总结/image-20221230164038527.png","hash":"6ff9f97309570cb866602d74a08eacd2009539b1","modified":1672389638550},{"_id":"source/_posts/机器学习基础知识总结/image-20230102154354917.png","hash":"c058817f6a73f178d3c751e2d01b6a5691019373","modified":1672645434944},{"_id":"source/_posts/机器学习基础知识总结/image-20230103144319179.png","hash":"d6bd0aade5e2fa52a192efedda1e3dc2574bc3d6","modified":1672728199211},{"_id":"source/_posts/树链剖分模板/f09feafcf66f44c0b0e215ff94c1ca40.png","hash":"59130f27d8d3cf66746fde136f3921b7438cab34","modified":1658485781750},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1627563282000},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1627563282000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1627563282000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1627563282000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1627563282000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1627563282000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1627563282000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1627563282000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1627563282000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1627563282000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1627563282000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1627563282000},{"_id":"themes/matery/source/libs/others/text.js","hash":"686307f19ddf3162b1e7cd5bac7e6a23a87fa482","modified":1656728423045},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1627563282000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1627563282000},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1627563282000},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1627563282000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1627563282000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1627563282000},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1627563282000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/xiaojike.jpg","hash":"80c1ed3ad375244d398e751f366c579afbd12821","modified":1656555031265},{"_id":"themes/matery/source/medias/avatars/yuanzhi.jpg","hash":"4e80bc9449cb1c75fa268cae31f04e8b2d9a2ffa","modified":1656254899829},{"_id":"themes/matery/source/medias/avatars/me.png","hash":"0865f9b44bc75189ee938182a577b7fe7a95bf7d","modified":1659599516000},{"_id":"themes/matery/source/medias/avatars/wawayu.jpg","hash":"4eb15b9469a80e379092bd07dc309851b00dcb31","modified":1656134770158},{"_id":"themes/matery/source/medias/featureimages/9.png","hash":"e35c4e98cce683993cc9fc9ae779d71fc7b97372","modified":1674393345810},{"_id":"themes/matery/source/medias/img/Arrow.cur","hash":"b495e52a951b5d4fed451d5b101c23d4ed0f7d7d","modified":1659510706230},{"_id":"themes/matery/source/medias/img/beian.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1659515310903},{"_id":"source/_posts/机器学习基础知识总结/image-20221230142020907.png","hash":"2c8eabe7ba89426aba13afce3433c80da063a4be","modified":1672381220942},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"73d6c94e2b4e3277cdd8a2248f4d160c9a989a68","modified":1655975934944},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1627563282000},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"7662ef1b3f2ef6528fa9362ece4db8426770f596","modified":1656210429000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"080458e0e183c9720db0ebccccd0cbbfddd4ef54","modified":1656211279000},{"_id":"themes/matery/source/medias/banner/8.jpg","hash":"9bfa08d4552b39760cb45e30956370fc4eeb6157","modified":1656211278000},{"_id":"themes/matery/source/medias/avatars/m3thy1.jpg","hash":"3455c313091f028ef3e613739c084be42295e065","modified":1656574773071},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"0201162cc863fb8255c92d56c3b6740f4468cc9d","modified":1659578835000},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"3e3861c190e3b5ef83d6fabb7e4cd54d1c59c739","modified":1674393507204},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"d208a925103793555c1a2b14c2d351f8440c838f","modified":1659578835000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"027c3535f5d675c91c870dcbe163f77931b7e96a","modified":1659676328000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"a45e4b793d910f689f185287edf8c9494c92cced","modified":1659676329000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1627563282000},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1627563282000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1627563282000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1627563282000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"9724d23ff5fb3f61e9b7e21c5f621b746aeda0e3","modified":1656910890385},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"d4fdf6b19523d3dca127b67eb3466019f9f8d1c6","modified":1672718874904},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1627563282000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1627563282000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/7.jpg","hash":"a8c76f897e10e994a0897c3e0f527eaf6539c2fa","modified":1656211279000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"172b6b978ad4c7b10690f05054576dd5cfb58d70","modified":1659578840000},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"7324a78cd14ee79e5cdfabc36edb5059ade4fe70","modified":1659578833000},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"63523123bc8a37120cbbcca567a0375dad391491","modified":1659578841000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"0e900f84efd55329d68c59d97585ad449bed2e86","modified":1659578833000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"c88c8f260c96beb19270335ff8c9487fa66db20e","modified":1659676329000},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"00a785762e67ab43f57d7442c9921909aaa98523","modified":1659578852000},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"24e7223ead78710e4d23b46828e237cc556256a5","modified":1659578834000},{"_id":"themes/matery/source/medias/img/background.jpg","hash":"44a7f9e361ce4fd700564a21f835b2932704e04a","modified":1659579757537},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1627563282000},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1627563282000},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1627563282000},{"_id":"source/_posts/机器学习基础知识总结/image-20221227173755095.png","hash":"54e5cdaa1be7ed31b7e98f5e9241ff2b972b7604","modified":1672133875144},{"_id":"source/_posts/机器学习基础知识总结/image-20230102144808362.png","hash":"b91a3c12f38fdfac21dd4834ad6c3291d96a0674","modified":1672642088413},{"_id":"source/_posts/机器学习基础知识总结/image-20221231110929844.png","hash":"289e777ac4db242fed52eb26d699f5c591d39866","modified":1672456169910},{"_id":"source/_posts/机器学习基础知识总结/image-20221231110826312.png","hash":"42e59f95442bdfc6e46146407108d1864480230d","modified":1672456106378},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"87e0fac5f5e70641730a524947a2489903820a8b","modified":1655975787207},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1627563282000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"c9af3a602729c006f2c977741118129d376fbc5b","modified":1656156117945},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"1ed602adbb311aac6b3e7029f51cf0d438159ad6","modified":1656211282000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"59605e94bc710469b94efdd419914b8980af57a6","modified":1656211283000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"257c61f78540f6f01b9d02fb9824f0bf8100d387","modified":1659578841000},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"9d7322c067857bcaf98eaa1a53dfc3f5b5db072b","modified":1659578835000},{"_id":"themes/matery/source/medias/img/front.jpg","hash":"858d4a36307ebeb5d13918d62f6c532ed191ea7c","modified":1673531733966},{"_id":"source/_posts/机器学习基础知识总结/image-20221230161807567.png","hash":"593c934dd730c04e78cf72a1227a870f6cfcc0d2","modified":1672388287650},{"_id":"source/_posts/机器学习基础知识总结/image-20230102224841617.png","hash":"fdc3fd2a3730e6919547ad7e91f16b6e4c716b0f","modified":1672670921697},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"48e60d01cab1d52c4686a1e0eb39629fcffdb412","modified":1656210429000},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"287aeb2cf25bf71a7aa94be6915be8e6afa46f5c","modified":1659578855000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1627563282000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"d8285a74d3b73e62139571fe8744669c8bc92c48","modified":1659676328000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"83ca541b99dc61ccc33440a35e31f118edaf76fc","modified":1659578842000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"14ddef65d10f181302d8925dbbf321b0497c36e1","modified":1660397584567},{"_id":"source/_posts/机器学习基础知识总结/image-20230102225422893.png","hash":"da2788e5421d574ac0e6c305b00386a94f856790","modified":1672671262991},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"404403a1df311f7b87dd2b37508b0bcdcf9d9c2a","modified":1656211281000},{"_id":"source/_posts/机器学习基础知识总结/image-20221227173603912.png","hash":"b1fb67666e7baec2847121aedd770b2f60efdbef","modified":1672133763997},{"_id":"source/_posts/机器学习基础知识总结/image-20230102225344026.png","hash":"b49279ae903bd9d22d72babc07325cd95a0ed8b1","modified":1672671224117},{"_id":"source/_posts/机器学习基础知识总结/image-20230103153918323.png","hash":"a3e1105a94256007acd9d6b832428b96ca443dee","modified":1672731558423},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"022ef45a2f9586b323682e16f83d14c4581c7b2f","modified":1659578840000},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1627563282000},{"_id":"source/_posts/机器学习基础知识总结/image-20221228164952743.png","hash":"4544f6bc4ef17d57138aa1942a2b1d2f20cd1867","modified":1672217392836},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1627563282000},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"72b4d3c11c928f4fbd724086712dd88884d3c5c0","modified":1660397384000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1627563282000},{"_id":"source/_posts/组合数学常用公式/image-20230209115625513.png","hash":"66e6eeb25dc7892d1e3bb07def7286b922f7968a","modified":1675915126475}],"Category":[{"name":"知识总结","_id":"cldwkolgf00056kuh8nv6nswj"},{"name":"哲思","_id":"cldwkolgr000d6kuhomzwzke7"},{"name":"图论","_id":"cldwkolh1000p6kuh00grwhtv"},{"name":"STL","_id":"cldwkolha000w6kuhzs70gnyd"},{"name":"多校","_id":"cldwkolhd00126kuh8hyxrkc4"},{"name":"数论","_id":"cldwkolho001f6kuhgnqoda3c"},{"name":"AT","_id":"cldwkolhv001v6kuhnm49cn54"},{"name":"DP","_id":"cldwkolhy00236kuh04pp5yrh"},{"name":"树","_id":"cldwkoli2002b6kuh7v1n4r6a"},{"name":"nginx","_id":"cldwkoli3002i6kuhl2yb61qe"},{"name":"树形DP","_id":"cldwkoli5002n6kuhgpx86rjf"}],"Data":[{"_id":"musics","data":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]},{"_id":"friends","data":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}],"Page":[{"title":"404","date":"2022-06-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2022-06-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2022-06-25T10:04:40.433Z","path":"404.html","comments":1,"_id":"cldwkoleo00006kuhc4k48dts","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":""},{"title":"categories","date":"2022-06-19T08:39:20.000Z","type":"categories","layout":"categories","_content":"\n\n\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-06-19 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---\n\n\n\n","updated":"2022-06-29T11:02:09.096Z","path":"categories/index.html","comments":1,"_id":"cldwkolg700016kuhp4ialt0g","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":""},{"title":"archives","date":"2022-06-19T08:39:20.000Z","type":"archives","layout":"archives","_content":"\n\n\n\n\n","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2022-06-19 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---\n\n\n\n\n\n","updated":"2023-01-05T04:52:50.822Z","path":"archives/index.html","comments":1,"_id":"cldwkolgd00036kuhqeqlfqvy","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":""},{"title":"contact","date":"2022-06-23T08:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎大家的留言！\n你有什么想问的？\n\n你有什么想说的？\n\n可以在下方评论区留言哦~\n\n或者加 QQ 技术交流群【群号：231756780】（群内基本没人，哈哈）。\n\n\n\n### 我的博客站点：\n\n- CSDN博客：[https://blog.csdn.net/qq_50285142](https://blog.csdn.net/qq_50285142)\n\n- 博客主站：[https://wyqz.top](https://wyqz.top)\n\n可以去相应的站点看看哦~\n","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2022-06-23 16:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎大家的留言！\n你有什么想问的？\n\n你有什么想说的？\n\n可以在下方评论区留言哦~\n\n或者加 QQ 技术交流群【群号：231756780】（群内基本没人，哈哈）。\n\n\n\n### 我的博客站点：\n\n- CSDN博客：[https://blog.csdn.net/qq_50285142](https://blog.csdn.net/qq_50285142)\n\n- 博客主站：[https://wyqz.top](https://wyqz.top)\n\n可以去相应的站点看看哦~\n","updated":"2023-01-06T10:58:35.559Z","path":"contact/index.html","comments":1,"_id":"cldwkolgh00076kuh7eblghr9","content":"<h1 id=\"欢迎大家的留言！\"><a href=\"#欢迎大家的留言！\" class=\"headerlink\" title=\"欢迎大家的留言！\"></a>欢迎大家的留言！</h1><p>你有什么想问的？</p>\n<p>你有什么想说的？</p>\n<p>可以在下方评论区留言哦~</p>\n<p>或者加 QQ 技术交流群【群号：231756780】（群内基本没人，哈哈）。</p>\n<h3 id=\"我的博客站点：\"><a href=\"#我的博客站点：\" class=\"headerlink\" title=\"我的博客站点：\"></a>我的博客站点：</h3><ul>\n<li><p>CSDN博客：<a href=\"https://blog.csdn.net/qq_50285142\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_50285142</a></p>\n</li>\n<li><p>博客主站：<a href=\"https://wyqz.top\">https://wyqz.top</a></p>\n</li>\n</ul>\n<p>可以去相应的站点看看哦~</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"欢迎大家的留言！\"><a href=\"#欢迎大家的留言！\" class=\"headerlink\" title=\"欢迎大家的留言！\"></a>欢迎大家的留言！</h1><p>你有什么想问的？</p>\n<p>你有什么想说的？</p>\n<p>可以在下方评论区留言哦~</p>\n<p>或者加 QQ 技术交流群【群号：231756780】（群内基本没人，哈哈）。</p>\n<h3 id=\"我的博客站点：\"><a href=\"#我的博客站点：\" class=\"headerlink\" title=\"我的博客站点：\"></a>我的博客站点：</h3><ul>\n<li><p>CSDN博客：<a href=\"https://blog.csdn.net/qq_50285142\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_50285142</a></p>\n</li>\n<li><p>博客主站：<a href=\"https://wyqz.top\">https://wyqz.top</a></p>\n</li>\n</ul>\n<p>可以去相应的站点看看哦~</p>\n"},{"title":"friends","date":"2022-06-13T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n# 关于本站\n\n## 1 更新日志\n\n- 2022-06-23   搭建该博客网站，采用Hexo博客框架，使用Github Page作为服务端\n- 2022-06-24   采用Matery主题\n- 2022-06-25   网站域名更新，变为[http://wyqz.top](http://wyqz.top)\n- 2022-06-25   添加百度统计，统计网站流量\n- 2022-06-30   记录更新日志内容（前面都是凭的记忆写的）\n- 2022-07-02    添加鼠标指针特效，修改菜单栏文字显示\n- 2022-07-04    添加动态线条背景，valine评论request失败bug修复（js版本过低）\n- 2022-07-26    代码上传至GitHub\n- 2022-08-02    网站添加背景图\n- 2022-08-03    添加备案号，准备更新域名\n- 2022-08-04    优化网站打开速度，压缩各种图片，网站链接更新为永久链接\n- 2023-01-02    添加valine评论邮件通知系统，评论时必填邮箱\n- 2023-01-23    修改网站字体，添加自定义js/css文件\n\n## 2 待解决问题\n\n- 文章访问量统计不准确\n\n\n\n# 友链交换\n\n想要交换友链的小伙伴，欢迎在下方评论区留言：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n例如我的博客友链，大家可以加到自己博客里哦：\n* **名称：**行码棋\n* **地址：**https://wyqz.top\n* **简介：**算法蒟蒻\n* **头像**：https://wyqz.top/medias/logo.png\n\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2022-06-13 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 关于本站\n\n## 1 更新日志\n\n- 2022-06-23   搭建该博客网站，采用Hexo博客框架，使用Github Page作为服务端\n- 2022-06-24   采用Matery主题\n- 2022-06-25   网站域名更新，变为[http://wyqz.top](http://wyqz.top)\n- 2022-06-25   添加百度统计，统计网站流量\n- 2022-06-30   记录更新日志内容（前面都是凭的记忆写的）\n- 2022-07-02    添加鼠标指针特效，修改菜单栏文字显示\n- 2022-07-04    添加动态线条背景，valine评论request失败bug修复（js版本过低）\n- 2022-07-26    代码上传至GitHub\n- 2022-08-02    网站添加背景图\n- 2022-08-03    添加备案号，准备更新域名\n- 2022-08-04    优化网站打开速度，压缩各种图片，网站链接更新为永久链接\n- 2023-01-02    添加valine评论邮件通知系统，评论时必填邮箱\n- 2023-01-23    修改网站字体，添加自定义js/css文件\n\n## 2 待解决问题\n\n- 文章访问量统计不准确\n\n\n\n# 友链交换\n\n想要交换友链的小伙伴，欢迎在下方评论区留言：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n例如我的博客友链，大家可以加到自己博客里哦：\n* **名称：**行码棋\n* **地址：**https://wyqz.top\n* **简介：**算法蒟蒻\n* **头像**：https://wyqz.top/medias/logo.png\n\n","updated":"2023-01-23T08:51:12.741Z","path":"friends/index.html","comments":1,"_id":"cldwkolgj00096kuhx1bsg27b","content":"<h1 id=\"关于本站\"><a href=\"#关于本站\" class=\"headerlink\" title=\"关于本站\"></a>关于本站</h1><h2 id=\"1-更新日志\"><a href=\"#1-更新日志\" class=\"headerlink\" title=\"1 更新日志\"></a>1 更新日志</h2><ul>\n<li>2022-06-23   搭建该博客网站，采用Hexo博客框架，使用Github Page作为服务端</li>\n<li>2022-06-24   采用Matery主题</li>\n<li>2022-06-25   网站域名更新，变为<a href=\"http://wyqz.top\">http://wyqz.top</a></li>\n<li>2022-06-25   添加百度统计，统计网站流量</li>\n<li>2022-06-30   记录更新日志内容（前面都是凭的记忆写的）</li>\n<li>2022-07-02    添加鼠标指针特效，修改菜单栏文字显示</li>\n<li>2022-07-04    添加动态线条背景，valine评论request失败bug修复（js版本过低）</li>\n<li>2022-07-26    代码上传至GitHub</li>\n<li>2022-08-02    网站添加背景图</li>\n<li>2022-08-03    添加备案号，准备更新域名</li>\n<li>2022-08-04    优化网站打开速度，压缩各种图片，网站链接更新为永久链接</li>\n<li>2023-01-02    添加valine评论邮件通知系统，评论时必填邮箱</li>\n<li>2023-01-23    修改网站字体，添加自定义js/css文件</li>\n</ul>\n<h2 id=\"2-待解决问题\"><a href=\"#2-待解决问题\" class=\"headerlink\" title=\"2 待解决问题\"></a>2 待解决问题</h2><ul>\n<li>文章访问量统计不准确</li>\n</ul>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在下方评论区留言：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n<p>例如我的博客友链，大家可以加到自己博客里哦：</p>\n<ul>\n<li><strong>名称：</strong>行码棋</li>\n<li><strong>地址：</strong><a href=\"https://wyqz.top\">https://wyqz.top</a></li>\n<li><strong>简介：</strong>算法蒟蒻</li>\n<li><strong>头像</strong>：<a href=\"https://wyqz.top/medias/logo.png\">https://wyqz.top/medias/logo.png</a></li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"关于本站\"><a href=\"#关于本站\" class=\"headerlink\" title=\"关于本站\"></a>关于本站</h1><h2 id=\"1-更新日志\"><a href=\"#1-更新日志\" class=\"headerlink\" title=\"1 更新日志\"></a>1 更新日志</h2><ul>\n<li>2022-06-23   搭建该博客网站，采用Hexo博客框架，使用Github Page作为服务端</li>\n<li>2022-06-24   采用Matery主题</li>\n<li>2022-06-25   网站域名更新，变为<a href=\"http://wyqz.top\">http://wyqz.top</a></li>\n<li>2022-06-25   添加百度统计，统计网站流量</li>\n<li>2022-06-30   记录更新日志内容（前面都是凭的记忆写的）</li>\n<li>2022-07-02    添加鼠标指针特效，修改菜单栏文字显示</li>\n<li>2022-07-04    添加动态线条背景，valine评论request失败bug修复（js版本过低）</li>\n<li>2022-07-26    代码上传至GitHub</li>\n<li>2022-08-02    网站添加背景图</li>\n<li>2022-08-03    添加备案号，准备更新域名</li>\n<li>2022-08-04    优化网站打开速度，压缩各种图片，网站链接更新为永久链接</li>\n<li>2023-01-02    添加valine评论邮件通知系统，评论时必填邮箱</li>\n<li>2023-01-23    修改网站字体，添加自定义js/css文件</li>\n</ul>\n<h2 id=\"2-待解决问题\"><a href=\"#2-待解决问题\" class=\"headerlink\" title=\"2 待解决问题\"></a>2 待解决问题</h2><ul>\n<li>文章访问量统计不准确</li>\n</ul>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在下方评论区留言：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n<p>例如我的博客友链，大家可以加到自己博客里哦：</p>\n<ul>\n<li><strong>名称：</strong>行码棋</li>\n<li><strong>地址：</strong><a href=\"https://wyqz.top\">https://wyqz.top</a></li>\n<li><strong>简介：</strong>算法蒟蒻</li>\n<li><strong>头像</strong>：<a href=\"https://wyqz.top/medias/logo.png\">https://wyqz.top/medias/logo.png</a></li>\n</ul>\n"},{"title":"tags","date":"2022-06-19T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-06-19 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2022-08-04T10:26:51.541Z","path":"tags/index.html","comments":1,"_id":"cldwkolgp000b6kuhku48pgej","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":""},{"title":"about","date":"2022-06-19T08:41:10.000Z","type":"about","layout":"about","mathjax":true,"_content":"\n## 教育背景\n\n* 2020.09 - 至今 本科 | 郑州大学 | 网络空间安全学院 | 物联网工程\n\n  **综合测评** \n\n  2020/09 - 2021/09, 4 / 240\n\n  2021/09 - 2022/09, 3 / 240\n\n\n## 获奖情况\n2021 国家励志奖学金、2022 校一等奖学金\n\n2020 ICPC国际大学生程序设计竞赛（省赛）银奖\n\n2021 CCPC中国大学生程序设计竞赛（省赛）银奖\n\n2022 CCPC中国大学生程序设计竞赛（省赛）金奖\n\n2022 CCPC中国大学生程序设计竞赛（广州站）银奖\n\n## 联系方式\n* <b>电子邮箱</b>\nwyq522208@qq.com\n\n* <b>QQ</b>\n2579272746\n\n* <b>QQ 技术交流群</b>\n231756780 （基本没人，哈哈）\n\n![](/medias/gzh.jpg)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-06-19 16:41:10\ntype: \"about\"\nlayout: \"about\"\nmathjax: true\n---\n\n## 教育背景\n\n* 2020.09 - 至今 本科 | 郑州大学 | 网络空间安全学院 | 物联网工程\n\n  **综合测评** \n\n  2020/09 - 2021/09, 4 / 240\n\n  2021/09 - 2022/09, 3 / 240\n\n\n## 获奖情况\n2021 国家励志奖学金、2022 校一等奖学金\n\n2020 ICPC国际大学生程序设计竞赛（省赛）银奖\n\n2021 CCPC中国大学生程序设计竞赛（省赛）银奖\n\n2022 CCPC中国大学生程序设计竞赛（省赛）金奖\n\n2022 CCPC中国大学生程序设计竞赛（广州站）银奖\n\n## 联系方式\n* <b>电子邮箱</b>\nwyq522208@qq.com\n\n* <b>QQ</b>\n2579272746\n\n* <b>QQ 技术交流群</b>\n231756780 （基本没人，哈哈）\n\n![](/medias/gzh.jpg)","updated":"2023-01-14T13:29:17.020Z","path":"about/index.html","comments":1,"_id":"cldwkoliv003r6kuho6tkp6r3","content":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li><p>2020.09 - 至今 本科 | 郑州大学 | 网络空间安全学院 | 物联网工程</p>\n<p><strong>综合测评</strong> </p>\n<p>2020/09 - 2021/09, 4 / 240</p>\n<p>2021/09 - 2022/09, 3 / 240</p>\n</li>\n</ul>\n<h2 id=\"获奖情况\"><a href=\"#获奖情况\" class=\"headerlink\" title=\"获奖情况\"></a>获奖情况</h2><p>2021 国家励志奖学金、2022 校一等奖学金</p>\n<p>2020 ICPC国际大学生程序设计竞赛（省赛）银奖</p>\n<p>2021 CCPC中国大学生程序设计竞赛（省赛）银奖</p>\n<p>2022 CCPC中国大学生程序设计竞赛（省赛）金奖</p>\n<p>2022 CCPC中国大学生程序设计竞赛（广州站）银奖</p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><p><b>电子邮箱</b><br><a href=\"mailto:wyq522208@qq.com\" target=\"_blank\" rel=\"noopener\">wyq522208@qq.com</a></p>\n</li>\n<li><p><b>QQ</b><br>2579272746</p>\n</li>\n<li><p><b>QQ 技术交流群</b><br>231756780 （基本没人，哈哈）</p>\n</li>\n</ul>\n<p><img src=\"/medias/gzh.jpg\" alt></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li><p>2020.09 - 至今 本科 | 郑州大学 | 网络空间安全学院 | 物联网工程</p>\n<p><strong>综合测评</strong> </p>\n<p>2020/09 - 2021/09, 4 / 240</p>\n<p>2021/09 - 2022/09, 3 / 240</p>\n</li>\n</ul>\n<h2 id=\"获奖情况\"><a href=\"#获奖情况\" class=\"headerlink\" title=\"获奖情况\"></a>获奖情况</h2><p>2021 国家励志奖学金、2022 校一等奖学金</p>\n<p>2020 ICPC国际大学生程序设计竞赛（省赛）银奖</p>\n<p>2021 CCPC中国大学生程序设计竞赛（省赛）银奖</p>\n<p>2022 CCPC中国大学生程序设计竞赛（省赛）金奖</p>\n<p>2022 CCPC中国大学生程序设计竞赛（广州站）银奖</p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><p><b>电子邮箱</b><br><a href=\"mailto:wyq522208@qq.com\" target=\"_blank\" rel=\"noopener\">wyq522208@qq.com</a></p>\n</li>\n<li><p><b>QQ</b><br>2579272746</p>\n</li>\n<li><p><b>QQ 技术交流群</b><br>231756780 （基本没人，哈哈）</p>\n</li>\n</ul>\n<p><img src=\"/medias/gzh.jpg\" alt></p>\n"}],"Post":[{"title":"2021大二上期末知识点总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":454636061,"date":"2022-06-29T11:04:00.000Z","password":null,"summary":null,"_content":"\n\n\n本文知识点均为从网络或其他地方搜集整理而来，提到的习题均无答案，完全不具备权威性质，作者不对看本文造成的后果负责，请合理参考。\n\n\n\n# Linux\n指令基本都是基本指令，输入输出流，统计行数，复制，文件权限修改等等\n大题会考swap分区构建的具体步骤\n考软硬链接文件复制文件和源文件的区别\n脚本题是对两个文件判存在不存在，不存在询问建文件不建，只有当两个文件时都存在合并并排序\n\n\n# 组原\n**大题考的主要是课后习题和课本例题**\n\n**选择填空**\n微指令内容感觉有点多\n填空\n\n- 带宽计算，速度计算\n\n计算\n\n- 补码加减法以及判溢出\n- 时钟周期机器周期计算带宽\n- 命中率，效率，平均访存时间\n- 计算cache映射主存地址位数计算，四路组相连计算\n\n- 一地址指令格式设计，操作方式种类数给了，寻址特征几种有了，设计地址，计算直接寻址范围和间接寻址范围\n\n综合\n\n- 屏蔽字设计，画多级中断图\n- CPU和存储器连接画图\n\n# 毛概\n\n- 新民主主义革命和社会主义革命\n- 对毛泽东思想活的灵魂的理解\n- 对建党精神的理解\n- 新民主主义革命和社会主义革命时期党是如何建设发展的\n\n\n# 近代史\n- 事件是什么：辛亥革命，本事件的性质是什么\n- 意义\n- 失败原因及教训\n- 为什么中国共产党是孙中山革命事业的继承者\n\n论述\n\n- 1.为什么中国共产党应运而生\n- 2.以毛泽东为代表的中国共产党如何探索开辟中国革命道路\n- 3.建党百年的取得成就\n\n\n# 数据结构\n有一个联通分量计算（填空）\n涉及了二叉树节点个数性质\n一些基础知识涉及的比较多\n涉及了一个地址计算（二维数组相关）\n**大题：**\n\n## 1\n\n第一个给了一个程序，进行复杂度分析\n\n```cpp\nint cal(int n)\n{\n\tint x = 2, count = 0;\n\twhile(x < n / 2)\n\t{\n\t\tx *= 2;\n\t\tcount ++;\n\t}\n\treturn count;\n}\n```\n求count的值（用n表示）\n求时间复杂度和空间复杂度\n\n下一个给出一个队列的描述，让你画队列的图，指出队首队尾，队列如何判满和判空\n\n最后一题是程序设计，关于链表操作的题目\n\n## 2\n\n一个队列，给了在其中的元素个数及内容和头指针的位置，让画出队列图，又进行出队和入队操作，再让画一次队列图（哪个位置存的什么元素）\n\n## 3\n\n第三个一个图，画出临接矩阵，然后dfs序列，最小生成树\n\n## 4\n\n一个序列，建立哈夫曼树，求WPL和叶子节点编码\n\n## 5\n\n哈希查找画哈希表，求asl\n\n## 6\n\n一个序列，快排第一趟之后是啥，堆排初始化建立的大根堆是啥\n\n## 编程\n\n编程是第一问编写初始化带头节点的单链表，第二问编写在单链表查找x的程序\n\n\n\n# 数电\n选择触发器涉及的不多，都是些逻辑表达式分析之类的，最小项分析，触发器涉及的都是基础知识，什么存在约束项，什么可以避免空翻，什么抗干扰不抗之类的\n**计算分析**\n\n- 补码加减法\n\n- 写TTL电路逻辑表达式\n\n- 写cmos电路逻辑表达式\n\n  上面写表达式的课本出现过原题\n\n- 用卡诺图化简最简式子\n\n- 用74l138实现某个逻辑表达式\n\n- 画主从rs触发器波形图\n  **综合**\n\n- 数码管设计，真值表\n\n- 8421bcd码，实现相关功能，画真值表，设计电路\n\n[2020年数电试卷](https://wwm.lanzouv.com/iJoc40h3kqfc) https://wwm.lanzouv.com/iJoc40h3kqfc\n","source":"_posts/2021大二上期末练习题.md","raw":"---\ntitle: 2021大二上期末知识点总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 学习总结\ncategories:\n  - 知识总结\nabbrlink: 454636061\ndate: 2022-06-29 19:04:00\npassword:\nsummary:\n---\n\n\n\n本文知识点均为从网络或其他地方搜集整理而来，提到的习题均无答案，完全不具备权威性质，作者不对看本文造成的后果负责，请合理参考。\n\n\n\n# Linux\n指令基本都是基本指令，输入输出流，统计行数，复制，文件权限修改等等\n大题会考swap分区构建的具体步骤\n考软硬链接文件复制文件和源文件的区别\n脚本题是对两个文件判存在不存在，不存在询问建文件不建，只有当两个文件时都存在合并并排序\n\n\n# 组原\n**大题考的主要是课后习题和课本例题**\n\n**选择填空**\n微指令内容感觉有点多\n填空\n\n- 带宽计算，速度计算\n\n计算\n\n- 补码加减法以及判溢出\n- 时钟周期机器周期计算带宽\n- 命中率，效率，平均访存时间\n- 计算cache映射主存地址位数计算，四路组相连计算\n\n- 一地址指令格式设计，操作方式种类数给了，寻址特征几种有了，设计地址，计算直接寻址范围和间接寻址范围\n\n综合\n\n- 屏蔽字设计，画多级中断图\n- CPU和存储器连接画图\n\n# 毛概\n\n- 新民主主义革命和社会主义革命\n- 对毛泽东思想活的灵魂的理解\n- 对建党精神的理解\n- 新民主主义革命和社会主义革命时期党是如何建设发展的\n\n\n# 近代史\n- 事件是什么：辛亥革命，本事件的性质是什么\n- 意义\n- 失败原因及教训\n- 为什么中国共产党是孙中山革命事业的继承者\n\n论述\n\n- 1.为什么中国共产党应运而生\n- 2.以毛泽东为代表的中国共产党如何探索开辟中国革命道路\n- 3.建党百年的取得成就\n\n\n# 数据结构\n有一个联通分量计算（填空）\n涉及了二叉树节点个数性质\n一些基础知识涉及的比较多\n涉及了一个地址计算（二维数组相关）\n**大题：**\n\n## 1\n\n第一个给了一个程序，进行复杂度分析\n\n```cpp\nint cal(int n)\n{\n\tint x = 2, count = 0;\n\twhile(x < n / 2)\n\t{\n\t\tx *= 2;\n\t\tcount ++;\n\t}\n\treturn count;\n}\n```\n求count的值（用n表示）\n求时间复杂度和空间复杂度\n\n下一个给出一个队列的描述，让你画队列的图，指出队首队尾，队列如何判满和判空\n\n最后一题是程序设计，关于链表操作的题目\n\n## 2\n\n一个队列，给了在其中的元素个数及内容和头指针的位置，让画出队列图，又进行出队和入队操作，再让画一次队列图（哪个位置存的什么元素）\n\n## 3\n\n第三个一个图，画出临接矩阵，然后dfs序列，最小生成树\n\n## 4\n\n一个序列，建立哈夫曼树，求WPL和叶子节点编码\n\n## 5\n\n哈希查找画哈希表，求asl\n\n## 6\n\n一个序列，快排第一趟之后是啥，堆排初始化建立的大根堆是啥\n\n## 编程\n\n编程是第一问编写初始化带头节点的单链表，第二问编写在单链表查找x的程序\n\n\n\n# 数电\n选择触发器涉及的不多，都是些逻辑表达式分析之类的，最小项分析，触发器涉及的都是基础知识，什么存在约束项，什么可以避免空翻，什么抗干扰不抗之类的\n**计算分析**\n\n- 补码加减法\n\n- 写TTL电路逻辑表达式\n\n- 写cmos电路逻辑表达式\n\n  上面写表达式的课本出现过原题\n\n- 用卡诺图化简最简式子\n\n- 用74l138实现某个逻辑表达式\n\n- 画主从rs触发器波形图\n  **综合**\n\n- 数码管设计，真值表\n\n- 8421bcd码，实现相关功能，画真值表，设计电路\n\n[2020年数电试卷](https://wwm.lanzouv.com/iJoc40h3kqfc) https://wwm.lanzouv.com/iJoc40h3kqfc\n","slug":"2021大二上期末练习题","published":1,"updated":"2022-11-28T04:45:17.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolg800026kuh1ybr093s","content":"<p>本文知识点均为从网络或其他地方搜集整理而来，提到的习题均无答案，完全不具备权威性质，作者不对看本文造成的后果负责，请合理参考。</p>\n<h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h1><p>指令基本都是基本指令，输入输出流，统计行数，复制，文件权限修改等等<br>大题会考swap分区构建的具体步骤<br>考软硬链接文件复制文件和源文件的区别<br>脚本题是对两个文件判存在不存在，不存在询问建文件不建，只有当两个文件时都存在合并并排序</p>\n<h1 id=\"组原\"><a href=\"#组原\" class=\"headerlink\" title=\"组原\"></a>组原</h1><p><strong>大题考的主要是课后习题和课本例题</strong></p>\n<p><strong>选择填空</strong><br>微指令内容感觉有点多<br>填空</p>\n<ul>\n<li>带宽计算，速度计算</li>\n</ul>\n<p>计算</p>\n<ul>\n<li><p>补码加减法以及判溢出</p>\n</li>\n<li><p>时钟周期机器周期计算带宽</p>\n</li>\n<li><p>命中率，效率，平均访存时间</p>\n</li>\n<li><p>计算cache映射主存地址位数计算，四路组相连计算</p>\n</li>\n<li><p>一地址指令格式设计，操作方式种类数给了，寻址特征几种有了，设计地址，计算直接寻址范围和间接寻址范围</p>\n</li>\n</ul>\n<p>综合</p>\n<ul>\n<li>屏蔽字设计，画多级中断图</li>\n<li>CPU和存储器连接画图</li>\n</ul>\n<h1 id=\"毛概\"><a href=\"#毛概\" class=\"headerlink\" title=\"毛概\"></a>毛概</h1><ul>\n<li>新民主主义革命和社会主义革命</li>\n<li>对毛泽东思想活的灵魂的理解</li>\n<li>对建党精神的理解</li>\n<li>新民主主义革命和社会主义革命时期党是如何建设发展的</li>\n</ul>\n<h1 id=\"近代史\"><a href=\"#近代史\" class=\"headerlink\" title=\"近代史\"></a>近代史</h1><ul>\n<li>事件是什么：辛亥革命，本事件的性质是什么</li>\n<li>意义</li>\n<li>失败原因及教训</li>\n<li>为什么中国共产党是孙中山革命事业的继承者</li>\n</ul>\n<p>论述</p>\n<ul>\n<li>1.为什么中国共产党应运而生</li>\n<li>2.以毛泽东为代表的中国共产党如何探索开辟中国革命道路</li>\n<li>3.建党百年的取得成就</li>\n</ul>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>有一个联通分量计算（填空）<br>涉及了二叉树节点个数性质<br>一些基础知识涉及的比较多<br>涉及了一个地址计算（二维数组相关）<br><strong>大题：</strong></p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>第一个给了一个程序，进行复杂度分析</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">cal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        count <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>求count的值（用n表示）<br>求时间复杂度和空间复杂度</p>\n<p>下一个给出一个队列的描述，让你画队列的图，指出队首队尾，队列如何判满和判空</p>\n<p>最后一题是程序设计，关于链表操作的题目</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>一个队列，给了在其中的元素个数及内容和头指针的位置，让画出队列图，又进行出队和入队操作，再让画一次队列图（哪个位置存的什么元素）</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p>第三个一个图，画出临接矩阵，然后dfs序列，最小生成树</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>一个序列，建立哈夫曼树，求WPL和叶子节点编码</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>哈希查找画哈希表，求asl</p>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><p>一个序列，快排第一趟之后是啥，堆排初始化建立的大根堆是啥</p>\n<h2 id=\"编程\"><a href=\"#编程\" class=\"headerlink\" title=\"编程\"></a>编程</h2><p>编程是第一问编写初始化带头节点的单链表，第二问编写在单链表查找x的程序</p>\n<h1 id=\"数电\"><a href=\"#数电\" class=\"headerlink\" title=\"数电\"></a>数电</h1><p>选择触发器涉及的不多，都是些逻辑表达式分析之类的，最小项分析，触发器涉及的都是基础知识，什么存在约束项，什么可以避免空翻，什么抗干扰不抗之类的<br><strong>计算分析</strong></p>\n<ul>\n<li><p>补码加减法</p>\n</li>\n<li><p>写TTL电路逻辑表达式</p>\n</li>\n<li><p>写cmos电路逻辑表达式</p>\n<p>上面写表达式的课本出现过原题</p>\n</li>\n<li><p>用卡诺图化简最简式子</p>\n</li>\n<li><p>用74l138实现某个逻辑表达式</p>\n</li>\n<li><p>画主从rs触发器波形图<br><strong>综合</strong></p>\n</li>\n<li><p>数码管设计，真值表</p>\n</li>\n<li><p>8421bcd码，实现相关功能，画真值表，设计电路</p>\n</li>\n</ul>\n<p><a href=\"https://wwm.lanzouv.com/iJoc40h3kqfc\" target=\"_blank\" rel=\"noopener\">2020年数电试卷</a> <a href=\"https://wwm.lanzouv.com/iJoc40h3kqfc\" target=\"_blank\" rel=\"noopener\">https://wwm.lanzouv.com/iJoc40h3kqfc</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<p>本文知识点均为从网络或其他地方搜集整理而来，提到的习题均无答案，完全不具备权威性质，作者不对看本文造成的后果负责，请合理参考。</p>\n<h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h1><p>指令基本都是基本指令，输入输出流，统计行数，复制，文件权限修改等等<br>大题会考swap分区构建的具体步骤<br>考软硬链接文件复制文件和源文件的区别<br>脚本题是对两个文件判存在不存在，不存在询问建文件不建，只有当两个文件时都存在合并并排序</p>\n<h1 id=\"组原\"><a href=\"#组原\" class=\"headerlink\" title=\"组原\"></a>组原</h1><p><strong>大题考的主要是课后习题和课本例题</strong></p>\n<p><strong>选择填空</strong><br>微指令内容感觉有点多<br>填空</p>\n<ul>\n<li>带宽计算，速度计算</li>\n</ul>\n<p>计算</p>\n<ul>\n<li><p>补码加减法以及判溢出</p>\n</li>\n<li><p>时钟周期机器周期计算带宽</p>\n</li>\n<li><p>命中率，效率，平均访存时间</p>\n</li>\n<li><p>计算cache映射主存地址位数计算，四路组相连计算</p>\n</li>\n<li><p>一地址指令格式设计，操作方式种类数给了，寻址特征几种有了，设计地址，计算直接寻址范围和间接寻址范围</p>\n</li>\n</ul>\n<p>综合</p>\n<ul>\n<li>屏蔽字设计，画多级中断图</li>\n<li>CPU和存储器连接画图</li>\n</ul>\n<h1 id=\"毛概\"><a href=\"#毛概\" class=\"headerlink\" title=\"毛概\"></a>毛概</h1><ul>\n<li>新民主主义革命和社会主义革命</li>\n<li>对毛泽东思想活的灵魂的理解</li>\n<li>对建党精神的理解</li>\n<li>新民主主义革命和社会主义革命时期党是如何建设发展的</li>\n</ul>\n<h1 id=\"近代史\"><a href=\"#近代史\" class=\"headerlink\" title=\"近代史\"></a>近代史</h1><ul>\n<li>事件是什么：辛亥革命，本事件的性质是什么</li>\n<li>意义</li>\n<li>失败原因及教训</li>\n<li>为什么中国共产党是孙中山革命事业的继承者</li>\n</ul>\n<p>论述</p>\n<ul>\n<li>1.为什么中国共产党应运而生</li>\n<li>2.以毛泽东为代表的中国共产党如何探索开辟中国革命道路</li>\n<li>3.建党百年的取得成就</li>\n</ul>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>有一个联通分量计算（填空）<br>涉及了二叉树节点个数性质<br>一些基础知识涉及的比较多<br>涉及了一个地址计算（二维数组相关）<br><strong>大题：</strong></p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>第一个给了一个程序，进行复杂度分析</p>\n<pre><code class=\"cpp\">int cal(int n)\n{\n    int x = 2, count = 0;\n    while(x &lt; n / 2)\n    {\n        x *= 2;\n        count ++;\n    }\n    return count;\n}</code></pre>\n<p>求count的值（用n表示）<br>求时间复杂度和空间复杂度</p>\n<p>下一个给出一个队列的描述，让你画队列的图，指出队首队尾，队列如何判满和判空</p>\n<p>最后一题是程序设计，关于链表操作的题目</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>一个队列，给了在其中的元素个数及内容和头指针的位置，让画出队列图，又进行出队和入队操作，再让画一次队列图（哪个位置存的什么元素）</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p>第三个一个图，画出临接矩阵，然后dfs序列，最小生成树</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>一个序列，建立哈夫曼树，求WPL和叶子节点编码</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>哈希查找画哈希表，求asl</p>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><p>一个序列，快排第一趟之后是啥，堆排初始化建立的大根堆是啥</p>\n<h2 id=\"编程\"><a href=\"#编程\" class=\"headerlink\" title=\"编程\"></a>编程</h2><p>编程是第一问编写初始化带头节点的单链表，第二问编写在单链表查找x的程序</p>\n<h1 id=\"数电\"><a href=\"#数电\" class=\"headerlink\" title=\"数电\"></a>数电</h1><p>选择触发器涉及的不多，都是些逻辑表达式分析之类的，最小项分析，触发器涉及的都是基础知识，什么存在约束项，什么可以避免空翻，什么抗干扰不抗之类的<br><strong>计算分析</strong></p>\n<ul>\n<li><p>补码加减法</p>\n</li>\n<li><p>写TTL电路逻辑表达式</p>\n</li>\n<li><p>写cmos电路逻辑表达式</p>\n<p>上面写表达式的课本出现过原题</p>\n</li>\n<li><p>用卡诺图化简最简式子</p>\n</li>\n<li><p>用74l138实现某个逻辑表达式</p>\n</li>\n<li><p>画主从rs触发器波形图<br><strong>综合</strong></p>\n</li>\n<li><p>数码管设计，真值表</p>\n</li>\n<li><p>8421bcd码，实现相关功能，画真值表，设计电路</p>\n</li>\n</ul>\n<p><a href=\"https://wwm.lanzouv.com/iJoc40h3kqfc\" target=\"_blank\" rel=\"noopener\">2020年数电试卷</a> <a href=\"https://wwm.lanzouv.com/iJoc40h3kqfc\" target=\"_blank\" rel=\"noopener\">https://wwm.lanzouv.com/iJoc40h3kqfc</a></p>\n"},{"title":"2022年度总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1646942053,"date":"2023-01-01T02:38:55.000Z","password":null,"summary":null,"_content":"\n> 希望2023健康，发论文，比赛拿牌，成功上岸。\n\n今天是2023年1月1日，2022有许多不顺心的事，也有一些值得记忆的事，希望通过下面的片段来回顾这年不易的时光。\n\n> 能说的尽量说，不能说的你我心领神会。我发现时间让我越来越不想说什么东西了，想说的基本都不能说，现实陈述基本是完全禁止的，当下的环境就让人容易窒息。\n\n我想还是多记录一下2022年的生活状态吧。\n\n转眼一看，过的好快啊，转眼间就大三了，大学不知不觉在校内和家里过了三年之久。\n\n# 学期片刻\n\n## 大二下\n\n大二上的考试依然是提前的，没有复习周，三年了，考试要么是提前考试，要么是在家线上考试。\n\n大二下是我计协会长的最后半年，开学是第一次正常开学，前面疫情形势大好，活动遥遥在望。可是近邻活动举办之时（也才过了一两周），疫情形势急转直下，整个学校又是一片封控之态。\n\n哎，整个会长的任期间完全废掉了：\n\n- 院赛没法办，学校不让办（疫情影响）\n- 活动全线上\n- 活动少之又少，线上根本难以办起有效活动\n\n这学期应该就参加了个蓝桥杯，实验室里参加的，题呢难死了，可最终省一还是没想到的，但是国赛在考试期间比就很拉跨了，那时候代码没敲基本一个月了，加之自身实力太菜，根本难以应对，故以国优落幕。\n\nXCPC省赛也没了，CCPC在学期后半段时间一改再改，因为教育厅通知6月初之前全部离校，传的很广了。校内甚至还出现了几次集体性聚集事件（我没有参加，只是听说），回家的这件事那么就理所当然的确定了。\n\n关于期末考试呢，学生闹之又闹，考试口头通知改之又改，最后定于回家之后延期数十天线上进行，所幸本次考试我没有过于拉跨。\n\n## 大三上\n\n又一次推迟开学，21和22届军训都没有进行，真有你的！\n\n辛亏CCPC省赛在前期抓紧办了，所幸拿金。\n\n好啦，这回前面基本上了5周以内的线下课呀，后面就完全封控了，封在寝室里面的。\n\n线上，封寝，做核酸等等，那么上课呢肯定不会好好上的，基本是无听状态，因为大二下假期后期入了原神，封寝室是有事可做的，要么玩，要么刷b站，前期刷题还坚持了一段，后面就很难进行下去了。期间时不时搞一些零碎的技术活（维护QQ机器人、维护博客网站、维护vj等）。\n\n那么XCPC区域赛都是没法打的，只能单挑了，基本整个学校的比赛都是拉跨的。\n\n毫无疑问，这次又是提前放假回家了，学校遣返，疫情形势很难控制住了（还未放开，各地瞒况皆有），考试呢从线上提前考试又改为了下学期线下考试（这时候基本就是大放开阶段了）。\n\n这个时期的社会事件真的是多之又多，fsk，zz，xj，bz运动等等，惊叹之后便保持沉默。\n\n# 专项行动\n\n## 比赛\n\n今年的比赛完全是拉跨的，大三上多好的比赛机会，都被疫情带走了。\n\n所幸还留有一丝希望：\n\nCCPC省赛拿金，CCPC广州站拿银（zsy tql）\n\n## 技术\n\n今年QQ机器人继续完善，现在基本不怎么关注了，后续应该还会再次启动，准备软著。\n\n新建vj平台，虽然是copy的，因为自身水平受限，还是废了一番功夫。\n\n拿下新域名，新建博客网站，目前已经运行半年之久。\n\ndjango和app开发都有所了解，github初步使用\n\n买了代理，不再受限于那堵墙。\n\n给出3张图纪念一下：\n\n![CF](1646942053/image-20230101121342445.png)\n\n![Github](1646942053/image-20230101121415331.png)\n\n![本站博客](1646942053/image-20230101121441216.png)\n\n## 思想\n\n我发现，我心态不再是像之前那样乐观了，现在似乎是`面对可能发生之事保持谨慎，面对未知之事保持关注`这样的态度了，我对许多东西已不报希望，这样的环境只能说尽量存活下去吧。\n\n越来越寡言少语，越来越艰难。2023希望好过些吧，毕竟放开了，比赛能线下了，大学生活或许会改变，但是之前的时间浪费是弄不回来了。\n","source":"_posts/2022年度总结.md","raw":"---\ntitle: 2022年度总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 学习总结\ncategories:\n  - 哲思\nabbrlink: 1646942053\ndate: 2023-01-01 10:38:55\npassword:\nsummary:\n---\n\n> 希望2023健康，发论文，比赛拿牌，成功上岸。\n\n今天是2023年1月1日，2022有许多不顺心的事，也有一些值得记忆的事，希望通过下面的片段来回顾这年不易的时光。\n\n> 能说的尽量说，不能说的你我心领神会。我发现时间让我越来越不想说什么东西了，想说的基本都不能说，现实陈述基本是完全禁止的，当下的环境就让人容易窒息。\n\n我想还是多记录一下2022年的生活状态吧。\n\n转眼一看，过的好快啊，转眼间就大三了，大学不知不觉在校内和家里过了三年之久。\n\n# 学期片刻\n\n## 大二下\n\n大二上的考试依然是提前的，没有复习周，三年了，考试要么是提前考试，要么是在家线上考试。\n\n大二下是我计协会长的最后半年，开学是第一次正常开学，前面疫情形势大好，活动遥遥在望。可是近邻活动举办之时（也才过了一两周），疫情形势急转直下，整个学校又是一片封控之态。\n\n哎，整个会长的任期间完全废掉了：\n\n- 院赛没法办，学校不让办（疫情影响）\n- 活动全线上\n- 活动少之又少，线上根本难以办起有效活动\n\n这学期应该就参加了个蓝桥杯，实验室里参加的，题呢难死了，可最终省一还是没想到的，但是国赛在考试期间比就很拉跨了，那时候代码没敲基本一个月了，加之自身实力太菜，根本难以应对，故以国优落幕。\n\nXCPC省赛也没了，CCPC在学期后半段时间一改再改，因为教育厅通知6月初之前全部离校，传的很广了。校内甚至还出现了几次集体性聚集事件（我没有参加，只是听说），回家的这件事那么就理所当然的确定了。\n\n关于期末考试呢，学生闹之又闹，考试口头通知改之又改，最后定于回家之后延期数十天线上进行，所幸本次考试我没有过于拉跨。\n\n## 大三上\n\n又一次推迟开学，21和22届军训都没有进行，真有你的！\n\n辛亏CCPC省赛在前期抓紧办了，所幸拿金。\n\n好啦，这回前面基本上了5周以内的线下课呀，后面就完全封控了，封在寝室里面的。\n\n线上，封寝，做核酸等等，那么上课呢肯定不会好好上的，基本是无听状态，因为大二下假期后期入了原神，封寝室是有事可做的，要么玩，要么刷b站，前期刷题还坚持了一段，后面就很难进行下去了。期间时不时搞一些零碎的技术活（维护QQ机器人、维护博客网站、维护vj等）。\n\n那么XCPC区域赛都是没法打的，只能单挑了，基本整个学校的比赛都是拉跨的。\n\n毫无疑问，这次又是提前放假回家了，学校遣返，疫情形势很难控制住了（还未放开，各地瞒况皆有），考试呢从线上提前考试又改为了下学期线下考试（这时候基本就是大放开阶段了）。\n\n这个时期的社会事件真的是多之又多，fsk，zz，xj，bz运动等等，惊叹之后便保持沉默。\n\n# 专项行动\n\n## 比赛\n\n今年的比赛完全是拉跨的，大三上多好的比赛机会，都被疫情带走了。\n\n所幸还留有一丝希望：\n\nCCPC省赛拿金，CCPC广州站拿银（zsy tql）\n\n## 技术\n\n今年QQ机器人继续完善，现在基本不怎么关注了，后续应该还会再次启动，准备软著。\n\n新建vj平台，虽然是copy的，因为自身水平受限，还是废了一番功夫。\n\n拿下新域名，新建博客网站，目前已经运行半年之久。\n\ndjango和app开发都有所了解，github初步使用\n\n买了代理，不再受限于那堵墙。\n\n给出3张图纪念一下：\n\n![CF](1646942053/image-20230101121342445.png)\n\n![Github](1646942053/image-20230101121415331.png)\n\n![本站博客](1646942053/image-20230101121441216.png)\n\n## 思想\n\n我发现，我心态不再是像之前那样乐观了，现在似乎是`面对可能发生之事保持谨慎，面对未知之事保持关注`这样的态度了，我对许多东西已不报希望，这样的环境只能说尽量存活下去吧。\n\n越来越寡言少语，越来越艰难。2023希望好过些吧，毕竟放开了，比赛能线下了，大学生活或许会改变，但是之前的时间浪费是弄不回来了。\n","slug":"2022年度总结","published":1,"updated":"2023-01-19T09:17:17.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolge00046kuhpt5phobb","content":"<blockquote>\n<p>希望2023健康，发论文，比赛拿牌，成功上岸。</p>\n</blockquote>\n<p>今天是2023年1月1日，2022有许多不顺心的事，也有一些值得记忆的事，希望通过下面的片段来回顾这年不易的时光。</p>\n<blockquote>\n<p>能说的尽量说，不能说的你我心领神会。我发现时间让我越来越不想说什么东西了，想说的基本都不能说，现实陈述基本是完全禁止的，当下的环境就让人容易窒息。</p>\n</blockquote>\n<p>我想还是多记录一下2022年的生活状态吧。</p>\n<p>转眼一看，过的好快啊，转眼间就大三了，大学不知不觉在校内和家里过了三年之久。</p>\n<h1 id=\"学期片刻\"><a href=\"#学期片刻\" class=\"headerlink\" title=\"学期片刻\"></a>学期片刻</h1><h2 id=\"大二下\"><a href=\"#大二下\" class=\"headerlink\" title=\"大二下\"></a>大二下</h2><p>大二上的考试依然是提前的，没有复习周，三年了，考试要么是提前考试，要么是在家线上考试。</p>\n<p>大二下是我计协会长的最后半年，开学是第一次正常开学，前面疫情形势大好，活动遥遥在望。可是近邻活动举办之时（也才过了一两周），疫情形势急转直下，整个学校又是一片封控之态。</p>\n<p>哎，整个会长的任期间完全废掉了：</p>\n<ul>\n<li>院赛没法办，学校不让办（疫情影响）</li>\n<li>活动全线上</li>\n<li>活动少之又少，线上根本难以办起有效活动</li>\n</ul>\n<p>这学期应该就参加了个蓝桥杯，实验室里参加的，题呢难死了，可最终省一还是没想到的，但是国赛在考试期间比就很拉跨了，那时候代码没敲基本一个月了，加之自身实力太菜，根本难以应对，故以国优落幕。</p>\n<p>XCPC省赛也没了，CCPC在学期后半段时间一改再改，因为教育厅通知6月初之前全部离校，传的很广了。校内甚至还出现了几次集体性聚集事件（我没有参加，只是听说），回家的这件事那么就理所当然的确定了。</p>\n<p>关于期末考试呢，学生闹之又闹，考试口头通知改之又改，最后定于回家之后延期数十天线上进行，所幸本次考试我没有过于拉跨。</p>\n<h2 id=\"大三上\"><a href=\"#大三上\" class=\"headerlink\" title=\"大三上\"></a>大三上</h2><p>又一次推迟开学，21和22届军训都没有进行，真有你的！</p>\n<p>辛亏CCPC省赛在前期抓紧办了，所幸拿金。</p>\n<p>好啦，这回前面基本上了5周以内的线下课呀，后面就完全封控了，封在寝室里面的。</p>\n<p>线上，封寝，做核酸等等，那么上课呢肯定不会好好上的，基本是无听状态，因为大二下假期后期入了原神，封寝室是有事可做的，要么玩，要么刷b站，前期刷题还坚持了一段，后面就很难进行下去了。期间时不时搞一些零碎的技术活（维护QQ机器人、维护博客网站、维护vj等）。</p>\n<p>那么XCPC区域赛都是没法打的，只能单挑了，基本整个学校的比赛都是拉跨的。</p>\n<p>毫无疑问，这次又是提前放假回家了，学校遣返，疫情形势很难控制住了（还未放开，各地瞒况皆有），考试呢从线上提前考试又改为了下学期线下考试（这时候基本就是大放开阶段了）。</p>\n<p>这个时期的社会事件真的是多之又多，fsk，zz，xj，bz运动等等，惊叹之后便保持沉默。</p>\n<h1 id=\"专项行动\"><a href=\"#专项行动\" class=\"headerlink\" title=\"专项行动\"></a>专项行动</h1><h2 id=\"比赛\"><a href=\"#比赛\" class=\"headerlink\" title=\"比赛\"></a>比赛</h2><p>今年的比赛完全是拉跨的，大三上多好的比赛机会，都被疫情带走了。</p>\n<p>所幸还留有一丝希望：</p>\n<p>CCPC省赛拿金，CCPC广州站拿银（zsy tql）</p>\n<h2 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h2><p>今年QQ机器人继续完善，现在基本不怎么关注了，后续应该还会再次启动，准备软著。</p>\n<p>新建vj平台，虽然是copy的，因为自身水平受限，还是废了一番功夫。</p>\n<p>拿下新域名，新建博客网站，目前已经运行半年之久。</p>\n<p>django和app开发都有所了解，github初步使用</p>\n<p>买了代理，不再受限于那堵墙。</p>\n<p>给出3张图纪念一下：</p>\n<p><img src=\"1646942053/image-20230101121342445.png\" alt=\"CF\"></p>\n<p><img src=\"1646942053/image-20230101121415331.png\" alt=\"Github\"></p>\n<p><img src=\"1646942053/image-20230101121441216.png\" alt=\"本站博客\"></p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>我发现，我心态不再是像之前那样乐观了，现在似乎是<code>面对可能发生之事保持谨慎，面对未知之事保持关注</code>这样的态度了，我对许多东西已不报希望，这样的环境只能说尽量存活下去吧。</p>\n<p>越来越寡言少语，越来越艰难。2023希望好过些吧，毕竟放开了，比赛能线下了，大学生活或许会改变，但是之前的时间浪费是弄不回来了。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<blockquote>\n<p>希望2023健康，发论文，比赛拿牌，成功上岸。</p>\n</blockquote>\n<p>今天是2023年1月1日，2022有许多不顺心的事，也有一些值得记忆的事，希望通过下面的片段来回顾这年不易的时光。</p>\n<blockquote>\n<p>能说的尽量说，不能说的你我心领神会。我发现时间让我越来越不想说什么东西了，想说的基本都不能说，现实陈述基本是完全禁止的，当下的环境就让人容易窒息。</p>\n</blockquote>\n<p>我想还是多记录一下2022年的生活状态吧。</p>\n<p>转眼一看，过的好快啊，转眼间就大三了，大学不知不觉在校内和家里过了三年之久。</p>\n<h1 id=\"学期片刻\"><a href=\"#学期片刻\" class=\"headerlink\" title=\"学期片刻\"></a>学期片刻</h1><h2 id=\"大二下\"><a href=\"#大二下\" class=\"headerlink\" title=\"大二下\"></a>大二下</h2><p>大二上的考试依然是提前的，没有复习周，三年了，考试要么是提前考试，要么是在家线上考试。</p>\n<p>大二下是我计协会长的最后半年，开学是第一次正常开学，前面疫情形势大好，活动遥遥在望。可是近邻活动举办之时（也才过了一两周），疫情形势急转直下，整个学校又是一片封控之态。</p>\n<p>哎，整个会长的任期间完全废掉了：</p>\n<ul>\n<li>院赛没法办，学校不让办（疫情影响）</li>\n<li>活动全线上</li>\n<li>活动少之又少，线上根本难以办起有效活动</li>\n</ul>\n<p>这学期应该就参加了个蓝桥杯，实验室里参加的，题呢难死了，可最终省一还是没想到的，但是国赛在考试期间比就很拉跨了，那时候代码没敲基本一个月了，加之自身实力太菜，根本难以应对，故以国优落幕。</p>\n<p>XCPC省赛也没了，CCPC在学期后半段时间一改再改，因为教育厅通知6月初之前全部离校，传的很广了。校内甚至还出现了几次集体性聚集事件（我没有参加，只是听说），回家的这件事那么就理所当然的确定了。</p>\n<p>关于期末考试呢，学生闹之又闹，考试口头通知改之又改，最后定于回家之后延期数十天线上进行，所幸本次考试我没有过于拉跨。</p>\n<h2 id=\"大三上\"><a href=\"#大三上\" class=\"headerlink\" title=\"大三上\"></a>大三上</h2><p>又一次推迟开学，21和22届军训都没有进行，真有你的！</p>\n<p>辛亏CCPC省赛在前期抓紧办了，所幸拿金。</p>\n<p>好啦，这回前面基本上了5周以内的线下课呀，后面就完全封控了，封在寝室里面的。</p>\n<p>线上，封寝，做核酸等等，那么上课呢肯定不会好好上的，基本是无听状态，因为大二下假期后期入了原神，封寝室是有事可做的，要么玩，要么刷b站，前期刷题还坚持了一段，后面就很难进行下去了。期间时不时搞一些零碎的技术活（维护QQ机器人、维护博客网站、维护vj等）。</p>\n<p>那么XCPC区域赛都是没法打的，只能单挑了，基本整个学校的比赛都是拉跨的。</p>\n<p>毫无疑问，这次又是提前放假回家了，学校遣返，疫情形势很难控制住了（还未放开，各地瞒况皆有），考试呢从线上提前考试又改为了下学期线下考试（这时候基本就是大放开阶段了）。</p>\n<p>这个时期的社会事件真的是多之又多，fsk，zz，xj，bz运动等等，惊叹之后便保持沉默。</p>\n<h1 id=\"专项行动\"><a href=\"#专项行动\" class=\"headerlink\" title=\"专项行动\"></a>专项行动</h1><h2 id=\"比赛\"><a href=\"#比赛\" class=\"headerlink\" title=\"比赛\"></a>比赛</h2><p>今年的比赛完全是拉跨的，大三上多好的比赛机会，都被疫情带走了。</p>\n<p>所幸还留有一丝希望：</p>\n<p>CCPC省赛拿金，CCPC广州站拿银（zsy tql）</p>\n<h2 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h2><p>今年QQ机器人继续完善，现在基本不怎么关注了，后续应该还会再次启动，准备软著。</p>\n<p>新建vj平台，虽然是copy的，因为自身水平受限，还是废了一番功夫。</p>\n<p>拿下新域名，新建博客网站，目前已经运行半年之久。</p>\n<p>django和app开发都有所了解，github初步使用</p>\n<p>买了代理，不再受限于那堵墙。</p>\n<p>给出3张图纪念一下：</p>\n<p><img src=\"1646942053/image-20230101121342445.png\" alt=\"CF\"></p>\n<p><img src=\"1646942053/image-20230101121415331.png\" alt=\"Github\"></p>\n<p><img src=\"1646942053/image-20230101121441216.png\" alt=\"本站博客\"></p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>我发现，我心态不再是像之前那样乐观了，现在似乎是<code>面对可能发生之事保持谨慎，面对未知之事保持关注</code>这样的态度了，我对许多东西已不报希望，这样的环境只能说尽量存活下去吧。</p>\n<p>越来越寡言少语，越来越艰难。2023希望好过些吧，毕竟放开了，比赛能线下了，大学生活或许会改变，但是之前的时间浪费是弄不回来了。</p>\n"},{"title":"2021年度总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":3756014507,"date":"2022-06-29T10:52:55.000Z","password":null,"summary":null,"_content":"\n\n\n# 2021年度总结\n\n许多应用都有他们自己的年度总结，那我是不是也要搞一份总结。\n\n今年真的是有很多不顺，也有很多收获。\n\n今年从考试周开始，到考试周结束。\n\n接下来回顾一下我普普通通的2021年，只希望之后看回来能够吸取之前的相关教训和经验。\n>很像流水账，但是我喜欢这样的时间记录，之后回看会很容易看到自己所走的历程。\n## 大一上\n\n- 2021年的开始是大一上学期的考试周，当时几乎什么都不懂，很多都不会。性格内敛，心理上懵懵懂懂。之前比较幸运擦边进了acm实验室，也比较幸运地进了一个北三的团队。（之后发现在这里能够收获很多东西）\n- 记得考试周晚上在看《西部世界》，离谱了，考试周有幸度过。\n- 寒假开始了艰难的acm学习。一个寒假跟着校acm实验室就学了一点，之后发现太难都不会就自己学去了。记得刚开始dfs就给我整吐了，一个寒假，绝望了多少次，啥都不会，看啥看不懂，还得硬看别人的代码，不然还是啥都不会。我真是一个菜鸡（垃圾）。\n- 寒假应该是中后期我开始了在CSDN的创作，当时是写C++STL总结，那时几乎没有代码水平的，现在想想，要是没有这篇总结，我都不会写博客了。\n- 大一的寒假延长了，我是没想到的，没想到大学的寒假竟然有两个多月之多，离大谱了。3月13号差不多才返校。\n\n## 大一下\n\n- 也许是上学期考试考的自我感觉良好了，下学期明显有点飘，干啥啥不中。\n- 开学我就继续进行了acm的训练，当然以我当时非常菜的水平，刷题是几乎不会有很大的提高的，刷的几乎都是水题，也没有很大的效率。\n- 3月底，参加天梯选拔赛，结果只能说是很不行，wa穿了，肯定是很菜的，自己算什么东西，当然是没有选上了，记得排名很靠后。\n- 四月初志愿者监考acm招新赛，看着一大批大佬乱杀，真的很厉害。源佬和熊佬杀的真的很猛，自愧不如。\n- 之后几天参加蓝桥杯，不出所料，只能用两个字形容，“垃圾”，会的几乎没有，铁是必然的。\n- 期间经历了很多次无助，自己看什么都看不懂，学什么都学不会。看着nb的人，他们真的难以被超越，完虐。acm什么都没教会我，倒是教会我了如何完美地被虐。\n- 五月初有幸傍上一个大佬，过了ICPC省赛选拔赛，大概接近五月底参加了ICPC省赛。这次比赛或许是我唯一一次线下的比赛，去农大免费游玩了两天，吃着免费的饭，这转转，那转转，还是很爽的。但是到做题的时候，就很难受了，几乎什么都不会，还是一个垃圾。不过有幸在大佬的带领下拿了银，记得当时因为时间冲突还鸽了学校的一个循迹小车比赛（这个比赛的小车还是一百块钱买的，呜呜呜）。\n- 接近期末参加了社团的换届竞选，选上计算机学术交流协会的会长我是没想到的。\n- 接下来就是我的期末了，考的比较差，概率论有大题原题也一点没有写出来，而且自己还做过，现在想来真的是非常伤啊，期末多科都考的不行，应该是自己没有认真复习，考前还在看美剧吧。\n- 考试后的小学期实习还碰上了有史以来的720大暴雨，当时我断水断电我记得还出去转了一圈呢，水是直接漫到大腿处，断水断电断网了几天，终于是挺过去了。\n- 暑假在家刷了很多题，进度缓慢的进行，前前后后刷了两三百道吧（当时暑假又延期了，延期了大概一个月10月10号左右才上学），题数上去了，但是感觉实力没有多大的提高。呜呜呜，好菜啊。\n\n- 接近8月底我带队参加物联网设计大赛（华为杯），又是因为疫情，比赛线上，本来能去西安线下比赛的，呜呜呜。可能因为线上才让我们获得了不错的成绩吧，西北赛区一等奖，可以晋级总决赛了。8月底，我们又线上参加了总决赛（本来线下是要在湖南大学比的），最后我想只要拿个奖都不错了。当时念获奖队伍的时候想一直不念我们的队，难道是寄了吗。最后真的出乎意料，得了一等奖。我的第一个国一。\n- 高考出分之后几乎都开始干社团宣传的活了，当个会长确实挺累的。\n\n## 大二上\n\n- 这学期真的是忙，开学开的晚，社团会长还得干活。办新生赛，扫楼，迎新，开见面会，交各种材料，答辩等等......\n- 10月底和队友打了省CCPC，在队友的努力带领下，最后拿了银，还是很菜。\n- 11月初在老社长的怂恿下，租了个三年的服务器，现在想来真的有用。上Linux课直接拿平板远程操控了，在服务器上搭网站，各种玩。\n- 11月21，ICPC沈阳站，这一天是绝望的一天。事实证明自己就是一菜比，五百多队，四百多名，题目狠磕，但是还是做不出来。铁又来了。比较难受，但确实证明了自己真的是非常的菜。\n- 快11月底国励到账，爽了。\n- 11月底学了不到一天，在服务器上成功运行了QQ机器人，现在功能慢慢变得已经比较完善了。\n- 12月底还是考试周，临时通知考试周提前，本来就来得晚，现在考的变早了两三个星期，课程很赶，啥都学不会，考试复习根本没时间，结课后下一天就考试。不过考试还是结束了，希望结果是是好的吧。\n\n2021过的有很多不顺利，出现了很多苦难和挫折，有些解决了，有些短时间无法解决或者无法解决（比如说菜这个事情），但是还是出现了一点成就的。今年许多不顺，希望之后遇到能够尽量解决吧。希望之后越来越好！\n","source":"_posts/2021年度总结.md","raw":"---\ntitle: 2021年度总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 学习总结\ncategories:\n  - 哲思\nabbrlink: 3756014507\ndate: 2022-06-29 18:52:55\npassword:\nsummary:\n---\n\n\n\n# 2021年度总结\n\n许多应用都有他们自己的年度总结，那我是不是也要搞一份总结。\n\n今年真的是有很多不顺，也有很多收获。\n\n今年从考试周开始，到考试周结束。\n\n接下来回顾一下我普普通通的2021年，只希望之后看回来能够吸取之前的相关教训和经验。\n>很像流水账，但是我喜欢这样的时间记录，之后回看会很容易看到自己所走的历程。\n## 大一上\n\n- 2021年的开始是大一上学期的考试周，当时几乎什么都不懂，很多都不会。性格内敛，心理上懵懵懂懂。之前比较幸运擦边进了acm实验室，也比较幸运地进了一个北三的团队。（之后发现在这里能够收获很多东西）\n- 记得考试周晚上在看《西部世界》，离谱了，考试周有幸度过。\n- 寒假开始了艰难的acm学习。一个寒假跟着校acm实验室就学了一点，之后发现太难都不会就自己学去了。记得刚开始dfs就给我整吐了，一个寒假，绝望了多少次，啥都不会，看啥看不懂，还得硬看别人的代码，不然还是啥都不会。我真是一个菜鸡（垃圾）。\n- 寒假应该是中后期我开始了在CSDN的创作，当时是写C++STL总结，那时几乎没有代码水平的，现在想想，要是没有这篇总结，我都不会写博客了。\n- 大一的寒假延长了，我是没想到的，没想到大学的寒假竟然有两个多月之多，离大谱了。3月13号差不多才返校。\n\n## 大一下\n\n- 也许是上学期考试考的自我感觉良好了，下学期明显有点飘，干啥啥不中。\n- 开学我就继续进行了acm的训练，当然以我当时非常菜的水平，刷题是几乎不会有很大的提高的，刷的几乎都是水题，也没有很大的效率。\n- 3月底，参加天梯选拔赛，结果只能说是很不行，wa穿了，肯定是很菜的，自己算什么东西，当然是没有选上了，记得排名很靠后。\n- 四月初志愿者监考acm招新赛，看着一大批大佬乱杀，真的很厉害。源佬和熊佬杀的真的很猛，自愧不如。\n- 之后几天参加蓝桥杯，不出所料，只能用两个字形容，“垃圾”，会的几乎没有，铁是必然的。\n- 期间经历了很多次无助，自己看什么都看不懂，学什么都学不会。看着nb的人，他们真的难以被超越，完虐。acm什么都没教会我，倒是教会我了如何完美地被虐。\n- 五月初有幸傍上一个大佬，过了ICPC省赛选拔赛，大概接近五月底参加了ICPC省赛。这次比赛或许是我唯一一次线下的比赛，去农大免费游玩了两天，吃着免费的饭，这转转，那转转，还是很爽的。但是到做题的时候，就很难受了，几乎什么都不会，还是一个垃圾。不过有幸在大佬的带领下拿了银，记得当时因为时间冲突还鸽了学校的一个循迹小车比赛（这个比赛的小车还是一百块钱买的，呜呜呜）。\n- 接近期末参加了社团的换届竞选，选上计算机学术交流协会的会长我是没想到的。\n- 接下来就是我的期末了，考的比较差，概率论有大题原题也一点没有写出来，而且自己还做过，现在想来真的是非常伤啊，期末多科都考的不行，应该是自己没有认真复习，考前还在看美剧吧。\n- 考试后的小学期实习还碰上了有史以来的720大暴雨，当时我断水断电我记得还出去转了一圈呢，水是直接漫到大腿处，断水断电断网了几天，终于是挺过去了。\n- 暑假在家刷了很多题，进度缓慢的进行，前前后后刷了两三百道吧（当时暑假又延期了，延期了大概一个月10月10号左右才上学），题数上去了，但是感觉实力没有多大的提高。呜呜呜，好菜啊。\n\n- 接近8月底我带队参加物联网设计大赛（华为杯），又是因为疫情，比赛线上，本来能去西安线下比赛的，呜呜呜。可能因为线上才让我们获得了不错的成绩吧，西北赛区一等奖，可以晋级总决赛了。8月底，我们又线上参加了总决赛（本来线下是要在湖南大学比的），最后我想只要拿个奖都不错了。当时念获奖队伍的时候想一直不念我们的队，难道是寄了吗。最后真的出乎意料，得了一等奖。我的第一个国一。\n- 高考出分之后几乎都开始干社团宣传的活了，当个会长确实挺累的。\n\n## 大二上\n\n- 这学期真的是忙，开学开的晚，社团会长还得干活。办新生赛，扫楼，迎新，开见面会，交各种材料，答辩等等......\n- 10月底和队友打了省CCPC，在队友的努力带领下，最后拿了银，还是很菜。\n- 11月初在老社长的怂恿下，租了个三年的服务器，现在想来真的有用。上Linux课直接拿平板远程操控了，在服务器上搭网站，各种玩。\n- 11月21，ICPC沈阳站，这一天是绝望的一天。事实证明自己就是一菜比，五百多队，四百多名，题目狠磕，但是还是做不出来。铁又来了。比较难受，但确实证明了自己真的是非常的菜。\n- 快11月底国励到账，爽了。\n- 11月底学了不到一天，在服务器上成功运行了QQ机器人，现在功能慢慢变得已经比较完善了。\n- 12月底还是考试周，临时通知考试周提前，本来就来得晚，现在考的变早了两三个星期，课程很赶，啥都学不会，考试复习根本没时间，结课后下一天就考试。不过考试还是结束了，希望结果是是好的吧。\n\n2021过的有很多不顺利，出现了很多苦难和挫折，有些解决了，有些短时间无法解决或者无法解决（比如说菜这个事情），但是还是出现了一点成就的。今年许多不顺，希望之后遇到能够尽量解决吧。希望之后越来越好！\n","slug":"2021年度总结","published":1,"updated":"2023-01-19T09:17:08.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolgh00086kuhguj6i9th","content":"<h1 id=\"2021年度总结\"><a href=\"#2021年度总结\" class=\"headerlink\" title=\"2021年度总结\"></a>2021年度总结</h1><p>许多应用都有他们自己的年度总结，那我是不是也要搞一份总结。</p>\n<p>今年真的是有很多不顺，也有很多收获。</p>\n<p>今年从考试周开始，到考试周结束。</p>\n<p>接下来回顾一下我普普通通的2021年，只希望之后看回来能够吸取之前的相关教训和经验。</p>\n<blockquote>\n<p>很像流水账，但是我喜欢这样的时间记录，之后回看会很容易看到自己所走的历程。</p>\n</blockquote>\n<h2 id=\"大一上\"><a href=\"#大一上\" class=\"headerlink\" title=\"大一上\"></a>大一上</h2><ul>\n<li>2021年的开始是大一上学期的考试周，当时几乎什么都不懂，很多都不会。性格内敛，心理上懵懵懂懂。之前比较幸运擦边进了acm实验室，也比较幸运地进了一个北三的团队。（之后发现在这里能够收获很多东西）</li>\n<li>记得考试周晚上在看《西部世界》，离谱了，考试周有幸度过。</li>\n<li>寒假开始了艰难的acm学习。一个寒假跟着校acm实验室就学了一点，之后发现太难都不会就自己学去了。记得刚开始dfs就给我整吐了，一个寒假，绝望了多少次，啥都不会，看啥看不懂，还得硬看别人的代码，不然还是啥都不会。我真是一个菜鸡（垃圾）。</li>\n<li>寒假应该是中后期我开始了在CSDN的创作，当时是写C++STL总结，那时几乎没有代码水平的，现在想想，要是没有这篇总结，我都不会写博客了。</li>\n<li>大一的寒假延长了，我是没想到的，没想到大学的寒假竟然有两个多月之多，离大谱了。3月13号差不多才返校。</li>\n</ul>\n<h2 id=\"大一下\"><a href=\"#大一下\" class=\"headerlink\" title=\"大一下\"></a>大一下</h2><ul>\n<li><p>也许是上学期考试考的自我感觉良好了，下学期明显有点飘，干啥啥不中。</p>\n</li>\n<li><p>开学我就继续进行了acm的训练，当然以我当时非常菜的水平，刷题是几乎不会有很大的提高的，刷的几乎都是水题，也没有很大的效率。</p>\n</li>\n<li><p>3月底，参加天梯选拔赛，结果只能说是很不行，wa穿了，肯定是很菜的，自己算什么东西，当然是没有选上了，记得排名很靠后。</p>\n</li>\n<li><p>四月初志愿者监考acm招新赛，看着一大批大佬乱杀，真的很厉害。源佬和熊佬杀的真的很猛，自愧不如。</p>\n</li>\n<li><p>之后几天参加蓝桥杯，不出所料，只能用两个字形容，“垃圾”，会的几乎没有，铁是必然的。</p>\n</li>\n<li><p>期间经历了很多次无助，自己看什么都看不懂，学什么都学不会。看着nb的人，他们真的难以被超越，完虐。acm什么都没教会我，倒是教会我了如何完美地被虐。</p>\n</li>\n<li><p>五月初有幸傍上一个大佬，过了ICPC省赛选拔赛，大概接近五月底参加了ICPC省赛。这次比赛或许是我唯一一次线下的比赛，去农大免费游玩了两天，吃着免费的饭，这转转，那转转，还是很爽的。但是到做题的时候，就很难受了，几乎什么都不会，还是一个垃圾。不过有幸在大佬的带领下拿了银，记得当时因为时间冲突还鸽了学校的一个循迹小车比赛（这个比赛的小车还是一百块钱买的，呜呜呜）。</p>\n</li>\n<li><p>接近期末参加了社团的换届竞选，选上计算机学术交流协会的会长我是没想到的。</p>\n</li>\n<li><p>接下来就是我的期末了，考的比较差，概率论有大题原题也一点没有写出来，而且自己还做过，现在想来真的是非常伤啊，期末多科都考的不行，应该是自己没有认真复习，考前还在看美剧吧。</p>\n</li>\n<li><p>考试后的小学期实习还碰上了有史以来的720大暴雨，当时我断水断电我记得还出去转了一圈呢，水是直接漫到大腿处，断水断电断网了几天，终于是挺过去了。</p>\n</li>\n<li><p>暑假在家刷了很多题，进度缓慢的进行，前前后后刷了两三百道吧（当时暑假又延期了，延期了大概一个月10月10号左右才上学），题数上去了，但是感觉实力没有多大的提高。呜呜呜，好菜啊。</p>\n</li>\n<li><p>接近8月底我带队参加物联网设计大赛（华为杯），又是因为疫情，比赛线上，本来能去西安线下比赛的，呜呜呜。可能因为线上才让我们获得了不错的成绩吧，西北赛区一等奖，可以晋级总决赛了。8月底，我们又线上参加了总决赛（本来线下是要在湖南大学比的），最后我想只要拿个奖都不错了。当时念获奖队伍的时候想一直不念我们的队，难道是寄了吗。最后真的出乎意料，得了一等奖。我的第一个国一。</p>\n</li>\n<li><p>高考出分之后几乎都开始干社团宣传的活了，当个会长确实挺累的。</p>\n</li>\n</ul>\n<h2 id=\"大二上\"><a href=\"#大二上\" class=\"headerlink\" title=\"大二上\"></a>大二上</h2><ul>\n<li>这学期真的是忙，开学开的晚，社团会长还得干活。办新生赛，扫楼，迎新，开见面会，交各种材料，答辩等等……</li>\n<li>10月底和队友打了省CCPC，在队友的努力带领下，最后拿了银，还是很菜。</li>\n<li>11月初在老社长的怂恿下，租了个三年的服务器，现在想来真的有用。上Linux课直接拿平板远程操控了，在服务器上搭网站，各种玩。</li>\n<li>11月21，ICPC沈阳站，这一天是绝望的一天。事实证明自己就是一菜比，五百多队，四百多名，题目狠磕，但是还是做不出来。铁又来了。比较难受，但确实证明了自己真的是非常的菜。</li>\n<li>快11月底国励到账，爽了。</li>\n<li>11月底学了不到一天，在服务器上成功运行了QQ机器人，现在功能慢慢变得已经比较完善了。</li>\n<li>12月底还是考试周，临时通知考试周提前，本来就来得晚，现在考的变早了两三个星期，课程很赶，啥都学不会，考试复习根本没时间，结课后下一天就考试。不过考试还是结束了，希望结果是是好的吧。</li>\n</ul>\n<p>2021过的有很多不顺利，出现了很多苦难和挫折，有些解决了，有些短时间无法解决或者无法解决（比如说菜这个事情），但是还是出现了一点成就的。今年许多不顺，希望之后遇到能够尽量解决吧。希望之后越来越好！</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"2021年度总结\"><a href=\"#2021年度总结\" class=\"headerlink\" title=\"2021年度总结\"></a>2021年度总结</h1><p>许多应用都有他们自己的年度总结，那我是不是也要搞一份总结。</p>\n<p>今年真的是有很多不顺，也有很多收获。</p>\n<p>今年从考试周开始，到考试周结束。</p>\n<p>接下来回顾一下我普普通通的2021年，只希望之后看回来能够吸取之前的相关教训和经验。</p>\n<blockquote>\n<p>很像流水账，但是我喜欢这样的时间记录，之后回看会很容易看到自己所走的历程。</p>\n</blockquote>\n<h2 id=\"大一上\"><a href=\"#大一上\" class=\"headerlink\" title=\"大一上\"></a>大一上</h2><ul>\n<li>2021年的开始是大一上学期的考试周，当时几乎什么都不懂，很多都不会。性格内敛，心理上懵懵懂懂。之前比较幸运擦边进了acm实验室，也比较幸运地进了一个北三的团队。（之后发现在这里能够收获很多东西）</li>\n<li>记得考试周晚上在看《西部世界》，离谱了，考试周有幸度过。</li>\n<li>寒假开始了艰难的acm学习。一个寒假跟着校acm实验室就学了一点，之后发现太难都不会就自己学去了。记得刚开始dfs就给我整吐了，一个寒假，绝望了多少次，啥都不会，看啥看不懂，还得硬看别人的代码，不然还是啥都不会。我真是一个菜鸡（垃圾）。</li>\n<li>寒假应该是中后期我开始了在CSDN的创作，当时是写C++STL总结，那时几乎没有代码水平的，现在想想，要是没有这篇总结，我都不会写博客了。</li>\n<li>大一的寒假延长了，我是没想到的，没想到大学的寒假竟然有两个多月之多，离大谱了。3月13号差不多才返校。</li>\n</ul>\n<h2 id=\"大一下\"><a href=\"#大一下\" class=\"headerlink\" title=\"大一下\"></a>大一下</h2><ul>\n<li><p>也许是上学期考试考的自我感觉良好了，下学期明显有点飘，干啥啥不中。</p>\n</li>\n<li><p>开学我就继续进行了acm的训练，当然以我当时非常菜的水平，刷题是几乎不会有很大的提高的，刷的几乎都是水题，也没有很大的效率。</p>\n</li>\n<li><p>3月底，参加天梯选拔赛，结果只能说是很不行，wa穿了，肯定是很菜的，自己算什么东西，当然是没有选上了，记得排名很靠后。</p>\n</li>\n<li><p>四月初志愿者监考acm招新赛，看着一大批大佬乱杀，真的很厉害。源佬和熊佬杀的真的很猛，自愧不如。</p>\n</li>\n<li><p>之后几天参加蓝桥杯，不出所料，只能用两个字形容，“垃圾”，会的几乎没有，铁是必然的。</p>\n</li>\n<li><p>期间经历了很多次无助，自己看什么都看不懂，学什么都学不会。看着nb的人，他们真的难以被超越，完虐。acm什么都没教会我，倒是教会我了如何完美地被虐。</p>\n</li>\n<li><p>五月初有幸傍上一个大佬，过了ICPC省赛选拔赛，大概接近五月底参加了ICPC省赛。这次比赛或许是我唯一一次线下的比赛，去农大免费游玩了两天，吃着免费的饭，这转转，那转转，还是很爽的。但是到做题的时候，就很难受了，几乎什么都不会，还是一个垃圾。不过有幸在大佬的带领下拿了银，记得当时因为时间冲突还鸽了学校的一个循迹小车比赛（这个比赛的小车还是一百块钱买的，呜呜呜）。</p>\n</li>\n<li><p>接近期末参加了社团的换届竞选，选上计算机学术交流协会的会长我是没想到的。</p>\n</li>\n<li><p>接下来就是我的期末了，考的比较差，概率论有大题原题也一点没有写出来，而且自己还做过，现在想来真的是非常伤啊，期末多科都考的不行，应该是自己没有认真复习，考前还在看美剧吧。</p>\n</li>\n<li><p>考试后的小学期实习还碰上了有史以来的720大暴雨，当时我断水断电我记得还出去转了一圈呢，水是直接漫到大腿处，断水断电断网了几天，终于是挺过去了。</p>\n</li>\n<li><p>暑假在家刷了很多题，进度缓慢的进行，前前后后刷了两三百道吧（当时暑假又延期了，延期了大概一个月10月10号左右才上学），题数上去了，但是感觉实力没有多大的提高。呜呜呜，好菜啊。</p>\n</li>\n<li><p>接近8月底我带队参加物联网设计大赛（华为杯），又是因为疫情，比赛线上，本来能去西安线下比赛的，呜呜呜。可能因为线上才让我们获得了不错的成绩吧，西北赛区一等奖，可以晋级总决赛了。8月底，我们又线上参加了总决赛（本来线下是要在湖南大学比的），最后我想只要拿个奖都不错了。当时念获奖队伍的时候想一直不念我们的队，难道是寄了吗。最后真的出乎意料，得了一等奖。我的第一个国一。</p>\n</li>\n<li><p>高考出分之后几乎都开始干社团宣传的活了，当个会长确实挺累的。</p>\n</li>\n</ul>\n<h2 id=\"大二上\"><a href=\"#大二上\" class=\"headerlink\" title=\"大二上\"></a>大二上</h2><ul>\n<li>这学期真的是忙，开学开的晚，社团会长还得干活。办新生赛，扫楼，迎新，开见面会，交各种材料，答辩等等……</li>\n<li>10月底和队友打了省CCPC，在队友的努力带领下，最后拿了银，还是很菜。</li>\n<li>11月初在老社长的怂恿下，租了个三年的服务器，现在想来真的有用。上Linux课直接拿平板远程操控了，在服务器上搭网站，各种玩。</li>\n<li>11月21，ICPC沈阳站，这一天是绝望的一天。事实证明自己就是一菜比，五百多队，四百多名，题目狠磕，但是还是做不出来。铁又来了。比较难受，但确实证明了自己真的是非常的菜。</li>\n<li>快11月底国励到账，爽了。</li>\n<li>11月底学了不到一天，在服务器上成功运行了QQ机器人，现在功能慢慢变得已经比较完善了。</li>\n<li>12月底还是考试周，临时通知考试周提前，本来就来得晚，现在考的变早了两三个星期，课程很赶，啥都学不会，考试复习根本没时间，结课后下一天就考试。不过考试还是结束了，希望结果是是好的吧。</li>\n</ul>\n<p>2021过的有很多不顺利，出现了很多苦难和挫折，有些解决了，有些短时间无法解决或者无法解决（比如说菜这个事情），但是还是出现了一点成就的。今年许多不顺，希望之后遇到能够尽量解决吧。希望之后越来越好！</p>\n"},{"title":"2022杭电多校2 Static Query on Tree|树链剖分","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":3388199031,"date":"2022-07-22T14:28:33.000Z","password":null,"summary":null,"_content":"\n\n\n# [Static Query on Tree](http://acm.hdu.edu.cn/showproblem.php?pid=7150)\n\n下面介绍树链剖分做法（即题解的第二种做法）\n\n![题目描述](3388199031/image-20220722223108042.png)\n\n\n\n> 题目大意：\n>\n> 一棵内向树，三个集合A，B，C，每个集合里面有一些点，求特定点的个数，满足从A集合和B集合可以到达该特定点，且可以从该特定点到达C集合。\n\n\n\n可以把从A集合到达根节点路径中都打上A标记，把从B集合到达根节点路径中都打上B标记，那么树中被打上A和B标记的就是A和B集合都可以到达的点。（因为是内向树，所以向根节点方向走）\n\n只需要判断这些打上A和B标记的点能否到达C节点即可，方法也是同样的，将C集合中的每个点和其子树上的点都打上C标记，只要统计树中同时被打上ABC标记的点的个数即可（此时可以用线段树维护标记）。\n\n\n\n**线段树记录变量**\n\n- $tr[u].cnt[i]$\n\n$tr[u].cnt[i]$中的$i$有三个值，0，1，2，分别代表被打上A标记的点，被打上AB标记的点，被打上ABC标记的点。\n\n则$tr[u].cnt[i]$则共可以表示在对应的线段树节点表示的区间上被打上A标记的点的个数（$i = 0$），被打上AB标记的点的个数（$i = 1$），被打上ABC标记的点的个数（$i = 2$）。\n\n- $tr[u].flag[i]$\n\n共有三个值`-1`，`0`， `1`\n\n初始值等于`-1`，为`0`代表对应的区间置为0\n\n懒标记下传方法：\n\n在下传懒标记A时，因为A是第一次标记，无需其他条件，直接下传，记录一下`cnt`变量即可。\n\n```cpp\ntr[u << 1].cnt[i] = tr[u].flag[i] * (mid - l + 1);\ntr[u << 1 | 1].cnt[i] = tr[u].flag[i] * (r - mid); \n```\n\n下传懒标记B和C时，就需要有限制条件了，下传懒标记B我们需要有A标记才能求被标记A和B的节点，即被标记AB的节点的数量等于被标记A节点的数量乘对应的懒标记。\n\n```cpp\ntr[u << 1].cnt[i] = tr[u].flag[i] * tr[u << 1].cnt[i - 1];\ntr[u << 1 | 1].cnt[i] = tr[u].flag[i] * tr[u << 1 | 1].cnt[i - 1];\n```\n\n\n\n接下来就是树链剖分的板子了，可以看下面链接\n\n[树链剖分模板题](../shupou1000)\n\n# 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 2e5 + 5, M = 2 * N;\nconst int p = 1e9 + 7;\n\nint n, q;\n\nstruct Segment\n{\n    int cnt[3], flag[3];\n}tr[N * 4];\n\nint dep[N], fa[N], son[N], sz[N];\nint cnt, nw[N], top[N], id[N];\n\nint e[M], h[N], ne[M], idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid pushup(int u)\n{\n    for(int i = 0; i < 3; i++)\n    \ttr[u].cnt[i] = tr[u << 1].cnt[i] + tr[u << 1 | 1].cnt[i];\n\n}\nvoid pushdown(int u, int l, int r)\n{\n    int mid = (l + r) >> 1;\n\n    for(int i = 0; i < 3; i++)\n    {\n    \tif(tr[u].flag[i] == -1)\n    \t\tcontinue;\n    \ttr[u << 1].flag[i] = tr[u].flag[i];\n    \ttr[u << 1 | 1].flag[i] = tr[u].flag[i];\n    \tif(i == 0)\n    \t{\n    \t\ttr[u << 1].cnt[i] = tr[u].flag[i] * (mid - l + 1);\n    \t\ttr[u << 1 | 1].cnt[i] = tr[u].flag[i] * (r - mid); \n    \t}\n    \telse\n    \t{\n    \t\ttr[u << 1].cnt[i] = tr[u].flag[i] * tr[u << 1].cnt[i - 1];\n    \t\ttr[u << 1 | 1].cnt[i] = tr[u].flag[i] * tr[u << 1 | 1].cnt[i - 1];\n    \t}\n    \ttr[u].flag[i] = -1;\n    }\n}\n\nvoid build(int u, int l, int r)\n{\n    if(l == r)\n    {\n        for(int i = 0; i < 3; i++)\n        \ttr[u].cnt[i] = 0;\n\t    for(int i = 0; i < 3; i++)\n        \ttr[u].flag[i] = -1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(u << 1, l, mid);\n    build(u << 1 | 1, mid + 1, r);\n    pushup(u);\n}\n\nvoid modify(int u, int l, int r, int x, int y, int d, int v)\n{\n    if(l >= x && r <= y)\n    {\n        tr[u].flag[d] = v;\n        if(d == 0)\n        \ttr[u].cnt[0] = (r - l + 1) * v;\n        else tr[u].cnt[d] = tr[u].cnt[d - 1] * v;\n        return;\n    }\n    pushdown(u, l, r);\n    int mid = (l + r) >> 1;\n    if(x <= mid) modify(u << 1, l, mid, x, y, d, v);\n    if(y > mid) modify(u << 1 | 1, mid + 1, r, x, y, d, v);\n    pushup(u);\n}\n\nll query(int u, int l, int r, int x, int y)\n{\n    if(l >= x && r <= y)\n    \treturn tr[u].cnt[2] % p;\n    pushdown(u, l, r);\n    int mid = (l + r) >> 1;\n    ll ans = 0;\n    if(x <= mid) ans = query(u << 1, l, mid, x, y) % p;\n    if(y > mid) ans = (ans + query(u << 1 | 1, mid + 1, r, x, y)) % p;\n    return ans;\n}\n\n//预处理dep[],fa[],sz[],son[](重儿子节点)\nvoid dfs1(int x, int f, int depth)//x : 当前节点, f：父亲, depth：深度\n{\n    dep[x] = depth;\n    fa[x] = f;\n    sz[x] = 1;\n    int mxson = -1;\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == f) continue;\n        dfs1(y, x, depth + 1);\n        sz[x] += sz[y];\n        if(sz[y] > mxson)// 记录重儿子编号\n        {\n            son[x] = y;\n            mxson = sz[y];\n        }\n    }\n}\n\n// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端\nvoid dfs2(int x, int topf)\n{\n    id[x] = ++cnt;\n    nw[cnt] = w[x];\n    top[x] = topf;\n    if(!son[x]) return;//无儿子返回\n    dfs2(son[x], topf);\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == fa[x] || y == son[x])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nll queryRange(int x, int y)\n{\n    ll ans = 0;\n    while(top[x] != top[y])//不在同一条链上\n    {\n        if(dep[top[x]] < dep[top[y]])\n            swap(x, y);\n        ans += query(1, 1, n, id[top[x]], id[x]);\n        ans %= p;\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y])\n        swap(x, y);\n    ans = (ans + query(1, 1, n, id[x], id[y])) % p;\n    return ans;\n}\n\nvoid modifyRange(int x, int y, int d, int v)\n{\n    v %= p;\n    while(top[x] != top[y])\n    {\n        if(dep[top[x]] < dep[top[y]])\n            swap(x, y);\n        modify(1, 1, n, id[top[x]], id[x], d, v);\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y])\n        swap(x, y);\n    modify(1, 1, n, id[x], id[y], d, v);\n}\nll querySon(int x)\n{\n    return query(1, 1, n, id[x], id[x] + sz[x] - 1);  \n}\nvoid modifySon(int x, int d, int v)\n{\n    modify(1, 1, n, id[x], id[x] + sz[x] - 1, d, v);\n}\n\n\nint tot[3], node[4][N];\n\nvoid solve()\n{\n    cin >> n >> q;\n    int r = 1;\n    memset(h, -1, sizeof h);\n    for(int i = 2; i <= n; i++)\n    {\n    \tint to;\n    \tcin >> to;\n        add(to, i);\n        add(i, to);\n    }\n    dfs1(r, -1, 1);\n    dfs2(r, r);\n    build(1, 1, n);\n    while(q--)\n    {\n    \tfor(int i = 0; i < 3; i++)\n    \t\tcin >> tot[i];\n    \tfor(int i = 0; i < 3; i++)\n    \t\tfor(int j = 1; j <= tot[i]; j++)\n    \t\t{\n    \t\t\tcin >> node[i][j];\n    \t\t\tif(i != 2)\n    \t\t\t\tmodifyRange(1, node[i][j], i, 1);\n    \t\t\telse\n    \t\t\t\tmodifySon(node[i][j], i, 1);\n    \t\t}\n    \tcout << querySon(1) << \"\\n\";\n    \tmodifySon(1, 0, 0);\n    \tmodifySon(1, 1, 0);\n    \tmodifySon(1, 2, 0);\n    }\n}\n\nint main()\n{\n    // ios::sync_with_stdio(false);\n    // cin.tie(0);\n    int t;\n    cin >> t;\n    // t = 1;\n    while(t--)\n        solve();\n    return 0;\n}\n```\n\n","source":"_posts/2022杭电Static Query on Tree树链剖分.md","raw":"---\ntitle: 2022杭电多校2 Static Query on Tree|树链剖分\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 树链剖分\ncategories:\n  - 图论\nabbrlink: 3388199031\ndate: 2022-07-22 22:28:33\npassword:\nsummary:\n---\n\n\n\n# [Static Query on Tree](http://acm.hdu.edu.cn/showproblem.php?pid=7150)\n\n下面介绍树链剖分做法（即题解的第二种做法）\n\n![题目描述](3388199031/image-20220722223108042.png)\n\n\n\n> 题目大意：\n>\n> 一棵内向树，三个集合A，B，C，每个集合里面有一些点，求特定点的个数，满足从A集合和B集合可以到达该特定点，且可以从该特定点到达C集合。\n\n\n\n可以把从A集合到达根节点路径中都打上A标记，把从B集合到达根节点路径中都打上B标记，那么树中被打上A和B标记的就是A和B集合都可以到达的点。（因为是内向树，所以向根节点方向走）\n\n只需要判断这些打上A和B标记的点能否到达C节点即可，方法也是同样的，将C集合中的每个点和其子树上的点都打上C标记，只要统计树中同时被打上ABC标记的点的个数即可（此时可以用线段树维护标记）。\n\n\n\n**线段树记录变量**\n\n- $tr[u].cnt[i]$\n\n$tr[u].cnt[i]$中的$i$有三个值，0，1，2，分别代表被打上A标记的点，被打上AB标记的点，被打上ABC标记的点。\n\n则$tr[u].cnt[i]$则共可以表示在对应的线段树节点表示的区间上被打上A标记的点的个数（$i = 0$），被打上AB标记的点的个数（$i = 1$），被打上ABC标记的点的个数（$i = 2$）。\n\n- $tr[u].flag[i]$\n\n共有三个值`-1`，`0`， `1`\n\n初始值等于`-1`，为`0`代表对应的区间置为0\n\n懒标记下传方法：\n\n在下传懒标记A时，因为A是第一次标记，无需其他条件，直接下传，记录一下`cnt`变量即可。\n\n```cpp\ntr[u << 1].cnt[i] = tr[u].flag[i] * (mid - l + 1);\ntr[u << 1 | 1].cnt[i] = tr[u].flag[i] * (r - mid); \n```\n\n下传懒标记B和C时，就需要有限制条件了，下传懒标记B我们需要有A标记才能求被标记A和B的节点，即被标记AB的节点的数量等于被标记A节点的数量乘对应的懒标记。\n\n```cpp\ntr[u << 1].cnt[i] = tr[u].flag[i] * tr[u << 1].cnt[i - 1];\ntr[u << 1 | 1].cnt[i] = tr[u].flag[i] * tr[u << 1 | 1].cnt[i - 1];\n```\n\n\n\n接下来就是树链剖分的板子了，可以看下面链接\n\n[树链剖分模板题](../shupou1000)\n\n# 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 2e5 + 5, M = 2 * N;\nconst int p = 1e9 + 7;\n\nint n, q;\n\nstruct Segment\n{\n    int cnt[3], flag[3];\n}tr[N * 4];\n\nint dep[N], fa[N], son[N], sz[N];\nint cnt, nw[N], top[N], id[N];\n\nint e[M], h[N], ne[M], idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid pushup(int u)\n{\n    for(int i = 0; i < 3; i++)\n    \ttr[u].cnt[i] = tr[u << 1].cnt[i] + tr[u << 1 | 1].cnt[i];\n\n}\nvoid pushdown(int u, int l, int r)\n{\n    int mid = (l + r) >> 1;\n\n    for(int i = 0; i < 3; i++)\n    {\n    \tif(tr[u].flag[i] == -1)\n    \t\tcontinue;\n    \ttr[u << 1].flag[i] = tr[u].flag[i];\n    \ttr[u << 1 | 1].flag[i] = tr[u].flag[i];\n    \tif(i == 0)\n    \t{\n    \t\ttr[u << 1].cnt[i] = tr[u].flag[i] * (mid - l + 1);\n    \t\ttr[u << 1 | 1].cnt[i] = tr[u].flag[i] * (r - mid); \n    \t}\n    \telse\n    \t{\n    \t\ttr[u << 1].cnt[i] = tr[u].flag[i] * tr[u << 1].cnt[i - 1];\n    \t\ttr[u << 1 | 1].cnt[i] = tr[u].flag[i] * tr[u << 1 | 1].cnt[i - 1];\n    \t}\n    \ttr[u].flag[i] = -1;\n    }\n}\n\nvoid build(int u, int l, int r)\n{\n    if(l == r)\n    {\n        for(int i = 0; i < 3; i++)\n        \ttr[u].cnt[i] = 0;\n\t    for(int i = 0; i < 3; i++)\n        \ttr[u].flag[i] = -1;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(u << 1, l, mid);\n    build(u << 1 | 1, mid + 1, r);\n    pushup(u);\n}\n\nvoid modify(int u, int l, int r, int x, int y, int d, int v)\n{\n    if(l >= x && r <= y)\n    {\n        tr[u].flag[d] = v;\n        if(d == 0)\n        \ttr[u].cnt[0] = (r - l + 1) * v;\n        else tr[u].cnt[d] = tr[u].cnt[d - 1] * v;\n        return;\n    }\n    pushdown(u, l, r);\n    int mid = (l + r) >> 1;\n    if(x <= mid) modify(u << 1, l, mid, x, y, d, v);\n    if(y > mid) modify(u << 1 | 1, mid + 1, r, x, y, d, v);\n    pushup(u);\n}\n\nll query(int u, int l, int r, int x, int y)\n{\n    if(l >= x && r <= y)\n    \treturn tr[u].cnt[2] % p;\n    pushdown(u, l, r);\n    int mid = (l + r) >> 1;\n    ll ans = 0;\n    if(x <= mid) ans = query(u << 1, l, mid, x, y) % p;\n    if(y > mid) ans = (ans + query(u << 1 | 1, mid + 1, r, x, y)) % p;\n    return ans;\n}\n\n//预处理dep[],fa[],sz[],son[](重儿子节点)\nvoid dfs1(int x, int f, int depth)//x : 当前节点, f：父亲, depth：深度\n{\n    dep[x] = depth;\n    fa[x] = f;\n    sz[x] = 1;\n    int mxson = -1;\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == f) continue;\n        dfs1(y, x, depth + 1);\n        sz[x] += sz[y];\n        if(sz[y] > mxson)// 记录重儿子编号\n        {\n            son[x] = y;\n            mxson = sz[y];\n        }\n    }\n}\n\n// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端\nvoid dfs2(int x, int topf)\n{\n    id[x] = ++cnt;\n    nw[cnt] = w[x];\n    top[x] = topf;\n    if(!son[x]) return;//无儿子返回\n    dfs2(son[x], topf);\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == fa[x] || y == son[x])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nll queryRange(int x, int y)\n{\n    ll ans = 0;\n    while(top[x] != top[y])//不在同一条链上\n    {\n        if(dep[top[x]] < dep[top[y]])\n            swap(x, y);\n        ans += query(1, 1, n, id[top[x]], id[x]);\n        ans %= p;\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y])\n        swap(x, y);\n    ans = (ans + query(1, 1, n, id[x], id[y])) % p;\n    return ans;\n}\n\nvoid modifyRange(int x, int y, int d, int v)\n{\n    v %= p;\n    while(top[x] != top[y])\n    {\n        if(dep[top[x]] < dep[top[y]])\n            swap(x, y);\n        modify(1, 1, n, id[top[x]], id[x], d, v);\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y])\n        swap(x, y);\n    modify(1, 1, n, id[x], id[y], d, v);\n}\nll querySon(int x)\n{\n    return query(1, 1, n, id[x], id[x] + sz[x] - 1);  \n}\nvoid modifySon(int x, int d, int v)\n{\n    modify(1, 1, n, id[x], id[x] + sz[x] - 1, d, v);\n}\n\n\nint tot[3], node[4][N];\n\nvoid solve()\n{\n    cin >> n >> q;\n    int r = 1;\n    memset(h, -1, sizeof h);\n    for(int i = 2; i <= n; i++)\n    {\n    \tint to;\n    \tcin >> to;\n        add(to, i);\n        add(i, to);\n    }\n    dfs1(r, -1, 1);\n    dfs2(r, r);\n    build(1, 1, n);\n    while(q--)\n    {\n    \tfor(int i = 0; i < 3; i++)\n    \t\tcin >> tot[i];\n    \tfor(int i = 0; i < 3; i++)\n    \t\tfor(int j = 1; j <= tot[i]; j++)\n    \t\t{\n    \t\t\tcin >> node[i][j];\n    \t\t\tif(i != 2)\n    \t\t\t\tmodifyRange(1, node[i][j], i, 1);\n    \t\t\telse\n    \t\t\t\tmodifySon(node[i][j], i, 1);\n    \t\t}\n    \tcout << querySon(1) << \"\\n\";\n    \tmodifySon(1, 0, 0);\n    \tmodifySon(1, 1, 0);\n    \tmodifySon(1, 2, 0);\n    }\n}\n\nint main()\n{\n    // ios::sync_with_stdio(false);\n    // cin.tie(0);\n    int t;\n    cin >> t;\n    // t = 1;\n    while(t--)\n        solve();\n    return 0;\n}\n```\n\n","slug":"2022杭电Static Query on Tree树链剖分","published":1,"updated":"2022-08-04T07:16:58.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolgj000a6kuhtk625wpe","content":"<h1 id=\"Static-Query-on-Tree\"><a href=\"#Static-Query-on-Tree\" class=\"headerlink\" title=\"Static Query on Tree\"></a><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=7150\" target=\"_blank\" rel=\"noopener\">Static Query on Tree</a></h1><p>下面介绍树链剖分做法（即题解的第二种做法）</p>\n<p><img src=\"3388199031/image-20220722223108042.png\" alt=\"题目描述\"></p>\n<blockquote>\n<p>题目大意：</p>\n<p>一棵内向树，三个集合A，B，C，每个集合里面有一些点，求特定点的个数，满足从A集合和B集合可以到达该特定点，且可以从该特定点到达C集合。</p>\n</blockquote>\n<p>可以把从A集合到达根节点路径中都打上A标记，把从B集合到达根节点路径中都打上B标记，那么树中被打上A和B标记的就是A和B集合都可以到达的点。（因为是内向树，所以向根节点方向走）</p>\n<p>只需要判断这些打上A和B标记的点能否到达C节点即可，方法也是同样的，将C集合中的每个点和其子树上的点都打上C标记，只要统计树中同时被打上ABC标记的点的个数即可（此时可以用线段树维护标记）。</p>\n<p><strong>线段树记录变量</strong></p>\n<ul>\n<li>$tr[u].cnt[i]$</li>\n</ul>\n<p>$tr[u].cnt[i]$中的$i$有三个值，0，1，2，分别代表被打上A标记的点，被打上AB标记的点，被打上ABC标记的点。</p>\n<p>则$tr[u].cnt[i]$则共可以表示在对应的线段树节点表示的区间上被打上A标记的点的个数（$i = 0$），被打上AB标记的点的个数（$i = 1$），被打上ABC标记的点的个数（$i = 2$）。</p>\n<ul>\n<li>$tr[u].flag[i]$</li>\n</ul>\n<p>共有三个值<code>-1</code>，<code>0</code>， <code>1</code></p>\n<p>初始值等于<code>-1</code>，为<code>0</code>代表对应的区间置为0</p>\n<p>懒标记下传方法：</p>\n<p>在下传懒标记A时，因为A是第一次标记，无需其他条件，直接下传，记录一下<code>cnt</code>变量即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>mid <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>下传懒标记B和C时，就需要有限制条件了，下传懒标记B我们需要有A标记才能求被标记A和B的节点，即被标记AB的节点的数量等于被标记A节点的数量乘对应的懒标记。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\ntr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>接下来就是树链剖分的板子了，可以看下面链接</p>\n<p><a href=\"../shupou1000\">树链剖分模板题</a></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">2e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> Segment\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>tr<span class=\"token punctuation\">[</span>N <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> dep<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> fa<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> son<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">,</span> nw<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> e<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ne<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    e<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b<span class=\"token punctuation\">,</span> ne<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> idx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">pushup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">pushdown</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>mid <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> r<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pushup</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> x <span class=\"token operator\">&amp;&amp;</span> r <span class=\"token operator\">&lt;=</span> y<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span>d <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">pushdown</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">></span> mid<span class=\"token punctuation\">)</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pushup</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nll <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> x <span class=\"token operator\">&amp;&amp;</span> r <span class=\"token operator\">&lt;=</span> y<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cnt<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pushdown</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> ans <span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">></span> mid<span class=\"token punctuation\">)</span> ans <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ans <span class=\"token operator\">+</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//预处理dep[],fa[],sz[],son[](重儿子节点)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dfs1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> f<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> depth<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//x : 当前节点, f：父亲, depth：深度</span>\n<span class=\"token punctuation\">{</span>\n    dep<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> depth<span class=\"token punctuation\">;</span>\n    fa<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> f<span class=\"token punctuation\">;</span>\n    sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mxson <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">~</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> ne<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs1</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> mxson<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">// 记录重儿子编号</span>\n        <span class=\"token punctuation\">{</span>\n            son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n            mxson <span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> topf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>cnt<span class=\"token punctuation\">;</span>\n    nw<span class=\"token punctuation\">[</span>cnt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> topf<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//无儿子返回</span>\n    <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span>son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> topf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">~</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> ne<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">==</span> fa<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> y <span class=\"token operator\">==</span> son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nll <span class=\"token function\">queryRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//不在同一条链上</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        x <span class=\"token operator\">=</span> fa<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dep<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ans <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ans <span class=\"token operator\">+</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifyRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    v <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        x <span class=\"token operator\">=</span> fa<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dep<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nll <span class=\"token function\">querySon</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">int</span> tot<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> r <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> to<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> to<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">dfs1</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            cin <span class=\"token operator\">>></span> tot<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> tot<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                cin <span class=\"token operator\">>></span> node<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token function\">modifyRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">else</span>\n                    <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">querySon</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ios::sync_with_stdio(false);</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin.tie(0);</span>\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// t = 1;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"Static-Query-on-Tree\"><a href=\"#Static-Query-on-Tree\" class=\"headerlink\" title=\"Static Query on Tree\"></a><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=7150\" target=\"_blank\" rel=\"noopener\">Static Query on Tree</a></h1><p>下面介绍树链剖分做法（即题解的第二种做法）</p>\n<p><img src=\"3388199031/image-20220722223108042.png\" alt=\"题目描述\"></p>\n<blockquote>\n<p>题目大意：</p>\n<p>一棵内向树，三个集合A，B，C，每个集合里面有一些点，求特定点的个数，满足从A集合和B集合可以到达该特定点，且可以从该特定点到达C集合。</p>\n</blockquote>\n<p>可以把从A集合到达根节点路径中都打上A标记，把从B集合到达根节点路径中都打上B标记，那么树中被打上A和B标记的就是A和B集合都可以到达的点。（因为是内向树，所以向根节点方向走）</p>\n<p>只需要判断这些打上A和B标记的点能否到达C节点即可，方法也是同样的，将C集合中的每个点和其子树上的点都打上C标记，只要统计树中同时被打上ABC标记的点的个数即可（此时可以用线段树维护标记）。</p>\n<p><strong>线段树记录变量</strong></p>\n<ul>\n<li>$tr[u].cnt[i]$</li>\n</ul>\n<p>$tr[u].cnt[i]$中的$i$有三个值，0，1，2，分别代表被打上A标记的点，被打上AB标记的点，被打上ABC标记的点。</p>\n<p>则$tr[u].cnt[i]$则共可以表示在对应的线段树节点表示的区间上被打上A标记的点的个数（$i = 0$），被打上AB标记的点的个数（$i = 1$），被打上ABC标记的点的个数（$i = 2$）。</p>\n<ul>\n<li>$tr[u].flag[i]$</li>\n</ul>\n<p>共有三个值<code>-1</code>，<code>0</code>， <code>1</code></p>\n<p>初始值等于<code>-1</code>，为<code>0</code>代表对应的区间置为0</p>\n<p>懒标记下传方法：</p>\n<p>在下传懒标记A时，因为A是第一次标记，无需其他条件，直接下传，记录一下<code>cnt</code>变量即可。</p>\n<pre><code class=\"cpp\">tr[u &lt;&lt; 1].cnt[i] = tr[u].flag[i] * (mid - l + 1);\ntr[u &lt;&lt; 1 | 1].cnt[i] = tr[u].flag[i] * (r - mid); </code></pre>\n<p>下传懒标记B和C时，就需要有限制条件了，下传懒标记B我们需要有A标记才能求被标记A和B的节点，即被标记AB的节点的数量等于被标记A节点的数量乘对应的懒标记。</p>\n<pre><code class=\"cpp\">tr[u &lt;&lt; 1].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; 1].cnt[i - 1];\ntr[u &lt;&lt; 1 | 1].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; 1 | 1].cnt[i - 1];</code></pre>\n<p>接下来就是树链剖分的板子了，可以看下面链接</p>\n<p><a href=\"../shupou1000\">树链剖分模板题</a></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nconst int N = 2e5 + 5, M = 2 * N;\nconst int p = 1e9 + 7;\n\nint n, q;\n\nstruct Segment\n{\n    int cnt[3], flag[3];\n}tr[N * 4];\n\nint dep[N], fa[N], son[N], sz[N];\nint cnt, nw[N], top[N], id[N];\n\nint e[M], h[N], ne[M], idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid pushup(int u)\n{\n    for(int i = 0; i &lt; 3; i++)\n        tr[u].cnt[i] = tr[u &lt;&lt; 1].cnt[i] + tr[u &lt;&lt; 1 | 1].cnt[i];\n\n}\nvoid pushdown(int u, int l, int r)\n{\n    int mid = (l + r) &gt;&gt; 1;\n\n    for(int i = 0; i &lt; 3; i++)\n    {\n        if(tr[u].flag[i] == -1)\n            continue;\n        tr[u &lt;&lt; 1].flag[i] = tr[u].flag[i];\n        tr[u &lt;&lt; 1 | 1].flag[i] = tr[u].flag[i];\n        if(i == 0)\n        {\n            tr[u &lt;&lt; 1].cnt[i] = tr[u].flag[i] * (mid - l + 1);\n            tr[u &lt;&lt; 1 | 1].cnt[i] = tr[u].flag[i] * (r - mid); \n        }\n        else\n        {\n            tr[u &lt;&lt; 1].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; 1].cnt[i - 1];\n            tr[u &lt;&lt; 1 | 1].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; 1 | 1].cnt[i - 1];\n        }\n        tr[u].flag[i] = -1;\n    }\n}\n\nvoid build(int u, int l, int r)\n{\n    if(l == r)\n    {\n        for(int i = 0; i &lt; 3; i++)\n            tr[u].cnt[i] = 0;\n        for(int i = 0; i &lt; 3; i++)\n            tr[u].flag[i] = -1;\n        return;\n    }\n    int mid = (l + r) &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid);\n    build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n}\n\nvoid modify(int u, int l, int r, int x, int y, int d, int v)\n{\n    if(l &gt;= x &amp;&amp; r &lt;= y)\n    {\n        tr[u].flag[d] = v;\n        if(d == 0)\n            tr[u].cnt[0] = (r - l + 1) * v;\n        else tr[u].cnt[d] = tr[u].cnt[d - 1] * v;\n        return;\n    }\n    pushdown(u, l, r);\n    int mid = (l + r) &gt;&gt; 1;\n    if(x &lt;= mid) modify(u &lt;&lt; 1, l, mid, x, y, d, v);\n    if(y &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, x, y, d, v);\n    pushup(u);\n}\n\nll query(int u, int l, int r, int x, int y)\n{\n    if(l &gt;= x &amp;&amp; r &lt;= y)\n        return tr[u].cnt[2] % p;\n    pushdown(u, l, r);\n    int mid = (l + r) &gt;&gt; 1;\n    ll ans = 0;\n    if(x &lt;= mid) ans = query(u &lt;&lt; 1, l, mid, x, y) % p;\n    if(y &gt; mid) ans = (ans + query(u &lt;&lt; 1 | 1, mid + 1, r, x, y)) % p;\n    return ans;\n}\n\n//预处理dep[],fa[],sz[],son[](重儿子节点)\nvoid dfs1(int x, int f, int depth)//x : 当前节点, f：父亲, depth：深度\n{\n    dep[x] = depth;\n    fa[x] = f;\n    sz[x] = 1;\n    int mxson = -1;\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == f) continue;\n        dfs1(y, x, depth + 1);\n        sz[x] += sz[y];\n        if(sz[y] &gt; mxson)// 记录重儿子编号\n        {\n            son[x] = y;\n            mxson = sz[y];\n        }\n    }\n}\n\n// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端\nvoid dfs2(int x, int topf)\n{\n    id[x] = ++cnt;\n    nw[cnt] = w[x];\n    top[x] = topf;\n    if(!son[x]) return;//无儿子返回\n    dfs2(son[x], topf);\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == fa[x] || y == son[x])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nll queryRange(int x, int y)\n{\n    ll ans = 0;\n    while(top[x] != top[y])//不在同一条链上\n    {\n        if(dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        ans += query(1, 1, n, id[top[x]], id[x]);\n        ans %= p;\n        x = fa[top[x]];\n    }\n    if(dep[x] &gt; dep[y])\n        swap(x, y);\n    ans = (ans + query(1, 1, n, id[x], id[y])) % p;\n    return ans;\n}\n\nvoid modifyRange(int x, int y, int d, int v)\n{\n    v %= p;\n    while(top[x] != top[y])\n    {\n        if(dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        modify(1, 1, n, id[top[x]], id[x], d, v);\n        x = fa[top[x]];\n    }\n    if(dep[x] &gt; dep[y])\n        swap(x, y);\n    modify(1, 1, n, id[x], id[y], d, v);\n}\nll querySon(int x)\n{\n    return query(1, 1, n, id[x], id[x] + sz[x] - 1);  \n}\nvoid modifySon(int x, int d, int v)\n{\n    modify(1, 1, n, id[x], id[x] + sz[x] - 1, d, v);\n}\n\n\nint tot[3], node[4][N];\n\nvoid solve()\n{\n    cin &gt;&gt; n &gt;&gt; q;\n    int r = 1;\n    memset(h, -1, sizeof h);\n    for(int i = 2; i &lt;= n; i++)\n    {\n        int to;\n        cin &gt;&gt; to;\n        add(to, i);\n        add(i, to);\n    }\n    dfs1(r, -1, 1);\n    dfs2(r, r);\n    build(1, 1, n);\n    while(q--)\n    {\n        for(int i = 0; i &lt; 3; i++)\n            cin &gt;&gt; tot[i];\n        for(int i = 0; i &lt; 3; i++)\n            for(int j = 1; j &lt;= tot[i]; j++)\n            {\n                cin &gt;&gt; node[i][j];\n                if(i != 2)\n                    modifyRange(1, node[i][j], i, 1);\n                else\n                    modifySon(node[i][j], i, 1);\n            }\n        cout &lt;&lt; querySon(1) &lt;&lt; &quot;\\n&quot;;\n        modifySon(1, 0, 0);\n        modifySon(1, 1, 0);\n        modifySon(1, 2, 0);\n    }\n}\n\nint main()\n{\n    // ios::sync_with_stdio(false);\n    // cin.tie(0);\n    int t;\n    cin &gt;&gt; t;\n    // t = 1;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n"},{"title":"C++ STL超全总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":16970766,"date":"2022-06-22T07:54:47.000Z","password":null,"summary":null,"_content":"\n\n\n#  C++ STL常用内容总结\n\n我是以打算法竞赛的角度整理的STL知识点，**强调使用方法**，并不强调原理。\n\n下面会介绍很多C++ STL库里面的模板，在编程中STL犹如神器，实用简洁好用。\nSTL绝对让你受益无穷！\n\n\n\n\n## 👉[1.vector动态数组](https://blog.csdn.net/qq_50285142/article/details/122303529)👈\n\n## 👉[2.stack栈](https://blog.csdn.net/qq_50285142/article/details/122303786)👈\n\n## 👉[3.queue队列](https://blog.csdn.net/qq_50285142/article/details/122304056)👈\n\n\n## 👉[4.deque双端队列](https://blog.csdn.net/qq_50285142/article/details/114079022)👈\n\n## 👉[5.priority_queue优先队列](https://blog.csdn.net/qq_50285142/article/details/114078695)👈\n\n\n## 👉[6.map映射](https://blog.csdn.net/qq_50285142/article/details/120368977)👈\n\n## 👉[7.set集合](https://blog.csdn.net/qq_50285142/article/details/122304728)👈\n\n## 👉[8.pair二元组](https://blog.csdn.net/qq_50285142/article/details/122304842)👈\n\n## 👉[9.string字符串](https://blog.csdn.net/qq_50285142/article/details/114156051)👈\n\n## 👉[10.bitset](https://blog.csdn.net/qq_50285142/article/details/114186789)👈\n\n## 👉[11.array数组](https://blog.csdn.net/qq_50285142/article/details/122932215)👈\n\n## 👉[12.tuple元组](https://blog.csdn.net/qq_50285142/article/details/123000835)👈\n\n# STL相关内容\n\n## [C++ STL函数总结](https://wyq666.blog.csdn.net/article/details/120632337)\n\n\n\n------------------\n\n由于作者水平有限，内容纯手敲，整理可能有误。\n如果有哪些不足或者错误的地方，也希望大家督促我尽快改正哦，我会及时回复的。\n\n\n如有疑问，请加QQ交流群\n\n点击链接加入群聊： [https://jq.qq.com/?_wv=1027&k=tcepNzVd](https://jq.qq.com/?_wv=1027&k=tcepNzVd)\n","source":"_posts/C-STL超全总结.md","raw":"---\ntitle: C++ STL超全总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - C++\n  - STL\n  - 学习总结\ncategories:\n  - STL\nabbrlink: 16970766\ndate: 2022-06-22 15:54:47\npassword:\nsummary:\n---\n\n\n\n#  C++ STL常用内容总结\n\n我是以打算法竞赛的角度整理的STL知识点，**强调使用方法**，并不强调原理。\n\n下面会介绍很多C++ STL库里面的模板，在编程中STL犹如神器，实用简洁好用。\nSTL绝对让你受益无穷！\n\n\n\n\n## 👉[1.vector动态数组](https://blog.csdn.net/qq_50285142/article/details/122303529)👈\n\n## 👉[2.stack栈](https://blog.csdn.net/qq_50285142/article/details/122303786)👈\n\n## 👉[3.queue队列](https://blog.csdn.net/qq_50285142/article/details/122304056)👈\n\n\n## 👉[4.deque双端队列](https://blog.csdn.net/qq_50285142/article/details/114079022)👈\n\n## 👉[5.priority_queue优先队列](https://blog.csdn.net/qq_50285142/article/details/114078695)👈\n\n\n## 👉[6.map映射](https://blog.csdn.net/qq_50285142/article/details/120368977)👈\n\n## 👉[7.set集合](https://blog.csdn.net/qq_50285142/article/details/122304728)👈\n\n## 👉[8.pair二元组](https://blog.csdn.net/qq_50285142/article/details/122304842)👈\n\n## 👉[9.string字符串](https://blog.csdn.net/qq_50285142/article/details/114156051)👈\n\n## 👉[10.bitset](https://blog.csdn.net/qq_50285142/article/details/114186789)👈\n\n## 👉[11.array数组](https://blog.csdn.net/qq_50285142/article/details/122932215)👈\n\n## 👉[12.tuple元组](https://blog.csdn.net/qq_50285142/article/details/123000835)👈\n\n# STL相关内容\n\n## [C++ STL函数总结](https://wyq666.blog.csdn.net/article/details/120632337)\n\n\n\n------------------\n\n由于作者水平有限，内容纯手敲，整理可能有误。\n如果有哪些不足或者错误的地方，也希望大家督促我尽快改正哦，我会及时回复的。\n\n\n如有疑问，请加QQ交流群\n\n点击链接加入群聊： [https://jq.qq.com/?_wv=1027&k=tcepNzVd](https://jq.qq.com/?_wv=1027&k=tcepNzVd)\n","slug":"C-STL超全总结","published":1,"updated":"2022-08-10T00:45:00.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolgq000c6kuh3l1pp7mx","content":"<h1 id=\"C-STL常用内容总结\"><a href=\"#C-STL常用内容总结\" class=\"headerlink\" title=\"C++ STL常用内容总结\"></a>C++ STL常用内容总结</h1><p>我是以打算法竞赛的角度整理的STL知识点，<strong>强调使用方法</strong>，并不强调原理。</p>\n<p>下面会介绍很多C++ STL库里面的模板，在编程中STL犹如神器，实用简洁好用。<br>STL绝对让你受益无穷！</p>\n<h2 id=\"👉1-vector动态数组👈\"><a href=\"#👉1-vector动态数组👈\" class=\"headerlink\" title=\"👉1.vector动态数组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122303529\" target=\"_blank\" rel=\"noopener\">1.vector动态数组</a>👈</h2><h2 id=\"👉2-stack栈👈\"><a href=\"#👉2-stack栈👈\" class=\"headerlink\" title=\"👉2.stack栈👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122303786\" target=\"_blank\" rel=\"noopener\">2.stack栈</a>👈</h2><h2 id=\"👉3-queue队列👈\"><a href=\"#👉3-queue队列👈\" class=\"headerlink\" title=\"👉3.queue队列👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122304056\" target=\"_blank\" rel=\"noopener\">3.queue队列</a>👈</h2><h2 id=\"👉4-deque双端队列👈\"><a href=\"#👉4-deque双端队列👈\" class=\"headerlink\" title=\"👉4.deque双端队列👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114079022\" target=\"_blank\" rel=\"noopener\">4.deque双端队列</a>👈</h2><h2 id=\"👉5-priority-queue优先队列👈\"><a href=\"#👉5-priority-queue优先队列👈\" class=\"headerlink\" title=\"👉5.priority_queue优先队列👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114078695\" target=\"_blank\" rel=\"noopener\">5.priority_queue优先队列</a>👈</h2><h2 id=\"👉6-map映射👈\"><a href=\"#👉6-map映射👈\" class=\"headerlink\" title=\"👉6.map映射👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/120368977\" target=\"_blank\" rel=\"noopener\">6.map映射</a>👈</h2><h2 id=\"👉7-set集合👈\"><a href=\"#👉7-set集合👈\" class=\"headerlink\" title=\"👉7.set集合👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122304728\" target=\"_blank\" rel=\"noopener\">7.set集合</a>👈</h2><h2 id=\"👉8-pair二元组👈\"><a href=\"#👉8-pair二元组👈\" class=\"headerlink\" title=\"👉8.pair二元组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122304842\" target=\"_blank\" rel=\"noopener\">8.pair二元组</a>👈</h2><h2 id=\"👉9-string字符串👈\"><a href=\"#👉9-string字符串👈\" class=\"headerlink\" title=\"👉9.string字符串👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114156051\" target=\"_blank\" rel=\"noopener\">9.string字符串</a>👈</h2><h2 id=\"👉10-bitset👈\"><a href=\"#👉10-bitset👈\" class=\"headerlink\" title=\"👉10.bitset👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114186789\" target=\"_blank\" rel=\"noopener\">10.bitset</a>👈</h2><h2 id=\"👉11-array数组👈\"><a href=\"#👉11-array数组👈\" class=\"headerlink\" title=\"👉11.array数组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122932215\" target=\"_blank\" rel=\"noopener\">11.array数组</a>👈</h2><h2 id=\"👉12-tuple元组👈\"><a href=\"#👉12-tuple元组👈\" class=\"headerlink\" title=\"👉12.tuple元组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/123000835\" target=\"_blank\" rel=\"noopener\">12.tuple元组</a>👈</h2><h1 id=\"STL相关内容\"><a href=\"#STL相关内容\" class=\"headerlink\" title=\"STL相关内容\"></a>STL相关内容</h1><h2 id=\"C-STL函数总结\"><a href=\"#C-STL函数总结\" class=\"headerlink\" title=\"C++ STL函数总结\"></a><a href=\"https://wyq666.blog.csdn.net/article/details/120632337\" target=\"_blank\" rel=\"noopener\">C++ STL函数总结</a></h2><hr>\n<p>由于作者水平有限，内容纯手敲，整理可能有误。<br>如果有哪些不足或者错误的地方，也希望大家督促我尽快改正哦，我会及时回复的。</p>\n<p>如有疑问，请加QQ交流群</p>\n<p>点击链接加入群聊： <a href=\"https://jq.qq.com/?_wv=1027&k=tcepNzVd\" target=\"_blank\" rel=\"noopener\">https://jq.qq.com/?_wv=1027&amp;k=tcepNzVd</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"C-STL常用内容总结\"><a href=\"#C-STL常用内容总结\" class=\"headerlink\" title=\"C++ STL常用内容总结\"></a>C++ STL常用内容总结</h1><p>我是以打算法竞赛的角度整理的STL知识点，<strong>强调使用方法</strong>，并不强调原理。</p>\n<p>下面会介绍很多C++ STL库里面的模板，在编程中STL犹如神器，实用简洁好用。<br>STL绝对让你受益无穷！</p>\n<h2 id=\"👉1-vector动态数组👈\"><a href=\"#👉1-vector动态数组👈\" class=\"headerlink\" title=\"👉1.vector动态数组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122303529\" target=\"_blank\" rel=\"noopener\">1.vector动态数组</a>👈</h2><h2 id=\"👉2-stack栈👈\"><a href=\"#👉2-stack栈👈\" class=\"headerlink\" title=\"👉2.stack栈👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122303786\" target=\"_blank\" rel=\"noopener\">2.stack栈</a>👈</h2><h2 id=\"👉3-queue队列👈\"><a href=\"#👉3-queue队列👈\" class=\"headerlink\" title=\"👉3.queue队列👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122304056\" target=\"_blank\" rel=\"noopener\">3.queue队列</a>👈</h2><h2 id=\"👉4-deque双端队列👈\"><a href=\"#👉4-deque双端队列👈\" class=\"headerlink\" title=\"👉4.deque双端队列👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114079022\" target=\"_blank\" rel=\"noopener\">4.deque双端队列</a>👈</h2><h2 id=\"👉5-priority-queue优先队列👈\"><a href=\"#👉5-priority-queue优先队列👈\" class=\"headerlink\" title=\"👉5.priority_queue优先队列👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114078695\" target=\"_blank\" rel=\"noopener\">5.priority_queue优先队列</a>👈</h2><h2 id=\"👉6-map映射👈\"><a href=\"#👉6-map映射👈\" class=\"headerlink\" title=\"👉6.map映射👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/120368977\" target=\"_blank\" rel=\"noopener\">6.map映射</a>👈</h2><h2 id=\"👉7-set集合👈\"><a href=\"#👉7-set集合👈\" class=\"headerlink\" title=\"👉7.set集合👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122304728\" target=\"_blank\" rel=\"noopener\">7.set集合</a>👈</h2><h2 id=\"👉8-pair二元组👈\"><a href=\"#👉8-pair二元组👈\" class=\"headerlink\" title=\"👉8.pair二元组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122304842\" target=\"_blank\" rel=\"noopener\">8.pair二元组</a>👈</h2><h2 id=\"👉9-string字符串👈\"><a href=\"#👉9-string字符串👈\" class=\"headerlink\" title=\"👉9.string字符串👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114156051\" target=\"_blank\" rel=\"noopener\">9.string字符串</a>👈</h2><h2 id=\"👉10-bitset👈\"><a href=\"#👉10-bitset👈\" class=\"headerlink\" title=\"👉10.bitset👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/114186789\" target=\"_blank\" rel=\"noopener\">10.bitset</a>👈</h2><h2 id=\"👉11-array数组👈\"><a href=\"#👉11-array数组👈\" class=\"headerlink\" title=\"👉11.array数组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/122932215\" target=\"_blank\" rel=\"noopener\">11.array数组</a>👈</h2><h2 id=\"👉12-tuple元组👈\"><a href=\"#👉12-tuple元组👈\" class=\"headerlink\" title=\"👉12.tuple元组👈\"></a>👉<a href=\"https://blog.csdn.net/qq_50285142/article/details/123000835\" target=\"_blank\" rel=\"noopener\">12.tuple元组</a>👈</h2><h1 id=\"STL相关内容\"><a href=\"#STL相关内容\" class=\"headerlink\" title=\"STL相关内容\"></a>STL相关内容</h1><h2 id=\"C-STL函数总结\"><a href=\"#C-STL函数总结\" class=\"headerlink\" title=\"C++ STL函数总结\"></a><a href=\"https://wyq666.blog.csdn.net/article/details/120632337\" target=\"_blank\" rel=\"noopener\">C++ STL函数总结</a></h2><hr>\n<p>由于作者水平有限，内容纯手敲，整理可能有误。<br>如果有哪些不足或者错误的地方，也希望大家督促我尽快改正哦，我会及时回复的。</p>\n<p>如有疑问，请加QQ交流群</p>\n<p>点击链接加入群聊： <a href=\"https://jq.qq.com/?_wv=1027&k=tcepNzVd\" target=\"_blank\" rel=\"noopener\">https://jq.qq.com/?_wv=1027&amp;k=tcepNzVd</a></p>\n"},{"title":"2022牛客多校1补题","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":2541904761,"date":"2022-08-21T14:57:49.000Z","password":null,"summary":null,"_content":"\n# 2022牛客多校1补题\n\n题解有`A C D G I J`六题。\n\n题解纯属自己玩，更多详细解释还请看官方题解。\n\n# G\n\n## 题意\n\n给定 $n$ ，将 $1,2,. . . , n$ 视为不含前导零的字符串\n\n求这些字符串中字典序最大的字符串\n\n## 思路\n\n只需要在 $|n|-1$ 个9和 $n$ 两个答案之中进行选择。\n\n- $n$去除最后一位其余均为9，答案为 $n$\n- 否则为 $|n|-1$ 个9\n\n复杂度 ： $O(|n|)$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tstring s;\n\tcin >> s;\n\tstring t = string(s.size() - 1, '9');\n\tif(s.substr(0, s.size() - 1) == t) cout << s << \"\\n\";\n\telse cout << t << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# A\n\n## 题意\n\n$n$个区间 $[x_i-r_i, x_i+r_i]$ ，求 $n$ 个区间并之后的区间的空隙长度和。\n\n## 思路\n\n贪心，将区间按左端点从小到大排序，从前往后扫一遍，不断维护维护区间右端点 $r$ 。若当前区间的左端点小于 $r$ ，可以进行合并，并且更新区间右端点；若当前区间的左端点大于 $r$ ，计算答案。\n\n> 注意第一个区间的判断以及 $r$ 的初始值。\n\n复杂度 ： $O(nlogn)$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvector<pii> a(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint c, r;\n\t\tcin >> c >> r;\n\t\ta[i] = {c - r, c + r};\n\t}\n\tsort(a.begin(), a.end());\n\tll ans = 0, rr = -1e18;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll l = a[i].first, r = a[i].second;\n\t\tif(l > rr && i)\n\t\t\tans += (l - rr);\n\t\trr = max(rr, r);\n\t}\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# D\n\n## 题意\n\n给定一个圆和严格位于圆内的一点 $P$\n\nMocha 会从点 $P$ 向任意角度发射一个长度为 $2d$ 的电磁炮\n\n电磁炮底边的中点为点P且两端位于圆内\n\n询问单次发射能摧毁的最大圆弧长\n\n$1≤T≤1000,-10^9≤ x, y ≤10^9,1 ≤r, d≤10^9$\n\n## 思路\n\n将电磁炮方向转化为竖直向上：无论当前的电磁炮旋转角度如何，我们可以固定电磁炮的方向，将点 $P$ 绕原点旋转，从而使得电磁炮方向竖直向上（即 $y$ 轴正方向）。\n\n那么可以将题目转化成为电磁炮的方向总是竖直向上的，点 P 绕原点旋转一周的过程中可以摧毁的最长墙壁长度。\n\n那么我们设点 P 到原点距离是 $dis$，点 Q 绕原点旋转一周就可以转化成点Q在以 $(-dis,0)$ 和 $(dis,0)$ 为端点的线段上移动。\n\n下面用一张动图来说明：当点 Q 位于 $x$ 轴上时，产生的弧长最长。\n\n![](https://uploadfiles.nowcoder.com/images/20220724/543419382_1658594584578/2CB7686E53E6883E02FCAA79818B7E3B)\n\n所以画图进行计算，我们计算弧度以此来算弧长。 $L = \\alpha R$\n\n>  当我们使用 $sin$ 计算时，因为正弦的 $0°-180°$表示并不唯一，所以需要分情况讨论 $dis > d$ 和 $dis < d$\n>\n> 当我们使用 $cos$ 计算时，$cos$ 可以唯一表示 $0-180$ 度，所以不需要分类讨论。\n\n![图示](2541904761/image-20220821221513603.png)\n\n以 $cos$ 计算为例：\n\n$\\alpha = arccos(\\frac{dis - d}{r})$\n\n$\\beta = arcos(\\frac{dis + d}{r})$\n\n$L = (\\alpha - \\beta) \\times r$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tint r, x, y, d;\n\tcin >> r >> x >> y >> d;\n\n\tdouble dis = sqrt(1ll * x * x + 1ll * y * y);\n\n\tcout << fixed << setprecision(12);\n\tdouble a = acos((dis + d) / r);\n\tdouble b = acos((dis - d) / r);\n\tcout << (b - a) * r << \"\\n\";\n\t// if(dis > d)\n\t// {\n\t// \tdouble a = asin((dis + d) / r);\n\t// \tdouble b = asin((dis - d) / r);\n\t// \tcout << r * (a - b) << \"\\n\";\n\t// }\n\t// else\n\t// {\n\t// \tdouble a = asin((d + dis) / r);\n\t// \tdouble b = asin((d - dis) / r);\n\t// \tcout << r * (a + b) << \"\\n\";\n\t// }\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# C\n\n## 题意\n\n一个二维平面，黑板为 $(0,1)-(0,m)$ 的线段， $n$ 行 $m$ 列座位在黑板前面，均为整数坐标。\n\n$k$ 个位置有人，求到黑板视线不被任何人挡住的座位数量。\n\n$q$ 次询问，修改一个人的坐标要求计算答案。\n\n$2 \\leq n,m \\leq 2\\times10^5, 1 \\leq k \\leq 2 \\times10 ^ 5, 1 \\leq q \\leq 200$\n\n## 思路\n\n每个人会挡住自己右边的人。每个人挡住的区域为一个折线右边的区域。\n\n每次询问维护 $mn[i], X[i]$\n\n$mn[i]$ ： 纵坐标为 $i$ 时最大不被遮挡的人的横坐标。\n\n$X[i]$ : 纵坐标为 $i$ 时，被遮挡的座位的最小横坐标。\n\n可以发现一个性质，当纵坐标从小到大时，如果新出现的点 $(X[i], i)$ 与 $(0,1)$ 构成的斜率更大，如果遮挡纵坐标更大的点时，也是该点遮挡后面的点。\n\n时间复杂度 ： $O(mq)$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tint n, m, k, q;\n\tcin >> n >> m >> k >> q;\n\n\tvl x(k + 1), y(x), X(m + 1, n + 1), mn(m + 1, n);\n\n\tfor(int i = 1; i <= k; i++)\n\t\tcin >> x[i] >> y[i];\n\n\twhile(q--)\n\t{\n\t\tint id;\n\t\tcin >> id;\n\t\tcin >> x[id] >> y[id];\n\n\t\tfor(int i = 1; i <= m; i++)\n\t\t\tmn[i] = n, X[i] = n + 1;\n\n\t\tfor(int i = 1; i <= k; i++)\n\t\t\tX[y[i]] = min(X[y[i]], x[i]);\n\n\t\tint j = 0;\n\t\t// 从下往上\n\t\tfor(int i = 1; i <= m; i++)\n\t\t{\n\t\t\t// (0, 1)(X[i], i) (0, 1)(X[j], j)\n\t\t\tif(X[i] != n + 1 && (!j || (i - 1) * X[j] > (j - 1) * X[i]))\n\t\t\t\tj = i;\n\n\t\t\tif(j == 1)\n\t\t\t\tmn[i] = min(mn[i], i == 1 ? X[i] - 1 : n);\n\t\t\telse // y = kx+1 = (j - 1)/X[j] x + 1 = i\n\t\t\t\tmn[i] = min(mn[i], j ? ((i - 1) * X[j] - 1) / (j - 1) : n);\n\t\t}\n\n\t\tj = 0;\n\t\tfor(int i = m; i >= 1; i--)\n\t\t{\n\t\t\t// (0,m)(X[i],i) (0,m)(X[j],j)\n\t\t\tif(X[i] != n + 1 && (!j || (i - m) * X[j] < (j - m) * X[i]))\n\t\t\t\tj = i;\n\n\t\t\tif(j == m)\n\t\t\t\tmn[i] = min(mn[i], i == m ? X[i] - 1 : n);\n\t\t\telse // y = kx+m = (j-m)/X[j] x + m = i\n\t\t\t\tmn[i] = min(mn[i], j ? ((m - i) * X[j] - 1) / (m - j) : n);\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i = 1; i <= m; i++)\n\t\t\tans += mn[i];\n\t\tcout << ans << \"\\n\";\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# I\n\n## 题意\n\n初始手牌有13张麻将牌，相同牌至多出现2张\n\n每轮可以从牌堆摸牌，若达成七对子则自摸胡牌\n\n若不然则选择手牌中某张牌并丢弃之\n\n给定初始手牌，求最优策略下达成七对子的期望轮数\n\n多组数据，数据组数不超过 $10^5$ 组\n\n## 思路\n\n期望DP\n\n$f[i][j]$ : 有 $j$ 张单排，牌堆剩余 $i$ 张的期望轮数\n\n$f[i][j] = \\frac{3 \\times j}{i} \\times (1 + f[i - 1][j - 2]) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$\n\n当 $j = 1$ 时， $f[i][j] =  \\frac{3 \\times j}{i} \\times (1 + 0) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$\n\n初始手牌单牌数量为 $cnt$ ，答案为 $f[136-13][cnt]$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nll f[150][15];\nll ksm(ll a, ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = res * a % mod;\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res % mod;\n}\nvoid init()\n{\n\tfor(int i = 1; i <= 123; i++)\n\t{\n\t\tll inv = ksm(i, mod - 2);\t\n\t\tfor(int j = 1; j <= 13; j++)\n\t\t{\n\t\t\tf[i][j] = (1 + \n\t\t\t\tf[i - 1][max(0, j - 2)] * (3 * j) % mod * inv % mod + \n\t\t\t\tf[i - 1][j] * (i - 3 * j) % mod * inv % mod) % mod;\n\t\t}\n\t}\n}\nll solve()\n{\n\tstring s;\n\tcin >> s;\n\tint cnt = 0;\n\tunordered_map<string, int> mp;\n\tfor(int i = 0; i < int(s.size()); i += 2)\n\t{\n\t\tif(mp[s.substr(i, 2)]) cnt--;\n\t\telse cnt++;\n\t\tmp[s.substr(i, 2)] ++;\n\t}\n\treturn f[123][cnt];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tinit();\n\tint t;\n\tt = 1;\n\tcin >> t;\n\tfor(int i = 1; i <= t; i++)\n\t\tcout << \"Case #\" << i << \": \" << solve() << \"\\n\";\n\treturn 0;\n}\n```\n\n\n\n# J\n\n## 题意\n\n有一张 n 个点 m 条边的无重边无自环的有向图\n\n初始时可以选择一个点染黑，其余点均为白点\n\n若某个点所有入边的起点均为黑点，则该点可以被染黑\n\n最大化图中黑点数量\n\n## 思路\n\n启发式合并。\n\n当一个点的入度为 1 ，那么该点的前驱染黑的话，该点一定也被染黑。那么可以将该点和该点的前驱进行缩点合并看做一个集合。\n\n因为每个点都可能会有对应的出边，而合并的两个点的出边可能会有重复，就要进行去重，因为缩点之后的出边只能有一条。去重就可以用到 `set`  ，自带去重操作。\n\n合并的时候也有技巧，通过出边数较小的点合并到出边数较大的点身上，也就是启发式合并（类似并查集中的合并），达到减小时间复杂度的目的。\n\n递归合并即可，最后输出合并后最大的块。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 2e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nint f[N], sz[N];\nset<int> in[N], out[N];\nint find(int x)\n{\n\tif(x == f[x])\n\t\treturn x;\n\treturn f[x] = find(f[x]);\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x), y = find(y);\n\tif(x == y) return;\n\tif(out[x].size() < out[y].size())\n\t\tswap(x, y);\n\n\tf[y] = x;\n\tsz[x] += sz[y];\n\n\tvi q;\n\tfor(auto v : out[y])\n\t{\n\t\tout[x].insert(v);\n\t\tin[v].erase(y);\n\t\tin[v].insert(x);\n\t\tif(in[v].size() == 1)\n\t\t\tq.push_back(v);\n\t}\n\tfor(auto v : q)\n\t\tmerge(x, v);\n}\n\n\nint solve()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tin[i].clear(), out[i].clear();\n\t\tf[i] = i;\n\t\tsz[i] = 1;\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 1; j <= k; j++)\n\t\t{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tin[i].insert(u);\n\t\t\tout[u].insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(in[i].size() == 1)\n\t\t\tmerge(i, *in[i].begin());\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = max(ans, sz[i]);\n\treturn ans;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\tfor(int i = 1; i <= t; i++)\n\t\tcout << \"Case #\" << i << \": \" << solve() << \"\\n\";\n\treturn 0;\n}\n```\n\n","source":"_posts/2022牛客多校1.md","raw":"---\ntitle: 2022牛客多校1补题\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 多校\ncategories:\n  - 多校\nabbrlink: 2541904761\ndate: 2022-08-21 22:57:49\npassword:\nsummary:\n---\n\n# 2022牛客多校1补题\n\n题解有`A C D G I J`六题。\n\n题解纯属自己玩，更多详细解释还请看官方题解。\n\n# G\n\n## 题意\n\n给定 $n$ ，将 $1,2,. . . , n$ 视为不含前导零的字符串\n\n求这些字符串中字典序最大的字符串\n\n## 思路\n\n只需要在 $|n|-1$ 个9和 $n$ 两个答案之中进行选择。\n\n- $n$去除最后一位其余均为9，答案为 $n$\n- 否则为 $|n|-1$ 个9\n\n复杂度 ： $O(|n|)$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tstring s;\n\tcin >> s;\n\tstring t = string(s.size() - 1, '9');\n\tif(s.substr(0, s.size() - 1) == t) cout << s << \"\\n\";\n\telse cout << t << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# A\n\n## 题意\n\n$n$个区间 $[x_i-r_i, x_i+r_i]$ ，求 $n$ 个区间并之后的区间的空隙长度和。\n\n## 思路\n\n贪心，将区间按左端点从小到大排序，从前往后扫一遍，不断维护维护区间右端点 $r$ 。若当前区间的左端点小于 $r$ ，可以进行合并，并且更新区间右端点；若当前区间的左端点大于 $r$ ，计算答案。\n\n> 注意第一个区间的判断以及 $r$ 的初始值。\n\n复杂度 ： $O(nlogn)$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvector<pii> a(n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint c, r;\n\t\tcin >> c >> r;\n\t\ta[i] = {c - r, c + r};\n\t}\n\tsort(a.begin(), a.end());\n\tll ans = 0, rr = -1e18;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll l = a[i].first, r = a[i].second;\n\t\tif(l > rr && i)\n\t\t\tans += (l - rr);\n\t\trr = max(rr, r);\n\t}\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# D\n\n## 题意\n\n给定一个圆和严格位于圆内的一点 $P$\n\nMocha 会从点 $P$ 向任意角度发射一个长度为 $2d$ 的电磁炮\n\n电磁炮底边的中点为点P且两端位于圆内\n\n询问单次发射能摧毁的最大圆弧长\n\n$1≤T≤1000,-10^9≤ x, y ≤10^9,1 ≤r, d≤10^9$\n\n## 思路\n\n将电磁炮方向转化为竖直向上：无论当前的电磁炮旋转角度如何，我们可以固定电磁炮的方向，将点 $P$ 绕原点旋转，从而使得电磁炮方向竖直向上（即 $y$ 轴正方向）。\n\n那么可以将题目转化成为电磁炮的方向总是竖直向上的，点 P 绕原点旋转一周的过程中可以摧毁的最长墙壁长度。\n\n那么我们设点 P 到原点距离是 $dis$，点 Q 绕原点旋转一周就可以转化成点Q在以 $(-dis,0)$ 和 $(dis,0)$ 为端点的线段上移动。\n\n下面用一张动图来说明：当点 Q 位于 $x$ 轴上时，产生的弧长最长。\n\n![](https://uploadfiles.nowcoder.com/images/20220724/543419382_1658594584578/2CB7686E53E6883E02FCAA79818B7E3B)\n\n所以画图进行计算，我们计算弧度以此来算弧长。 $L = \\alpha R$\n\n>  当我们使用 $sin$ 计算时，因为正弦的 $0°-180°$表示并不唯一，所以需要分情况讨论 $dis > d$ 和 $dis < d$\n>\n> 当我们使用 $cos$ 计算时，$cos$ 可以唯一表示 $0-180$ 度，所以不需要分类讨论。\n\n![图示](2541904761/image-20220821221513603.png)\n\n以 $cos$ 计算为例：\n\n$\\alpha = arccos(\\frac{dis - d}{r})$\n\n$\\beta = arcos(\\frac{dis + d}{r})$\n\n$L = (\\alpha - \\beta) \\times r$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tint r, x, y, d;\n\tcin >> r >> x >> y >> d;\n\n\tdouble dis = sqrt(1ll * x * x + 1ll * y * y);\n\n\tcout << fixed << setprecision(12);\n\tdouble a = acos((dis + d) / r);\n\tdouble b = acos((dis - d) / r);\n\tcout << (b - a) * r << \"\\n\";\n\t// if(dis > d)\n\t// {\n\t// \tdouble a = asin((dis + d) / r);\n\t// \tdouble b = asin((dis - d) / r);\n\t// \tcout << r * (a - b) << \"\\n\";\n\t// }\n\t// else\n\t// {\n\t// \tdouble a = asin((d + dis) / r);\n\t// \tdouble b = asin((d - dis) / r);\n\t// \tcout << r * (a + b) << \"\\n\";\n\t// }\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# C\n\n## 题意\n\n一个二维平面，黑板为 $(0,1)-(0,m)$ 的线段， $n$ 行 $m$ 列座位在黑板前面，均为整数坐标。\n\n$k$ 个位置有人，求到黑板视线不被任何人挡住的座位数量。\n\n$q$ 次询问，修改一个人的坐标要求计算答案。\n\n$2 \\leq n,m \\leq 2\\times10^5, 1 \\leq k \\leq 2 \\times10 ^ 5, 1 \\leq q \\leq 200$\n\n## 思路\n\n每个人会挡住自己右边的人。每个人挡住的区域为一个折线右边的区域。\n\n每次询问维护 $mn[i], X[i]$\n\n$mn[i]$ ： 纵坐标为 $i$ 时最大不被遮挡的人的横坐标。\n\n$X[i]$ : 纵坐标为 $i$ 时，被遮挡的座位的最小横坐标。\n\n可以发现一个性质，当纵坐标从小到大时，如果新出现的点 $(X[i], i)$ 与 $(0,1)$ 构成的斜率更大，如果遮挡纵坐标更大的点时，也是该点遮挡后面的点。\n\n时间复杂度 ： $O(mq)$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tint n, m, k, q;\n\tcin >> n >> m >> k >> q;\n\n\tvl x(k + 1), y(x), X(m + 1, n + 1), mn(m + 1, n);\n\n\tfor(int i = 1; i <= k; i++)\n\t\tcin >> x[i] >> y[i];\n\n\twhile(q--)\n\t{\n\t\tint id;\n\t\tcin >> id;\n\t\tcin >> x[id] >> y[id];\n\n\t\tfor(int i = 1; i <= m; i++)\n\t\t\tmn[i] = n, X[i] = n + 1;\n\n\t\tfor(int i = 1; i <= k; i++)\n\t\t\tX[y[i]] = min(X[y[i]], x[i]);\n\n\t\tint j = 0;\n\t\t// 从下往上\n\t\tfor(int i = 1; i <= m; i++)\n\t\t{\n\t\t\t// (0, 1)(X[i], i) (0, 1)(X[j], j)\n\t\t\tif(X[i] != n + 1 && (!j || (i - 1) * X[j] > (j - 1) * X[i]))\n\t\t\t\tj = i;\n\n\t\t\tif(j == 1)\n\t\t\t\tmn[i] = min(mn[i], i == 1 ? X[i] - 1 : n);\n\t\t\telse // y = kx+1 = (j - 1)/X[j] x + 1 = i\n\t\t\t\tmn[i] = min(mn[i], j ? ((i - 1) * X[j] - 1) / (j - 1) : n);\n\t\t}\n\n\t\tj = 0;\n\t\tfor(int i = m; i >= 1; i--)\n\t\t{\n\t\t\t// (0,m)(X[i],i) (0,m)(X[j],j)\n\t\t\tif(X[i] != n + 1 && (!j || (i - m) * X[j] < (j - m) * X[i]))\n\t\t\t\tj = i;\n\n\t\t\tif(j == m)\n\t\t\t\tmn[i] = min(mn[i], i == m ? X[i] - 1 : n);\n\t\t\telse // y = kx+m = (j-m)/X[j] x + m = i\n\t\t\t\tmn[i] = min(mn[i], j ? ((m - i) * X[j] - 1) / (m - j) : n);\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i = 1; i <= m; i++)\n\t\t\tans += mn[i];\n\t\tcout << ans << \"\\n\";\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# I\n\n## 题意\n\n初始手牌有13张麻将牌，相同牌至多出现2张\n\n每轮可以从牌堆摸牌，若达成七对子则自摸胡牌\n\n若不然则选择手牌中某张牌并丢弃之\n\n给定初始手牌，求最优策略下达成七对子的期望轮数\n\n多组数据，数据组数不超过 $10^5$ 组\n\n## 思路\n\n期望DP\n\n$f[i][j]$ : 有 $j$ 张单排，牌堆剩余 $i$ 张的期望轮数\n\n$f[i][j] = \\frac{3 \\times j}{i} \\times (1 + f[i - 1][j - 2]) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$\n\n当 $j = 1$ 时， $f[i][j] =  \\frac{3 \\times j}{i} \\times (1 + 0) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$\n\n初始手牌单牌数量为 $cnt$ ，答案为 $f[136-13][cnt]$\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nll f[150][15];\nll ksm(ll a, ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = res * a % mod;\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res % mod;\n}\nvoid init()\n{\n\tfor(int i = 1; i <= 123; i++)\n\t{\n\t\tll inv = ksm(i, mod - 2);\t\n\t\tfor(int j = 1; j <= 13; j++)\n\t\t{\n\t\t\tf[i][j] = (1 + \n\t\t\t\tf[i - 1][max(0, j - 2)] * (3 * j) % mod * inv % mod + \n\t\t\t\tf[i - 1][j] * (i - 3 * j) % mod * inv % mod) % mod;\n\t\t}\n\t}\n}\nll solve()\n{\n\tstring s;\n\tcin >> s;\n\tint cnt = 0;\n\tunordered_map<string, int> mp;\n\tfor(int i = 0; i < int(s.size()); i += 2)\n\t{\n\t\tif(mp[s.substr(i, 2)]) cnt--;\n\t\telse cnt++;\n\t\tmp[s.substr(i, 2)] ++;\n\t}\n\treturn f[123][cnt];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tinit();\n\tint t;\n\tt = 1;\n\tcin >> t;\n\tfor(int i = 1; i <= t; i++)\n\t\tcout << \"Case #\" << i << \": \" << solve() << \"\\n\";\n\treturn 0;\n}\n```\n\n\n\n# J\n\n## 题意\n\n有一张 n 个点 m 条边的无重边无自环的有向图\n\n初始时可以选择一个点染黑，其余点均为白点\n\n若某个点所有入边的起点均为黑点，则该点可以被染黑\n\n最大化图中黑点数量\n\n## 思路\n\n启发式合并。\n\n当一个点的入度为 1 ，那么该点的前驱染黑的话，该点一定也被染黑。那么可以将该点和该点的前驱进行缩点合并看做一个集合。\n\n因为每个点都可能会有对应的出边，而合并的两个点的出边可能会有重复，就要进行去重，因为缩点之后的出边只能有一条。去重就可以用到 `set`  ，自带去重操作。\n\n合并的时候也有技巧，通过出边数较小的点合并到出边数较大的点身上，也就是启发式合并（类似并查集中的合并），达到减小时间复杂度的目的。\n\n递归合并即可，最后输出合并后最大的块。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 2e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nint f[N], sz[N];\nset<int> in[N], out[N];\nint find(int x)\n{\n\tif(x == f[x])\n\t\treturn x;\n\treturn f[x] = find(f[x]);\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x), y = find(y);\n\tif(x == y) return;\n\tif(out[x].size() < out[y].size())\n\t\tswap(x, y);\n\n\tf[y] = x;\n\tsz[x] += sz[y];\n\n\tvi q;\n\tfor(auto v : out[y])\n\t{\n\t\tout[x].insert(v);\n\t\tin[v].erase(y);\n\t\tin[v].insert(x);\n\t\tif(in[v].size() == 1)\n\t\t\tq.push_back(v);\n\t}\n\tfor(auto v : q)\n\t\tmerge(x, v);\n}\n\n\nint solve()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tin[i].clear(), out[i].clear();\n\t\tf[i] = i;\n\t\tsz[i] = 1;\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 1; j <= k; j++)\n\t\t{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tin[i].insert(u);\n\t\t\tout[u].insert(i);\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(in[i].size() == 1)\n\t\t\tmerge(i, *in[i].begin());\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = max(ans, sz[i]);\n\treturn ans;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\tfor(int i = 1; i <= t; i++)\n\t\tcout << \"Case #\" << i << \": \" << solve() << \"\\n\";\n\treturn 0;\n}\n```\n\n","slug":"2022牛客多校1","published":1,"updated":"2022-08-21T15:01:19.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolgv000g6kuh8j4lomii","content":"<h1 id=\"2022牛客多校1补题\"><a href=\"#2022牛客多校1补题\" class=\"headerlink\" title=\"2022牛客多校1补题\"></a>2022牛客多校1补题</h1><p>题解有<code>A C D G I J</code>六题。</p>\n<p>题解纯属自己玩，更多详细解释还请看官方题解。</p>\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定 $n$ ，将 $1,2,. . . , n$ 视为不含前导零的字符串</p>\n<p>求这些字符串中字典序最大的字符串</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>只需要在 $|n|-1$ 个9和 $n$ 两个答案之中进行选择。</p>\n<ul>\n<li>$n$去除最后一位其余均为9，答案为 $n$</li>\n<li>否则为 $|n|-1$ 个9</li>\n</ul>\n<p>复杂度 ： $O(|n|)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    string s<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">;</span>\n    string t <span class=\"token operator\">=</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> t<span class=\"token punctuation\">)</span> cout <span class=\"token operator\">&lt;&lt;</span> s <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> cout <span class=\"token operator\">&lt;&lt;</span> t <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><h2 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>$n$个区间 $[x_i-r_i, x_i+r_i]$ ，求 $n$ 个区间并之后的区间的空隙长度和。</p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>贪心，将区间按左端点从小到大排序，从前往后扫一遍，不断维护维护区间右端点 $r$ 。若当前区间的左端点小于 $r$ ，可以进行合并，并且更新区间右端点；若当前区间的左端点大于 $r$ ，计算答案。</p>\n<blockquote>\n<p>注意第一个区间的判断以及 $r$ 的初始值。</p>\n</blockquote>\n<p>复杂度 ： $O(nlogn)$</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span>pii<span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> c <span class=\"token operator\">>></span> r<span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>c <span class=\"token operator\">-</span> r<span class=\"token punctuation\">,</span> c <span class=\"token operator\">+</span> r<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> rr <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1e18</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        ll l <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> r <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">></span> rr <span class=\"token operator\">&amp;&amp;</span> i<span class=\"token punctuation\">)</span>\n            ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">-</span> rr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        rr <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>rr<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><h2 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一个圆和严格位于圆内的一点 $P$</p>\n<p>Mocha 会从点 $P$ 向任意角度发射一个长度为 $2d$ 的电磁炮</p>\n<p>电磁炮底边的中点为点P且两端位于圆内</p>\n<p>询问单次发射能摧毁的最大圆弧长</p>\n<p>$1≤T≤1000,-10^9≤ x, y ≤10^9,1 ≤r, d≤10^9$</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>将电磁炮方向转化为竖直向上：无论当前的电磁炮旋转角度如何，我们可以固定电磁炮的方向，将点 $P$ 绕原点旋转，从而使得电磁炮方向竖直向上（即 $y$ 轴正方向）。</p>\n<p>那么可以将题目转化成为电磁炮的方向总是竖直向上的，点 P 绕原点旋转一周的过程中可以摧毁的最长墙壁长度。</p>\n<p>那么我们设点 P 到原点距离是 $dis$，点 Q 绕原点旋转一周就可以转化成点Q在以 $(-dis,0)$ 和 $(dis,0)$ 为端点的线段上移动。</p>\n<p>下面用一张动图来说明：当点 Q 位于 $x$ 轴上时，产生的弧长最长。</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20220724/543419382_1658594584578/2CB7686E53E6883E02FCAA79818B7E3B\" alt></p>\n<p>所以画图进行计算，我们计算弧度以此来算弧长。 $L = \\alpha R$</p>\n<blockquote>\n<p> 当我们使用 $sin$ 计算时，因为正弦的 $0°-180°$表示并不唯一，所以需要分情况讨论 $dis &gt; d$ 和 $dis &lt; d$</p>\n<p>当我们使用 $cos$ 计算时，$cos$ 可以唯一表示 $0-180$ 度，所以不需要分类讨论。</p>\n</blockquote>\n<p><img src=\"2541904761/image-20220821221513603.png\" alt=\"图示\"></p>\n<p>以 $cos$ 计算为例：</p>\n<p>$\\alpha = arccos(\\frac{dis - d}{r})$</p>\n<p>$\\beta = arcos(\\frac{dis + d}{r})$</p>\n<p>$L = (\\alpha - \\beta) \\times r$</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> r <span class=\"token operator\">>></span> x <span class=\"token operator\">>></span> y <span class=\"token operator\">>></span> d<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">double</span> dis <span class=\"token operator\">=</span> <span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> x <span class=\"token operator\">*</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> y <span class=\"token operator\">*</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    cout <span class=\"token operator\">&lt;&lt;</span> fixed <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">setprecision</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">double</span> a <span class=\"token operator\">=</span> <span class=\"token function\">acos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>dis <span class=\"token operator\">+</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> <span class=\"token function\">acos</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>dis <span class=\"token operator\">-</span> d<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> r <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// if(dis > d)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// {</span>\n    <span class=\"token comment\" spellcheck=\"true\">//     double a = asin((dis + d) / r);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//     double b = asin((dis - d) / r);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//     cout &lt;&lt; r * (a - b) &lt;&lt; \"\\n\";</span>\n    <span class=\"token comment\" spellcheck=\"true\">// }</span>\n    <span class=\"token comment\" spellcheck=\"true\">// else</span>\n    <span class=\"token comment\" spellcheck=\"true\">// {</span>\n    <span class=\"token comment\" spellcheck=\"true\">//     double a = asin((d + dis) / r);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//     double b = asin((d - dis) / r);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//     cout &lt;&lt; r * (a + b) &lt;&lt; \"\\n\";</span>\n    <span class=\"token comment\" spellcheck=\"true\">// }</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><h2 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>一个二维平面，黑板为 $(0,1)-(0,m)$ 的线段， $n$ 行 $m$ 列座位在黑板前面，均为整数坐标。</p>\n<p>$k$ 个位置有人，求到黑板视线不被任何人挡住的座位数量。</p>\n<p>$q$ 次询问，修改一个人的坐标要求计算答案。</p>\n<p>$2 \\leq n,m \\leq 2\\times10^5, 1 \\leq k \\leq 2 \\times10 ^ 5, 1 \\leq q \\leq 200$</p>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>每个人会挡住自己右边的人。每个人挡住的区域为一个折线右边的区域。</p>\n<p>每次询问维护 $mn[i], X[i]$</p>\n<p>$mn[i]$ ： 纵坐标为 $i$ 时最大不被遮挡的人的横坐标。</p>\n<p>$X[i]$ : 纵坐标为 $i$ 时，被遮挡的座位的最小横坐标。</p>\n<p>可以发现一个性质，当纵坐标从小到大时，如果新出现的点 $(X[i], i)$ 与 $(0,1)$ 构成的斜率更大，如果遮挡纵坐标更大的点时，也是该点遮挡后面的点。</p>\n<p>时间复杂度 ： $O(mq)$</p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m <span class=\"token operator\">>></span> k <span class=\"token operator\">>></span> q<span class=\"token punctuation\">;</span>\n\n    vl <span class=\"token function\">x</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">X</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">mn</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">>></span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> id<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> id<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">>></span> y<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n<span class=\"token punctuation\">,</span> X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            X<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 从下往上</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// (0, 1)(X[i], i) (0, 1)(X[j], j)</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>j <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> X<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token operator\">?</span> X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token comment\" spellcheck=\"true\">// y = kx+1 = (j - 1)/X[j] x + 1 = i</span>\n                mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> X<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> m<span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// (0,m)(X[i],i) (0,m)(X[j],j)</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>j <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> X<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> m<span class=\"token punctuation\">)</span>\n                mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">==</span> m <span class=\"token operator\">?</span> X<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token comment\" spellcheck=\"true\">// y = kx+m = (j-m)/X[j] x + m = i</span>\n                mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> X<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">-</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> mn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h1><h2 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>初始手牌有13张麻将牌，相同牌至多出现2张</p>\n<p>每轮可以从牌堆摸牌，若达成七对子则自摸胡牌</p>\n<p>若不然则选择手牌中某张牌并丢弃之</p>\n<p>给定初始手牌，求最优策略下达成七对子的期望轮数</p>\n<p>多组数据，数据组数不超过 $10^5$ 组</p>\n<h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>期望DP</p>\n<p>$f[i][j]$ : 有 $j$ 张单排，牌堆剩余 $i$ 张的期望轮数</p>\n<p>$f[i][j] = \\frac{3 \\times j}{i} \\times (1 + f[i - 1][j - 2]) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$</p>\n<p>当 $j = 1$ 时， $f[i][j] =  \\frac{3 \\times j}{i} \\times (1 + 0) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$</p>\n<p>初始手牌单牌数量为 $cnt$ ，答案为 $f[136-13][cnt]$</p>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\nll f<span class=\"token punctuation\">[</span><span class=\"token number\">150</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">15</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nll <span class=\"token function\">ksm</span><span class=\"token punctuation\">(</span>ll a<span class=\"token punctuation\">,</span> ll b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> res <span class=\"token operator\">=</span> res <span class=\"token operator\">*</span> a <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> a <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> res <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        ll inv <span class=\"token operator\">=</span> <span class=\"token function\">ksm</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> mod <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> <span class=\"token number\">13</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> \n                f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span> <span class=\"token operator\">*</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> inv <span class=\"token operator\">%</span> mod <span class=\"token operator\">+</span> \n                f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> inv <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nll <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    string s<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    unordered_map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> cnt<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> cnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        mp<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span><span class=\"token number\">123</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>cnt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> t<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Case #\"</span> <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h1><h2 id=\"题意-5\"><a href=\"#题意-5\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>有一张 n 个点 m 条边的无重边无自环的有向图</p>\n<p>初始时可以选择一个点染黑，其余点均为白点</p>\n<p>若某个点所有入边的起点均为黑点，则该点可以被染黑</p>\n<p>最大化图中黑点数量</p>\n<h2 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>启发式合并。</p>\n<p>当一个点的入度为 1 ，那么该点的前驱染黑的话，该点一定也被染黑。那么可以将该点和该点的前驱进行缩点合并看做一个集合。</p>\n<p>因为每个点都可能会有对应的出边，而合并的两个点的出边可能会有重复，就要进行去重，因为缩点之后的出边只能有一条。去重就可以用到 <code>set</code>  ，自带去重操作。</p>\n<p>合并的时候也有技巧，通过出边数较小的点合并到出边数较大的点身上，也就是启发式合并（类似并查集中的合并），达到减小时间复杂度的目的。</p>\n<p>递归合并即可，最后输出合并后最大的块。</p>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">2e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> f<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nset<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> in<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> out<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> f<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    x <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> out<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    f<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    vi q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> out<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        out<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        in<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        in<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            q<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> q<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        in<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> out<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        sz<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> k<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">;</span>\n            cin <span class=\"token operator\">>></span> u<span class=\"token punctuation\">;</span>\n            in<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            out<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>in<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> t<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Case #\"</span> <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"2022牛客多校1补题\"><a href=\"#2022牛客多校1补题\" class=\"headerlink\" title=\"2022牛客多校1补题\"></a>2022牛客多校1补题</h1><p>题解有<code>A C D G I J</code>六题。</p>\n<p>题解纯属自己玩，更多详细解释还请看官方题解。</p>\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定 $n$ ，将 $1,2,. . . , n$ 视为不含前导零的字符串</p>\n<p>求这些字符串中字典序最大的字符串</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>只需要在 $|n|-1$ 个9和 $n$ 两个答案之中进行选择。</p>\n<ul>\n<li>$n$去除最后一位其余均为9，答案为 $n$</li>\n<li>否则为 $|n|-1$ 个9</li>\n</ul>\n<p>复杂度 ： $O(|n|)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n    string s;\n    cin &gt;&gt; s;\n    string t = string(s.size() - 1, &#39;9&#39;);\n    if(s.substr(0, s.size() - 1) == t) cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;\n    else cout &lt;&lt; t &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><h2 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>$n$个区间 $[x_i-r_i, x_i+r_i]$ ，求 $n$ 个区间并之后的区间的空隙长度和。</p>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>贪心，将区间按左端点从小到大排序，从前往后扫一遍，不断维护维护区间右端点 $r$ 。若当前区间的左端点小于 $r$ ，可以进行合并，并且更新区间右端点；若当前区间的左端点大于 $r$ ，计算答案。</p>\n<blockquote>\n<p>注意第一个区间的判断以及 $r$ 的初始值。</p>\n</blockquote>\n<p>复杂度 ： $O(nlogn)$</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pii&gt; a(n);\n    for(int i = 0; i &lt; n; i++)\n    {\n        int c, r;\n        cin &gt;&gt; c &gt;&gt; r;\n        a[i] = {c - r, c + r};\n    }\n    sort(a.begin(), a.end());\n    ll ans = 0, rr = -1e18;\n    for(int i = 0; i &lt; n; i++)\n    {\n        ll l = a[i].first, r = a[i].second;\n        if(l &gt; rr &amp;&amp; i)\n            ans += (l - rr);\n        rr = max(rr, r);\n    }\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><h2 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给定一个圆和严格位于圆内的一点 $P$</p>\n<p>Mocha 会从点 $P$ 向任意角度发射一个长度为 $2d$ 的电磁炮</p>\n<p>电磁炮底边的中点为点P且两端位于圆内</p>\n<p>询问单次发射能摧毁的最大圆弧长</p>\n<p>$1≤T≤1000,-10^9≤ x, y ≤10^9,1 ≤r, d≤10^9$</p>\n<h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>将电磁炮方向转化为竖直向上：无论当前的电磁炮旋转角度如何，我们可以固定电磁炮的方向，将点 $P$ 绕原点旋转，从而使得电磁炮方向竖直向上（即 $y$ 轴正方向）。</p>\n<p>那么可以将题目转化成为电磁炮的方向总是竖直向上的，点 P 绕原点旋转一周的过程中可以摧毁的最长墙壁长度。</p>\n<p>那么我们设点 P 到原点距离是 $dis$，点 Q 绕原点旋转一周就可以转化成点Q在以 $(-dis,0)$ 和 $(dis,0)$ 为端点的线段上移动。</p>\n<p>下面用一张动图来说明：当点 Q 位于 $x$ 轴上时，产生的弧长最长。</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20220724/543419382_1658594584578/2CB7686E53E6883E02FCAA79818B7E3B\" alt></p>\n<p>所以画图进行计算，我们计算弧度以此来算弧长。 $L = \\alpha R$</p>\n<blockquote>\n<p> 当我们使用 $sin$ 计算时，因为正弦的 $0°-180°$表示并不唯一，所以需要分情况讨论 $dis &gt; d$ 和 $dis &lt; d$</p>\n<p>当我们使用 $cos$ 计算时，$cos$ 可以唯一表示 $0-180$ 度，所以不需要分类讨论。</p>\n</blockquote>\n<p><img src=\"2541904761/image-20220821221513603.png\" alt=\"图示\"></p>\n<p>以 $cos$ 计算为例：</p>\n<p>$\\alpha = arccos(\\frac{dis - d}{r})$</p>\n<p>$\\beta = arcos(\\frac{dis + d}{r})$</p>\n<p>$L = (\\alpha - \\beta) \\times r$</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n    int r, x, y, d;\n    cin &gt;&gt; r &gt;&gt; x &gt;&gt; y &gt;&gt; d;\n\n    double dis = sqrt(1ll * x * x + 1ll * y * y);\n\n    cout &lt;&lt; fixed &lt;&lt; setprecision(12);\n    double a = acos((dis + d) / r);\n    double b = acos((dis - d) / r);\n    cout &lt;&lt; (b - a) * r &lt;&lt; &quot;\\n&quot;;\n    // if(dis &gt; d)\n    // {\n    //     double a = asin((dis + d) / r);\n    //     double b = asin((dis - d) / r);\n    //     cout &lt;&lt; r * (a - b) &lt;&lt; &quot;\\n&quot;;\n    // }\n    // else\n    // {\n    //     double a = asin((d + dis) / r);\n    //     double b = asin((d - dis) / r);\n    //     cout &lt;&lt; r * (a + b) &lt;&lt; &quot;\\n&quot;;\n    // }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><h2 id=\"题意-3\"><a href=\"#题意-3\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>一个二维平面，黑板为 $(0,1)-(0,m)$ 的线段， $n$ 行 $m$ 列座位在黑板前面，均为整数坐标。</p>\n<p>$k$ 个位置有人，求到黑板视线不被任何人挡住的座位数量。</p>\n<p>$q$ 次询问，修改一个人的坐标要求计算答案。</p>\n<p>$2 \\leq n,m \\leq 2\\times10^5, 1 \\leq k \\leq 2 \\times10 ^ 5, 1 \\leq q \\leq 200$</p>\n<h2 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>每个人会挡住自己右边的人。每个人挡住的区域为一个折线右边的区域。</p>\n<p>每次询问维护 $mn[i], X[i]$</p>\n<p>$mn[i]$ ： 纵坐标为 $i$ 时最大不被遮挡的人的横坐标。</p>\n<p>$X[i]$ : 纵坐标为 $i$ 时，被遮挡的座位的最小横坐标。</p>\n<p>可以发现一个性质，当纵坐标从小到大时，如果新出现的点 $(X[i], i)$ 与 $(0,1)$ 构成的斜率更大，如果遮挡纵坐标更大的点时，也是该点遮挡后面的点。</p>\n<p>时间复杂度 ： $O(mq)$</p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n    int n, m, k, q;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;\n\n    vl x(k + 1), y(x), X(m + 1, n + 1), mn(m + 1, n);\n\n    for(int i = 1; i &lt;= k; i++)\n        cin &gt;&gt; x[i] &gt;&gt; y[i];\n\n    while(q--)\n    {\n        int id;\n        cin &gt;&gt; id;\n        cin &gt;&gt; x[id] &gt;&gt; y[id];\n\n        for(int i = 1; i &lt;= m; i++)\n            mn[i] = n, X[i] = n + 1;\n\n        for(int i = 1; i &lt;= k; i++)\n            X[y[i]] = min(X[y[i]], x[i]);\n\n        int j = 0;\n        // 从下往上\n        for(int i = 1; i &lt;= m; i++)\n        {\n            // (0, 1)(X[i], i) (0, 1)(X[j], j)\n            if(X[i] != n + 1 &amp;&amp; (!j || (i - 1) * X[j] &gt; (j - 1) * X[i]))\n                j = i;\n\n            if(j == 1)\n                mn[i] = min(mn[i], i == 1 ? X[i] - 1 : n);\n            else // y = kx+1 = (j - 1)/X[j] x + 1 = i\n                mn[i] = min(mn[i], j ? ((i - 1) * X[j] - 1) / (j - 1) : n);\n        }\n\n        j = 0;\n        for(int i = m; i &gt;= 1; i--)\n        {\n            // (0,m)(X[i],i) (0,m)(X[j],j)\n            if(X[i] != n + 1 &amp;&amp; (!j || (i - m) * X[j] &lt; (j - m) * X[i]))\n                j = i;\n\n            if(j == m)\n                mn[i] = min(mn[i], i == m ? X[i] - 1 : n);\n            else // y = kx+m = (j-m)/X[j] x + m = i\n                mn[i] = min(mn[i], j ? ((m - i) * X[j] - 1) / (m - j) : n);\n        }\n        ll ans = 0;\n        for(int i = 1; i &lt;= m; i++)\n            ans += mn[i];\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h1><h2 id=\"题意-4\"><a href=\"#题意-4\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>初始手牌有13张麻将牌，相同牌至多出现2张</p>\n<p>每轮可以从牌堆摸牌，若达成七对子则自摸胡牌</p>\n<p>若不然则选择手牌中某张牌并丢弃之</p>\n<p>给定初始手牌，求最优策略下达成七对子的期望轮数</p>\n<p>多组数据，数据组数不超过 $10^5$ 组</p>\n<h2 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>期望DP</p>\n<p>$f[i][j]$ : 有 $j$ 张单排，牌堆剩余 $i$ 张的期望轮数</p>\n<p>$f[i][j] = \\frac{3 \\times j}{i} \\times (1 + f[i - 1][j - 2]) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$</p>\n<p>当 $j = 1$ 时， $f[i][j] =  \\frac{3 \\times j}{i} \\times (1 + 0) + \\frac{i - 3 \\times j}{i} \\times (1 + f[i - 1][j])$</p>\n<p>初始手牌单牌数量为 $cnt$ ，答案为 $f[136-13][cnt]$</p>\n<h2 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nll f[150][15];\nll ksm(ll a, ll b)\n{\n    ll res = 1;\n    while(b)\n    {\n        if(b &amp; 1) res = res * a % mod;\n        b &gt;&gt;= 1;\n        a = a * a % mod;\n    }\n    return res % mod;\n}\nvoid init()\n{\n    for(int i = 1; i &lt;= 123; i++)\n    {\n        ll inv = ksm(i, mod - 2);    \n        for(int j = 1; j &lt;= 13; j++)\n        {\n            f[i][j] = (1 + \n                f[i - 1][max(0, j - 2)] * (3 * j) % mod * inv % mod + \n                f[i - 1][j] * (i - 3 * j) % mod * inv % mod) % mod;\n        }\n    }\n}\nll solve()\n{\n    string s;\n    cin &gt;&gt; s;\n    int cnt = 0;\n    unordered_map&lt;string, int&gt; mp;\n    for(int i = 0; i &lt; int(s.size()); i += 2)\n    {\n        if(mp[s.substr(i, 2)]) cnt--;\n        else cnt++;\n        mp[s.substr(i, 2)] ++;\n    }\n    return f[123][cnt];\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    init();\n    int t;\n    t = 1;\n    cin &gt;&gt; t;\n    for(int i = 1; i &lt;= t; i++)\n        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; solve() &lt;&lt; &quot;\\n&quot;;\n    return 0;\n}</code></pre>\n<h1 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h1><h2 id=\"题意-5\"><a href=\"#题意-5\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>有一张 n 个点 m 条边的无重边无自环的有向图</p>\n<p>初始时可以选择一个点染黑，其余点均为白点</p>\n<p>若某个点所有入边的起点均为黑点，则该点可以被染黑</p>\n<p>最大化图中黑点数量</p>\n<h2 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>启发式合并。</p>\n<p>当一个点的入度为 1 ，那么该点的前驱染黑的话，该点一定也被染黑。那么可以将该点和该点的前驱进行缩点合并看做一个集合。</p>\n<p>因为每个点都可能会有对应的出边，而合并的两个点的出边可能会有重复，就要进行去重，因为缩点之后的出边只能有一条。去重就可以用到 <code>set</code>  ，自带去重操作。</p>\n<p>合并的时候也有技巧，通过出边数较小的点合并到出边数较大的点身上，也就是启发式合并（类似并查集中的合并），达到减小时间复杂度的目的。</p>\n<p>递归合并即可，最后输出合并后最大的块。</p>\n<h2 id=\"代码-5\"><a href=\"#代码-5\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 2e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nint f[N], sz[N];\nset&lt;int&gt; in[N], out[N];\nint find(int x)\n{\n    if(x == f[x])\n        return x;\n    return f[x] = find(f[x]);\n}\n\nvoid merge(int x, int y)\n{\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(out[x].size() &lt; out[y].size())\n        swap(x, y);\n\n    f[y] = x;\n    sz[x] += sz[y];\n\n    vi q;\n    for(auto v : out[y])\n    {\n        out[x].insert(v);\n        in[v].erase(y);\n        in[v].insert(x);\n        if(in[v].size() == 1)\n            q.push_back(v);\n    }\n    for(auto v : q)\n        merge(x, v);\n}\n\n\nint solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        in[i].clear(), out[i].clear();\n        f[i] = i;\n        sz[i] = 1;\n    }\n\n    for(int i = 1; i &lt;= n; i++)\n    {\n        int k;\n        cin &gt;&gt; k;\n        for(int j = 1; j &lt;= k; j++)\n        {\n            int u;\n            cin &gt;&gt; u;\n            in[i].insert(u);\n            out[u].insert(i);\n        }\n    }\n\n    for(int i = 1; i &lt;= n; i++)\n        if(in[i].size() == 1)\n            merge(i, *in[i].begin());\n\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++)\n        ans = max(ans, sz[i]);\n    return ans;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    cin &gt;&gt; t;\n    for(int i = 1; i &lt;= t; i++)\n        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; solve() &lt;&lt; &quot;\\n&quot;;\n    return 0;\n}</code></pre>\n"},{"title":"2022牛客多校2补题","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":2791995876,"date":"2022-08-23T14:13:03.000Z","password":null,"summary":null,"_content":"\n# [2022牛客多校2补题](https://ac.nowcoder.com/acm/contest/33187)\n\n# G Link with Monotonic Subsequence\n\n$max(lis(p), lds(p))$ 的下界为 $\\lceil \\sqrt n \\rceil$ \n\n如果 $n = k^2$ 构造出 $(n-k+1,n-k+2,...,n)(k+1,...,2 \\times k)(1,2,3,...,k)$\n\n规律也可以通过打表得到\n\n打表程序主体\n\n```cpp\nfor(int i = 6; i <= 6; i++)\n{\n    vi a(i);\n    iota(a.begin(), a.end(), 1);\n    int ans = 1e9;\n    vi t;\n    do\n    {\n        vi dpd(i, 1), dpi(i, 1);\n        for(int j = 0; j < i; j++)\n            for(int k = 0; k < j; k++)\n                if(a[j] < a[k])\n                    dpd[j] = max(dpd[j], dpd[k] + 1);\n\n        for(int j = 0; j < i; j++)\n            for(int k = 0; k < j; k++)\n                if(a[j] > a[k])\n                    dpi[j] = max(dpi[j], dpi[k] + 1);\n        int in = 0, de = 0;\n        for(int j = 0; j < i; j++)\n        {\n            in = max(in, dpi[j]);\n            de = max(de, dpd[j]);\n        }\n        if(max(in, de) < ans)\n        {\n            ans = max(in, de);\n            t = a;\n        }\n    }while(next_permutation(a.begin(), a.end()));\n    for(auto x : t)\n        cout << x << \" \";\n    cout << \"\\n\";\n}\n```\n\n\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tint len = sqrt(n);\n\tif(len * len != n) len ++;\n\n\tint val = 0;\n\n\tif(n % len)\n\t{\n\t\tval += n % len;\n\t\tfor(int i = 1; i <= n % len; i++)\n\t\t\tcout << val-- << \" \";\n\t\tval += n % len + len;\n\t}\n\telse val += len;\n\n\tfor(int i = 1; i <= n / len; i++)\n\t{\n\t\tfor(int j = 1; j <= len; j++)\n\t\t\tcout << val-- << \" \";\n\t\tval += len * 2;\n\t}\n\tcout << \"\\n\";\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# D Link with Game Glitch\n\n> n种物品，m种交换，每 $a_i$ 个 $b_i$ 类物品可以换 $w \\cdot c_i$ 个 $d_i$ 类物品。求最大的 w 使不存在一种无限交换的方式。\n\n从 $b_i$ 向 $d_i$ 连一条 $w \\cdot c_i / a_i$ 的边。\n\n二分 $w$ ，如果图中出现边乘积大于 1 的环，即存在无限转换的方式，否则不存在。\n\n> 因为边乘积较大，需要转换为 $log$ 进行处理。\n> $$\n> log(w_1 \\cdot w_2 \\cdot ... \\cdot w_n) = logw_1 + logw_2 + ... + logw_n\n> $$\n> 边权乘积转化为边权log和。\n>\n> 即为存在边权和大于等于0的环即是无限转换，我们把边权取符号，即存在小于等于0的环即为无线转换。所以转换为判断是否存在负环。\n\n判断负环使用SPFA，建立一个超级源点，使其可以到达所有点。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing tu = tuple<int, int, db>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e3 + 5, M = 3 * N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint n, m;\nint e[M], h[N], ne[M], idx;\ndb w[M], dis[N];\n\nvoid add(int a, int b, db c)\n{\n\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nvoid solve()\n{\n\tcin >> n >> m;\n\n\tmemset(h, -1, sizeof h);\n\tfor(int i = 1; i <= n; i++)\n\t\tadd(0, i, 0);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd(b, d, log(a) - log(c));\n\t}\n\n\tauto check = [&](db x) -> bool\n\t{\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tdis[i] = 1e9;\n\t\tvector<db> W(idx);\n\t\tfor(int i = 0; i < idx; i++)\n\t\t{\n\t\t\tif(i < n) W[i] = w[i];\n\t\t\telse W[i] = w[i] - log(x);\n\t\t}\n\n\t\tvector<bool> vis(n + 1);\n\t\tvi cnt(n + 1);\n\t\tqueue<int> q;\n\t\tq.push(0);\n\t\tdis[0] = 0;\n\t\tvis[0] = true;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tvis[u] = false;\n\n\t\t\tfor(int i = h[u]; ~i; i = ne[i])\n\t\t\t{\n\t\t\t\tint v = e[i];\n\t\t\t\tdb ww = W[i];\n\t\t\t\tif(dis[u] + ww < dis[v])\n\t\t\t\t{\n\t\t\t\t\tdis[v] = dis[u] + ww;\n\t\t\t\t\tcnt[v]++;\n\t\t\t\t\tif(cnt[v] >= n) return false;\n\t\t\t\t\tif(!vis[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[v] = true;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tdb l = 0, r = 1;\n\twhile(r - l > eps)\n\t{\n\t\tdb mid = (l + r) / 2;\n\t\tif(check(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\tcout << fixed << setprecision(10) << l << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# J  Link with Arithmetic Progression\n\n> 给定数列 $a_1,a_2, ..., a_n$ ，求一个等差数列 $b_1, b_2, ...,b_n$ 使 $\\sum \\limits_{i=1}^n(b_i-a_i)^2$ 最小，输出最小值。\n\n线性回归，求出一条拟合直线 $y = kx + b$ 可以保证题目中最小值。\n$$\nk = \\frac{\\sum \\limits_{i=1}^n x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^nx_i^2 - n \\overline x^2}\\\\\nb = \\overline y - k \\overline x\n$$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvl y(n + 1);\n\tll sy = 0, sx = 0, a = 0, b = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> y[i];\n\t\tsx += i, sy += y[i];\n\t\ta += 1ll * i * y[i];\n\t\tb += 1ll * i * i;\n\t}\n\tld ax = (ld)sx / n, ay = (ld)sy / n;\n\tld k = (a - n * ax * ay) / (b - n * ax * ax);\n\tld c = ay - k * ax;\n\n\tld ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tld x = (k * i + c - y[i]) * (k * i + c - y[i]);\n\t\tans += x;\n\t}\n\tcout << fixed << setprecision(12) << ans << \"\\n\";\n\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# K Link with Bracket Sequence I\n\n> 长度为n的括号序列a是长度为m的合法括号序列的子序列，给定a，求b的数量。\n\n$f[i][j][k]$ : b串有 $i$ 个字符，a串中前 $j$ 个字符是b串的子序列，还有k个左括号未匹配的数量。\n\n转移：\n\n$i+1$ 位置放 `(`，且有 $j=n$ 或 $s_{j+1}\\neq$ `(` ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k+1}$。\n\n$i+1$ 位置放 `)`，且有 $j=n$ 或 $s_{j+1}\\neq$ `)` ，且 $k>0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k-1}$。\n\n$i+1$ 位置放 `(`，且有 $j<n,s_{j+1}=$`(` ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k+1}$。\n\n$i+1$ 位置放 `)`，且有 $j<n,s_{j+1}=$ `)` ，且$k>0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k-1}$\n\n```cpp\n#include<bits/stdc++.h>\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 205, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint f[N][N][N];\n\nvoid add(int &x, int y)\n{\n\tif((x += y) >= mod)\n\t\tx -= mod;\n}\nvoid solve()\n{\n\tmemset(f, 0, sizeof f);\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\ts = \" \" + s;\n\tf[0][0][0] = 1;\n\n\tfor(int i = 0; i < m; i++)\n\t\tfor(int j = 0; j <= min(i, n); j++)\n\t\t\tfor(int k = 0; k <= i; k++)\n\t\t\t\tif(f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tif(k < m && (j == n || s[j + 1] != '('))\n\t\t\t\t\t\tadd(f[i + 1][j][k + 1], f[i][j][k]);\n\t\t\t\t\tif(k && (j == n || s[j + 1] != ')'))\n\t\t\t\t\t\tadd(f[i + 1][j][k - 1], f[i][j][k]);\n\t\t\t\t\tif(j < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(k < m && s[j + 1] == '(')\n\t\t\t\t\t\t\tadd(f[i + 1][j + 1][k + 1], f[i][j][k]);\n\t\t\t\t\t\tif(k && s[j + 1] == ')')\n\t\t\t\t\t\t\tadd(f[i + 1][j + 1][k - 1], f[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tcout << f[m][n][0] << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# L Link with Level Editor I\n\n> $n$ 个世界， 每个世界有一个 $m$ 个点的无向图，从第一个世界的编号为 $1$ 的点出发，每个世界可以不动或可以走一条边到达下一个点 $u$ ，然后跳到下一个世界的点 $u$ ，如果跳到点 $m$ 则胜利。求一个最短的子段，使得其可胜利。\n\n$(i, u)$ 到 $(i + 1, v)$ 有关系，可以考虑进行状态转移。\n\n设置 $f[i][j]$ : 表示到达第 $i$ 个世界中的 $j$ 号点最少需要经过多少世界\n\n初始时： $f[i][1] = 1, f[i][j] = \\infty$ \n\n两种转移方式：\n\n- 在当前世界原地不动，之后到下一个世界。 $f[i][j] + 1 \\rightarrow f[i+1][j] (i < n)$\n- 在当前世界走一条边，之后到下一个世界。$f[i][u]+1 \\rightarrow f[i+1][v] (i < n),(u, v)$  属于第 $i$ 个世界的一条边。\n\n第一维可以进行压缩，进行空间优化。\n\n>  注意：转移的时候，是先进行走边，然后再到下一个世界。\n>\n> 当到达第 $i$ 个世界时， 先对上一层状态 $f[]$ 数组不为无穷的加一，代表进入当前世界。然后进行状态转移，转移时候利用的是转移到当前世界的数组（即下面代码的$f[]$ 数组）进行更新。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvi f(m + 1, 1e9), nf;\n\tf[1] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tif(j != 1 && j != m && f[j] != 1e9)\n\t\t\t\tf[j]++;// 走到第 i 个世界,世界数加一\n\t\tnf = f;\n\t\twhile(c--)\n\t\t{\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tnf[v] = min(f[u], nf[v]); // 在第i个世界中进行状态转移，f[]为老的状态，新的状态存在nf[]数组中\n\t\t}\n\t\tf = nf;\n\t}\n\tcout << (f[m] == 1e9 ? -1 : f[m]) << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n","source":"_posts/2022牛客多校2补题.md","raw":"---\ntitle: 2022牛客多校2补题\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 多校\ncategories:\n  - 多校\nabbrlink: 2791995876\ndate: 2022-08-23 22:13:03\npassword:\nsummary:\n---\n\n# [2022牛客多校2补题](https://ac.nowcoder.com/acm/contest/33187)\n\n# G Link with Monotonic Subsequence\n\n$max(lis(p), lds(p))$ 的下界为 $\\lceil \\sqrt n \\rceil$ \n\n如果 $n = k^2$ 构造出 $(n-k+1,n-k+2,...,n)(k+1,...,2 \\times k)(1,2,3,...,k)$\n\n规律也可以通过打表得到\n\n打表程序主体\n\n```cpp\nfor(int i = 6; i <= 6; i++)\n{\n    vi a(i);\n    iota(a.begin(), a.end(), 1);\n    int ans = 1e9;\n    vi t;\n    do\n    {\n        vi dpd(i, 1), dpi(i, 1);\n        for(int j = 0; j < i; j++)\n            for(int k = 0; k < j; k++)\n                if(a[j] < a[k])\n                    dpd[j] = max(dpd[j], dpd[k] + 1);\n\n        for(int j = 0; j < i; j++)\n            for(int k = 0; k < j; k++)\n                if(a[j] > a[k])\n                    dpi[j] = max(dpi[j], dpi[k] + 1);\n        int in = 0, de = 0;\n        for(int j = 0; j < i; j++)\n        {\n            in = max(in, dpi[j]);\n            de = max(de, dpd[j]);\n        }\n        if(max(in, de) < ans)\n        {\n            ans = max(in, de);\n            t = a;\n        }\n    }while(next_permutation(a.begin(), a.end()));\n    for(auto x : t)\n        cout << x << \" \";\n    cout << \"\\n\";\n}\n```\n\n\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tint len = sqrt(n);\n\tif(len * len != n) len ++;\n\n\tint val = 0;\n\n\tif(n % len)\n\t{\n\t\tval += n % len;\n\t\tfor(int i = 1; i <= n % len; i++)\n\t\t\tcout << val-- << \" \";\n\t\tval += n % len + len;\n\t}\n\telse val += len;\n\n\tfor(int i = 1; i <= n / len; i++)\n\t{\n\t\tfor(int j = 1; j <= len; j++)\n\t\t\tcout << val-- << \" \";\n\t\tval += len * 2;\n\t}\n\tcout << \"\\n\";\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# D Link with Game Glitch\n\n> n种物品，m种交换，每 $a_i$ 个 $b_i$ 类物品可以换 $w \\cdot c_i$ 个 $d_i$ 类物品。求最大的 w 使不存在一种无限交换的方式。\n\n从 $b_i$ 向 $d_i$ 连一条 $w \\cdot c_i / a_i$ 的边。\n\n二分 $w$ ，如果图中出现边乘积大于 1 的环，即存在无限转换的方式，否则不存在。\n\n> 因为边乘积较大，需要转换为 $log$ 进行处理。\n> $$\n> log(w_1 \\cdot w_2 \\cdot ... \\cdot w_n) = logw_1 + logw_2 + ... + logw_n\n> $$\n> 边权乘积转化为边权log和。\n>\n> 即为存在边权和大于等于0的环即是无限转换，我们把边权取符号，即存在小于等于0的环即为无线转换。所以转换为判断是否存在负环。\n\n判断负环使用SPFA，建立一个超级源点，使其可以到达所有点。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing tu = tuple<int, int, db>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e3 + 5, M = 3 * N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint n, m;\nint e[M], h[N], ne[M], idx;\ndb w[M], dis[N];\n\nvoid add(int a, int b, db c)\n{\n\te[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nvoid solve()\n{\n\tcin >> n >> m;\n\n\tmemset(h, -1, sizeof h);\n\tfor(int i = 1; i <= n; i++)\n\t\tadd(0, i, 0);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tadd(b, d, log(a) - log(c));\n\t}\n\n\tauto check = [&](db x) -> bool\n\t{\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tdis[i] = 1e9;\n\t\tvector<db> W(idx);\n\t\tfor(int i = 0; i < idx; i++)\n\t\t{\n\t\t\tif(i < n) W[i] = w[i];\n\t\t\telse W[i] = w[i] - log(x);\n\t\t}\n\n\t\tvector<bool> vis(n + 1);\n\t\tvi cnt(n + 1);\n\t\tqueue<int> q;\n\t\tq.push(0);\n\t\tdis[0] = 0;\n\t\tvis[0] = true;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tvis[u] = false;\n\n\t\t\tfor(int i = h[u]; ~i; i = ne[i])\n\t\t\t{\n\t\t\t\tint v = e[i];\n\t\t\t\tdb ww = W[i];\n\t\t\t\tif(dis[u] + ww < dis[v])\n\t\t\t\t{\n\t\t\t\t\tdis[v] = dis[u] + ww;\n\t\t\t\t\tcnt[v]++;\n\t\t\t\t\tif(cnt[v] >= n) return false;\n\t\t\t\t\tif(!vis[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[v] = true;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tdb l = 0, r = 1;\n\twhile(r - l > eps)\n\t{\n\t\tdb mid = (l + r) / 2;\n\t\tif(check(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\tcout << fixed << setprecision(10) << l << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# J  Link with Arithmetic Progression\n\n> 给定数列 $a_1,a_2, ..., a_n$ ，求一个等差数列 $b_1, b_2, ...,b_n$ 使 $\\sum \\limits_{i=1}^n(b_i-a_i)^2$ 最小，输出最小值。\n\n线性回归，求出一条拟合直线 $y = kx + b$ 可以保证题目中最小值。\n$$\nk = \\frac{\\sum \\limits_{i=1}^n x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^nx_i^2 - n \\overline x^2}\\\\\nb = \\overline y - k \\overline x\n$$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvl y(n + 1);\n\tll sy = 0, sx = 0, a = 0, b = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> y[i];\n\t\tsx += i, sy += y[i];\n\t\ta += 1ll * i * y[i];\n\t\tb += 1ll * i * i;\n\t}\n\tld ax = (ld)sx / n, ay = (ld)sy / n;\n\tld k = (a - n * ax * ay) / (b - n * ax * ax);\n\tld c = ay - k * ax;\n\n\tld ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tld x = (k * i + c - y[i]) * (k * i + c - y[i]);\n\t\tans += x;\n\t}\n\tcout << fixed << setprecision(12) << ans << \"\\n\";\n\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# K Link with Bracket Sequence I\n\n> 长度为n的括号序列a是长度为m的合法括号序列的子序列，给定a，求b的数量。\n\n$f[i][j][k]$ : b串有 $i$ 个字符，a串中前 $j$ 个字符是b串的子序列，还有k个左括号未匹配的数量。\n\n转移：\n\n$i+1$ 位置放 `(`，且有 $j=n$ 或 $s_{j+1}\\neq$ `(` ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k+1}$。\n\n$i+1$ 位置放 `)`，且有 $j=n$ 或 $s_{j+1}\\neq$ `)` ，且 $k>0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k-1}$。\n\n$i+1$ 位置放 `(`，且有 $j<n,s_{j+1}=$`(` ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k+1}$。\n\n$i+1$ 位置放 `)`，且有 $j<n,s_{j+1}=$ `)` ，且$k>0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k-1}$\n\n```cpp\n#include<bits/stdc++.h>\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 205, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint f[N][N][N];\n\nvoid add(int &x, int y)\n{\n\tif((x += y) >= mod)\n\t\tx -= mod;\n}\nvoid solve()\n{\n\tmemset(f, 0, sizeof f);\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\ts = \" \" + s;\n\tf[0][0][0] = 1;\n\n\tfor(int i = 0; i < m; i++)\n\t\tfor(int j = 0; j <= min(i, n); j++)\n\t\t\tfor(int k = 0; k <= i; k++)\n\t\t\t\tif(f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tif(k < m && (j == n || s[j + 1] != '('))\n\t\t\t\t\t\tadd(f[i + 1][j][k + 1], f[i][j][k]);\n\t\t\t\t\tif(k && (j == n || s[j + 1] != ')'))\n\t\t\t\t\t\tadd(f[i + 1][j][k - 1], f[i][j][k]);\n\t\t\t\t\tif(j < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(k < m && s[j + 1] == '(')\n\t\t\t\t\t\t\tadd(f[i + 1][j + 1][k + 1], f[i][j][k]);\n\t\t\t\t\t\tif(k && s[j + 1] == ')')\n\t\t\t\t\t\t\tadd(f[i + 1][j + 1][k - 1], f[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tcout << f[m][n][0] << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# L Link with Level Editor I\n\n> $n$ 个世界， 每个世界有一个 $m$ 个点的无向图，从第一个世界的编号为 $1$ 的点出发，每个世界可以不动或可以走一条边到达下一个点 $u$ ，然后跳到下一个世界的点 $u$ ，如果跳到点 $m$ 则胜利。求一个最短的子段，使得其可胜利。\n\n$(i, u)$ 到 $(i + 1, v)$ 有关系，可以考虑进行状态转移。\n\n设置 $f[i][j]$ : 表示到达第 $i$ 个世界中的 $j$ 号点最少需要经过多少世界\n\n初始时： $f[i][1] = 1, f[i][j] = \\infty$ \n\n两种转移方式：\n\n- 在当前世界原地不动，之后到下一个世界。 $f[i][j] + 1 \\rightarrow f[i+1][j] (i < n)$\n- 在当前世界走一条边，之后到下一个世界。$f[i][u]+1 \\rightarrow f[i+1][v] (i < n),(u, v)$  属于第 $i$ 个世界的一条边。\n\n第一维可以进行压缩，进行空间优化。\n\n>  注意：转移的时候，是先进行走边，然后再到下一个世界。\n>\n> 当到达第 $i$ 个世界时， 先对上一层状态 $f[]$ 数组不为无穷的加一，代表进入当前世界。然后进行状态转移，转移时候利用的是转移到当前世界的数组（即下面代码的$f[]$ 数组）进行更新。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvi f(m + 1, 1e9), nf;\n\tf[1] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tif(j != 1 && j != m && f[j] != 1e9)\n\t\t\t\tf[j]++;// 走到第 i 个世界,世界数加一\n\t\tnf = f;\n\t\twhile(c--)\n\t\t{\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tnf[v] = min(f[u], nf[v]); // 在第i个世界中进行状态转移，f[]为老的状态，新的状态存在nf[]数组中\n\t\t}\n\t\tf = nf;\n\t}\n\tcout << (f[m] == 1e9 ? -1 : f[m]) << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n","slug":"2022牛客多校2补题","published":1,"updated":"2022-08-23T14:18:02.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolgw000h6kuh21sjz81r","content":"<h1 id=\"2022牛客多校2补题\"><a href=\"#2022牛客多校2补题\" class=\"headerlink\" title=\"2022牛客多校2补题\"></a><a href=\"https://ac.nowcoder.com/acm/contest/33187\" target=\"_blank\" rel=\"noopener\">2022牛客多校2补题</a></h1><h1 id=\"G-Link-with-Monotonic-Subsequence\"><a href=\"#G-Link-with-Monotonic-Subsequence\" class=\"headerlink\" title=\"G Link with Monotonic Subsequence\"></a>G Link with Monotonic Subsequence</h1><p>$max(lis(p), lds(p))$ 的下界为 $\\lceil \\sqrt n \\rceil$ </p>\n<p>如果 $n = k^2$ 构造出 $(n-k+1,n-k+2,…,n)(k+1,…,2 \\times k)(1,2,3,…,k)$</p>\n<p>规律也可以通过打表得到</p>\n<p>打表程序主体</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    vi <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">iota</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span><span class=\"token punctuation\">;</span>\n    vi t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">{</span>\n        vi <span class=\"token function\">dpd</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">dpi</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    dpd<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>dpd<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dpd<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    dpi<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>dpi<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dpi<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> in <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> de <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            in <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">,</span> dpi<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            de <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>de<span class=\"token punctuation\">,</span> dpd<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">,</span> de<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> ans<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">,</span> de<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">next_permutation</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x <span class=\"token operator\">:</span> t<span class=\"token punctuation\">)</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> x <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">*</span> len <span class=\"token operator\">!=</span> n<span class=\"token punctuation\">)</span> len <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> len<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        val <span class=\"token operator\">+</span><span class=\"token operator\">=</span> n <span class=\"token operator\">%</span> len<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">%</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> val<span class=\"token operator\">--</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        val <span class=\"token operator\">+</span><span class=\"token operator\">=</span> n <span class=\"token operator\">%</span> len <span class=\"token operator\">+</span> len<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> val <span class=\"token operator\">+</span><span class=\"token operator\">=</span> len<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">/</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> len<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> val<span class=\"token operator\">--</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n        val <span class=\"token operator\">+</span><span class=\"token operator\">=</span> len <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"D-Link-with-Game-Glitch\"><a href=\"#D-Link-with-Game-Glitch\" class=\"headerlink\" title=\"D Link with Game Glitch\"></a>D Link with Game Glitch</h1><blockquote>\n<p>n种物品，m种交换，每 $a_i$ 个 $b_i$ 类物品可以换 $w \\cdot c_i$ 个 $d_i$ 类物品。求最大的 w 使不存在一种无限交换的方式。</p>\n</blockquote>\n<p>从 $b_i$ 向 $d_i$ 连一条 $w \\cdot c_i / a_i$ 的边。</p>\n<p>二分 $w$ ，如果图中出现边乘积大于 1 的环，即存在无限转换的方式，否则不存在。</p>\n<blockquote>\n<p>因为边乘积较大，需要转换为 $log$ 进行处理。<br>$$<br>log(w_1 \\cdot w_2 \\cdot … \\cdot w_n) = logw_1 + logw_2 + … + logw_n<br>$$<br>边权乘积转化为边权log和。</p>\n<p>即为存在边权和大于等于0的环即是无限转换，我们把边权取符号，即存在小于等于0的环即为无线转换。所以转换为判断是否存在负环。</p>\n</blockquote>\n<p>判断负环使用SPFA，建立一个超级源点，使其可以到达所有点。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> tu <span class=\"token operator\">=</span> tuple<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> db<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e3</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> e<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ne<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">;</span>\ndb w<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dis<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> db c<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    e<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c<span class=\"token punctuation\">,</span> ne<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> idx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> a <span class=\"token operator\">>></span> b <span class=\"token operator\">>></span> c <span class=\"token operator\">>></span> d<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">auto</span> check <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>db x<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token keyword\">bool</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            dis<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span>db<span class=\"token operator\">></span> <span class=\"token function\">W</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> idx<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> W<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> W<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> <span class=\"token function\">vis</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vi <span class=\"token function\">cnt</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span>\n        q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dis<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        vis<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> u <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            q<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            vis<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">~</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> ne<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> v <span class=\"token operator\">=</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                db ww <span class=\"token operator\">=</span> W<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dis<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> ww <span class=\"token operator\">&lt;</span> dis<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    dis<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dis<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> ww<span class=\"token punctuation\">;</span>\n                    cnt<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cnt<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>vis<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">{</span>\n                        vis<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                        q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    db l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> r <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> l <span class=\"token operator\">></span> eps<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        db mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">check</span><span class=\"token punctuation\">(</span>mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> l <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> r <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> fixed <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">setprecision</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> l <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"J-Link-with-Arithmetic-Progression\"><a href=\"#J-Link-with-Arithmetic-Progression\" class=\"headerlink\" title=\"J  Link with Arithmetic Progression\"></a>J  Link with Arithmetic Progression</h1><blockquote>\n<p>给定数列 $a_1,a_2, …, a_n$ ，求一个等差数列 $b_1, b_2, …,b_n$ 使 $\\sum \\limits_{i=1}^n(b_i-a_i)^2$ 最小，输出最小值。</p>\n</blockquote>\n<p>线性回归，求出一条拟合直线 $y = kx + b$ 可以保证题目中最小值。<br>$$<br>k = \\frac{\\sum \\limits_{i=1}^n x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^nx_i^2 - n \\overline x^2}\\<br>b = \\overline y - k \\overline x<br>$$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    vl <span class=\"token function\">y</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ll sy <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> sx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        sx <span class=\"token operator\">+</span><span class=\"token operator\">=</span> i<span class=\"token punctuation\">,</span> sy <span class=\"token operator\">+</span><span class=\"token operator\">=</span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">*</span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ld ax <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ld<span class=\"token punctuation\">)</span>sx <span class=\"token operator\">/</span> n<span class=\"token punctuation\">,</span> ay <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ld<span class=\"token punctuation\">)</span>sy <span class=\"token operator\">/</span> n<span class=\"token punctuation\">;</span>\n    ld k <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">-</span> n <span class=\"token operator\">*</span> ax <span class=\"token operator\">*</span> ay<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">-</span> n <span class=\"token operator\">*</span> ax <span class=\"token operator\">*</span> ax<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ld c <span class=\"token operator\">=</span> ay <span class=\"token operator\">-</span> k <span class=\"token operator\">*</span> ax<span class=\"token punctuation\">;</span>\n\n    ld ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        ld x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">*</span> i <span class=\"token operator\">+</span> c <span class=\"token operator\">-</span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">*</span> i <span class=\"token operator\">+</span> c <span class=\"token operator\">-</span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> fixed <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">setprecision</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"K-Link-with-Bracket-Sequence-I\"><a href=\"#K-Link-with-Bracket-Sequence-I\" class=\"headerlink\" title=\"K Link with Bracket Sequence I\"></a>K Link with Bracket Sequence I</h1><blockquote>\n<p>长度为n的括号序列a是长度为m的合法括号序列的子序列，给定a，求b的数量。</p>\n</blockquote>\n<p>$f[i][j][k]$ : b串有 $i$ 个字符，a串中前 $j$ 个字符是b串的子序列，还有k个左括号未匹配的数量。</p>\n<p>转移：</p>\n<p>$i+1$ 位置放 <code>(</code>，且有 $j=n$ 或 $s_{j+1}\\neq$ <code>(</code> ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k+1}$。</p>\n<p>$i+1$ 位置放 <code>)</code>，且有 $j=n$ 或 $s_{j+1}\\neq$ <code>)</code> ，且 $k&gt;0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k-1}$。</p>\n<p>$i+1$ 位置放 <code>(</code>，且有 $j&lt;n,s_{j+1}=$<code>(</code> ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k+1}$。</p>\n<p>$i+1$ 位置放 <code>)</code>，且有 $j&lt;n,s_{j+1}=$ <code>)</code> ，且$k&gt;0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k-1}$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">205</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> f<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span><span class=\"token operator\">=</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> mod<span class=\"token punctuation\">)</span>\n        x <span class=\"token operator\">-</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    string s<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">;</span>\n    s <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">;</span>\n    f<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;=</span> i<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">&lt;</span> m <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> n <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> n <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">&lt;</span> m <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">)</span>\n                            <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span>\n                            <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n    cout <span class=\"token operator\">&lt;&lt;</span> f<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"L-Link-with-Level-Editor-I\"><a href=\"#L-Link-with-Level-Editor-I\" class=\"headerlink\" title=\"L Link with Level Editor I\"></a>L Link with Level Editor I</h1><blockquote>\n<p>$n$ 个世界， 每个世界有一个 $m$ 个点的无向图，从第一个世界的编号为 $1$ 的点出发，每个世界可以不动或可以走一条边到达下一个点 $u$ ，然后跳到下一个世界的点 $u$ ，如果跳到点 $m$ 则胜利。求一个最短的子段，使得其可胜利。</p>\n</blockquote>\n<p>$(i, u)$ 到 $(i + 1, v)$ 有关系，可以考虑进行状态转移。</p>\n<p>设置 $f[i][j]$ : 表示到达第 $i$ 个世界中的 $j$ 号点最少需要经过多少世界</p>\n<p>初始时： $f[i][1] = 1, f[i][j] = \\infty$ </p>\n<p>两种转移方式：</p>\n<ul>\n<li>在当前世界原地不动，之后到下一个世界。 $f[i][j] + 1 \\rightarrow f[i+1][j] (i &lt; n)$</li>\n<li>在当前世界走一条边，之后到下一个世界。$f[i][u]+1 \\rightarrow f[i+1][v] (i &lt; n),(u, v)$  属于第 $i$ 个世界的一条边。</li>\n</ul>\n<p>第一维可以进行压缩，进行空间优化。</p>\n<blockquote>\n<p> 注意：转移的时候，是先进行走边，然后再到下一个世界。</p>\n<p>当到达第 $i$ 个世界时， 先对上一层状态 $f[]$ 数组不为无穷的加一，代表进入当前世界。然后进行状态转移，转移时候利用的是转移到当前世界的数组（即下面代码的$f[]$ 数组）进行更新。</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n\n    vi <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nf<span class=\"token punctuation\">;</span>\n    f<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> c<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>j <span class=\"token operator\">!=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">!=</span> m <span class=\"token operator\">&amp;&amp;</span> f<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span>\n                f<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 走到第 i 个世界,世界数加一</span>\n        nf <span class=\"token operator\">=</span> f<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>c<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n            cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n            nf<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nf<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 在第i个世界中进行状态转移，f[]为老的状态，新的状态存在nf[]数组中</span>\n        <span class=\"token punctuation\">}</span>\n        f <span class=\"token operator\">=</span> nf<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">:</span> f<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"2022牛客多校2补题\"><a href=\"#2022牛客多校2补题\" class=\"headerlink\" title=\"2022牛客多校2补题\"></a><a href=\"https://ac.nowcoder.com/acm/contest/33187\" target=\"_blank\" rel=\"noopener\">2022牛客多校2补题</a></h1><h1 id=\"G-Link-with-Monotonic-Subsequence\"><a href=\"#G-Link-with-Monotonic-Subsequence\" class=\"headerlink\" title=\"G Link with Monotonic Subsequence\"></a>G Link with Monotonic Subsequence</h1><p>$max(lis(p), lds(p))$ 的下界为 $\\lceil \\sqrt n \\rceil$ </p>\n<p>如果 $n = k^2$ 构造出 $(n-k+1,n-k+2,…,n)(k+1,…,2 \\times k)(1,2,3,…,k)$</p>\n<p>规律也可以通过打表得到</p>\n<p>打表程序主体</p>\n<pre><code class=\"cpp\">for(int i = 6; i &lt;= 6; i++)\n{\n    vi a(i);\n    iota(a.begin(), a.end(), 1);\n    int ans = 1e9;\n    vi t;\n    do\n    {\n        vi dpd(i, 1), dpi(i, 1);\n        for(int j = 0; j &lt; i; j++)\n            for(int k = 0; k &lt; j; k++)\n                if(a[j] &lt; a[k])\n                    dpd[j] = max(dpd[j], dpd[k] + 1);\n\n        for(int j = 0; j &lt; i; j++)\n            for(int k = 0; k &lt; j; k++)\n                if(a[j] &gt; a[k])\n                    dpi[j] = max(dpi[j], dpi[k] + 1);\n        int in = 0, de = 0;\n        for(int j = 0; j &lt; i; j++)\n        {\n            in = max(in, dpi[j]);\n            de = max(de, dpd[j]);\n        }\n        if(max(in, de) &lt; ans)\n        {\n            ans = max(in, de);\n            t = a;\n        }\n    }while(next_permutation(a.begin(), a.end()));\n    for(auto x : t)\n        cout &lt;&lt; x &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; &quot;\\n&quot;;\n}</code></pre>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    int len = sqrt(n);\n    if(len * len != n) len ++;\n\n    int val = 0;\n\n    if(n % len)\n    {\n        val += n % len;\n        for(int i = 1; i &lt;= n % len; i++)\n            cout &lt;&lt; val-- &lt;&lt; &quot; &quot;;\n        val += n % len + len;\n    }\n    else val += len;\n\n    for(int i = 1; i &lt;= n / len; i++)\n    {\n        for(int j = 1; j &lt;= len; j++)\n            cout &lt;&lt; val-- &lt;&lt; &quot; &quot;;\n        val += len * 2;\n    }\n    cout &lt;&lt; &quot;\\n&quot;;\n\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"D-Link-with-Game-Glitch\"><a href=\"#D-Link-with-Game-Glitch\" class=\"headerlink\" title=\"D Link with Game Glitch\"></a>D Link with Game Glitch</h1><blockquote>\n<p>n种物品，m种交换，每 $a_i$ 个 $b_i$ 类物品可以换 $w \\cdot c_i$ 个 $d_i$ 类物品。求最大的 w 使不存在一种无限交换的方式。</p>\n</blockquote>\n<p>从 $b_i$ 向 $d_i$ 连一条 $w \\cdot c_i / a_i$ 的边。</p>\n<p>二分 $w$ ，如果图中出现边乘积大于 1 的环，即存在无限转换的方式，否则不存在。</p>\n<blockquote>\n<p>因为边乘积较大，需要转换为 $log$ 进行处理。<br>$$<br>log(w_1 \\cdot w_2 \\cdot … \\cdot w_n) = logw_1 + logw_2 + … + logw_n<br>$$<br>边权乘积转化为边权log和。</p>\n<p>即为存在边权和大于等于0的环即是无限转换，我们把边权取符号，即存在小于等于0的环即为无线转换。所以转换为判断是否存在负环。</p>\n</blockquote>\n<p>判断负环使用SPFA，建立一个超级源点，使其可以到达所有点。</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing tu = tuple&lt;int, int, db&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e3 + 5, M = 3 * N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint n, m;\nint e[M], h[N], ne[M], idx;\ndb w[M], dis[N];\n\nvoid add(int a, int b, db c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nvoid solve()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt;= n; i++)\n        add(0, i, 0);\n    for(int i = 1; i &lt;= m; i++)\n    {\n        int a, b, c, d;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        add(b, d, log(a) - log(c));\n    }\n\n    auto check = [&amp;](db x) -&gt; bool\n    {\n        for(int i = 1; i &lt;= n; i++)\n            dis[i] = 1e9;\n        vector&lt;db&gt; W(idx);\n        for(int i = 0; i &lt; idx; i++)\n        {\n            if(i &lt; n) W[i] = w[i];\n            else W[i] = w[i] - log(x);\n        }\n\n        vector&lt;bool&gt; vis(n + 1);\n        vi cnt(n + 1);\n        queue&lt;int&gt; q;\n        q.push(0);\n        dis[0] = 0;\n        vis[0] = true;\n        while(!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            vis[u] = false;\n\n            for(int i = h[u]; ~i; i = ne[i])\n            {\n                int v = e[i];\n                db ww = W[i];\n                if(dis[u] + ww &lt; dis[v])\n                {\n                    dis[v] = dis[u] + ww;\n                    cnt[v]++;\n                    if(cnt[v] &gt;= n) return false;\n                    if(!vis[v])\n                    {\n                        vis[v] = true;\n                        q.push(v);\n                    }\n\n                }\n            }\n        }\n        return true;\n    };\n\n    db l = 0, r = 1;\n    while(r - l &gt; eps)\n    {\n        db mid = (l + r) / 2;\n        if(check(mid)) l = mid;\n        else r = mid;\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; l &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"J-Link-with-Arithmetic-Progression\"><a href=\"#J-Link-with-Arithmetic-Progression\" class=\"headerlink\" title=\"J  Link with Arithmetic Progression\"></a>J  Link with Arithmetic Progression</h1><blockquote>\n<p>给定数列 $a_1,a_2, …, a_n$ ，求一个等差数列 $b_1, b_2, …,b_n$ 使 $\\sum \\limits_{i=1}^n(b_i-a_i)^2$ 最小，输出最小值。</p>\n</blockquote>\n<p>线性回归，求出一条拟合直线 $y = kx + b$ 可以保证题目中最小值。<br>$$<br>k = \\frac{\\sum \\limits_{i=1}^n x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^nx_i^2 - n \\overline x^2}\\<br>b = \\overline y - k \\overline x<br>$$</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vl y(n + 1);\n    ll sy = 0, sx = 0, a = 0, b = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; y[i];\n        sx += i, sy += y[i];\n        a += 1ll * i * y[i];\n        b += 1ll * i * i;\n    }\n    ld ax = (ld)sx / n, ay = (ld)sy / n;\n    ld k = (a - n * ax * ay) / (b - n * ax * ax);\n    ld c = ay - k * ax;\n\n    ld ans = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        ld x = (k * i + c - y[i]) * (k * i + c - y[i]);\n        ans += x;\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(12) &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n\n\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"K-Link-with-Bracket-Sequence-I\"><a href=\"#K-Link-with-Bracket-Sequence-I\" class=\"headerlink\" title=\"K Link with Bracket Sequence I\"></a>K Link with Bracket Sequence I</h1><blockquote>\n<p>长度为n的括号序列a是长度为m的合法括号序列的子序列，给定a，求b的数量。</p>\n</blockquote>\n<p>$f[i][j][k]$ : b串有 $i$ 个字符，a串中前 $j$ 个字符是b串的子序列，还有k个左括号未匹配的数量。</p>\n<p>转移：</p>\n<p>$i+1$ 位置放 <code>(</code>，且有 $j=n$ 或 $s_{j+1}\\neq$ <code>(</code> ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k+1}$。</p>\n<p>$i+1$ 位置放 <code>)</code>，且有 $j=n$ 或 $s_{j+1}\\neq$ <code>)</code> ，且 $k&gt;0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j,k-1}$。</p>\n<p>$i+1$ 位置放 <code>(</code>，且有 $j&lt;n,s_{j+1}=$<code>(</code> ，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k+1}$。</p>\n<p>$i+1$ 位置放 <code>)</code>，且有 $j&lt;n,s_{j+1}=$ <code>)</code> ，且$k&gt;0$，那么有转移 $f_{i,j,k}\\rightarrow f_{i+1,j+1,k-1}$</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 205, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint f[N][N][N];\n\nvoid add(int &amp;x, int y)\n{\n    if((x += y) &gt;= mod)\n        x -= mod;\n}\nvoid solve()\n{\n    memset(f, 0, sizeof f);\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    string s;\n    cin &gt;&gt; s;\n    s = &quot; &quot; + s;\n    f[0][0][0] = 1;\n\n    for(int i = 0; i &lt; m; i++)\n        for(int j = 0; j &lt;= min(i, n); j++)\n            for(int k = 0; k &lt;= i; k++)\n                if(f[i][j][k])\n                {\n                    if(k &lt; m &amp;&amp; (j == n || s[j + 1] != &#39;(&#39;))\n                        add(f[i + 1][j][k + 1], f[i][j][k]);\n                    if(k &amp;&amp; (j == n || s[j + 1] != &#39;)&#39;))\n                        add(f[i + 1][j][k - 1], f[i][j][k]);\n                    if(j &lt; n)\n                    {\n                        if(k &lt; m &amp;&amp; s[j + 1] == &#39;(&#39;)\n                            add(f[i + 1][j + 1][k + 1], f[i][j][k]);\n                        if(k &amp;&amp; s[j + 1] == &#39;)&#39;)\n                            add(f[i + 1][j + 1][k - 1], f[i][j][k]);\n                    }\n                }\n\n    cout &lt;&lt; f[m][n][0] &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"L-Link-with-Level-Editor-I\"><a href=\"#L-Link-with-Level-Editor-I\" class=\"headerlink\" title=\"L Link with Level Editor I\"></a>L Link with Level Editor I</h1><blockquote>\n<p>$n$ 个世界， 每个世界有一个 $m$ 个点的无向图，从第一个世界的编号为 $1$ 的点出发，每个世界可以不动或可以走一条边到达下一个点 $u$ ，然后跳到下一个世界的点 $u$ ，如果跳到点 $m$ 则胜利。求一个最短的子段，使得其可胜利。</p>\n</blockquote>\n<p>$(i, u)$ 到 $(i + 1, v)$ 有关系，可以考虑进行状态转移。</p>\n<p>设置 $f[i][j]$ : 表示到达第 $i$ 个世界中的 $j$ 号点最少需要经过多少世界</p>\n<p>初始时： $f[i][1] = 1, f[i][j] = \\infty$ </p>\n<p>两种转移方式：</p>\n<ul>\n<li>在当前世界原地不动，之后到下一个世界。 $f[i][j] + 1 \\rightarrow f[i+1][j] (i &lt; n)$</li>\n<li>在当前世界走一条边，之后到下一个世界。$f[i][u]+1 \\rightarrow f[i+1][v] (i &lt; n),(u, v)$  属于第 $i$ 个世界的一条边。</li>\n</ul>\n<p>第一维可以进行压缩，进行空间优化。</p>\n<blockquote>\n<p> 注意：转移的时候，是先进行走边，然后再到下一个世界。</p>\n<p>当到达第 $i$ 个世界时， 先对上一层状态 $f[]$ 数组不为无穷的加一，代表进入当前世界。然后进行状态转移，转移时候利用的是转移到当前世界的数组（即下面代码的$f[]$ 数组）进行更新。</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vi f(m + 1, 1e9), nf;\n    f[1] = 1;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        int c;\n        cin &gt;&gt; c;\n\n        for(int j = 1; j &lt;= m; j++)\n            if(j != 1 &amp;&amp; j != m &amp;&amp; f[j] != 1e9)\n                f[j]++;// 走到第 i 个世界,世界数加一\n        nf = f;\n        while(c--)\n        {\n            int u, v;\n            cin &gt;&gt; u &gt;&gt; v;\n            nf[v] = min(f[u], nf[v]); // 在第i个世界中进行状态转移，f[]为老的状态，新的状态存在nf[]数组中\n        }\n        f = nf;\n    }\n    cout &lt;&lt; (f[m] == 1e9 ? -1 : f[m]) &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n"},{"title":"CF1055C Lucky Days|裴蜀定理","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":4188452413,"date":"2022-08-08T11:45:25.000Z","password":null,"summary":null,"_content":"\n\n\n# [Lucky Days](https://codeforces.com/problemset/problem/1055/C)\n\n> 给定 $l_a,r_a,t_a,l_b,r_b,t_b$，对于所有的非负整数 $k$，将区间 $[l_a+kt_a,r_a+kt_a]$ 打上标记 $1$，将区间 $[l_b+kt_b,r_b+kt_b]$ 打上标记 $2$。求出最长的连续区间使得该区间中的所有位置都被同时打上的 $1,2$ 标记。\n\n样例一\n\n```\n0 2 5\n1 3 5\n```\n\n```\n2\n```\n\n样例二\n\n```\n0 1 3\n2 3 6\n```\n\n```\n1\n```\n\n\n\n![样例一](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/19d7a3762431cf8ed7d41c7aa787eb194dc6ab47.png)\n\n![样例二](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/dee255111b7c12483568555df6c88766f900f855.png)\n\n\n\n\n\n---\n\n# 思路 \n\n题目要求两个区间的重合度最大的长度。\n\n首先第一个点我们要想到：要想使两个区间的重合度最高，需要让两个区间尽可能逼近。最优的情况就是两个区间的**左端点尽可能相等**，这样重合度是最大的。\n\n即使 $la + x \\* ta = lb + y * tb$\n\n将式子进行移项得 $x \\* ta - y * tb = lb - la$ （此时我们假设$la < lb$，代码中已做相关的操作，这样只是为了方便）\n\n我们需要看式子是否有解，式子结构和**裴蜀定理**比较像，拿出来进行对比。\n\n裴蜀定理 ： 存在整数 $x, y$，满足$a \\* x + b * y = gcd(a,b)$\n\n 该式子进行$y$符号变为正，表示$y$是整数，则 $x \\* ta + y * tb = lb - la$\n\n我们令$d = gcd(ta, tb)$\n\n那么可以发现如果$d | (lb - la)$，则该式子有解，左端点可以重合。\n\n---\n\n但是如果左端点不能重合怎么办，尽可能逼近就行。\n\n此时别忘了式子右边的$lb-la$代表的是什么，是 **区间a左端点移动的距离**，那么因为$x \\* ta + y * tb = d$是存在解的，则**区间a移动的距离可进一步变为** $d$ 。\n\n>  注意：我说的区间a可以移动，是指的一定存在某种状态，上下两个人有两个区间的距离发生了变化，叫为区间移动更容易理解。如\n>\n> $ta = 3,[1,4]->[4,7]->[7,10]->[10,13]$\n>\n> $tb = 4,[3,5]->[7,9]->[11,13]$\n>\n> $[1,4][3,5]$左端点相差$2$，这是一种区间状态，通过移动，会出现另一种区间状态$[10,13][11,13]$左端点相差$1$。移动了一步（$d = gcd(3,4) = 1$）\n\n左端点不重合就尽可能逼近。\n\n有两种状态可能是合适的。\n\n> $dis$代表a区间左端点与b区间左端点相差的最小距离（a区间左端点我认为小于等于b区间左端点），即$dis = (lb - la) \\% d$\n\n- 区间a左端点移动到和区间b左端点相差$(lb-la) \\% d$，可能是距离最近的\n  -  $min(rb - lb + 1, ra - la + 1 - dis)$\n\n- 然后是上面的情况在往后移一步，即区间a左端点超过区间b左端点$d-(lb-la)%d$\n  - $dis = d - dis$ \n  - $min(ra - la + 1, rb - lb + 1 - dis)$\n\n> 两个计算请画图领悟计算方法。\n>\n> 计算：左端点重合的情况可以合并在左端点能合并的代码里面，即左端点合并是左端点不合并的特殊情况。\n\n\n\n# 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\n\n// [l[a] + k * ta, r[a] + k * ta]\n// 3 [1, 4] [4, 7] [7, 10] [10, 13] [13, 16] ---\n// 4 [3, 5] [7, 9] [11, 13]         [15, 17] ---\n// 起点尽可能相同\n// 裴蜀定理：存在x,y 使 ax + by = gcd(a, b)\n// la + x * ta = lb + y * tb\n// x * ta - y * tb = lb - la\n// gcd(ta, tb) | (lb - la)有解\n// d = gcd(ta, tb) 看成相对移动的距离\n// la -> la + d -> la + k * d    lb\n// 差 = lb - la \n// dis = (lb - la) % d\n\nvoid solve()\n{\n\tint la, ra, ta, lb, rb, tb;\n\tcin >> la >> ra >> ta >> lb >> rb >> tb;\n\tif(la > lb)\n\t{\n\t\tswap(la, lb);\n\t\tswap(ra, rb);\n\t\tswap(ta, tb);\n\t}\n\tint d = __gcd(ta, tb);\n\tint dis = (lb - la) % d; // 左端点的差\n\tint ans = 0;\n\tans = max(ans, min(rb - lb + 1, ra - la + 1 - dis));\n\tdis = d - dis; // 向右移动一步\n\tans = max(ans, min(ra - la + 1, rb - lb + 1 - dis));\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\t// cin >> t;\n\tt = 1;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n","source":"_posts/CF1055C-Lucky-Days裴蜀定理.md","raw":"---\ntitle: CF1055C Lucky Days|裴蜀定理\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 数论\n  - 裴蜀定理\ncategories:\n  - 数论\nabbrlink: 4188452413\ndate: 2022-08-08 19:45:25\npassword:\nsummary:\n---\n\n\n\n# [Lucky Days](https://codeforces.com/problemset/problem/1055/C)\n\n> 给定 $l_a,r_a,t_a,l_b,r_b,t_b$，对于所有的非负整数 $k$，将区间 $[l_a+kt_a,r_a+kt_a]$ 打上标记 $1$，将区间 $[l_b+kt_b,r_b+kt_b]$ 打上标记 $2$。求出最长的连续区间使得该区间中的所有位置都被同时打上的 $1,2$ 标记。\n\n样例一\n\n```\n0 2 5\n1 3 5\n```\n\n```\n2\n```\n\n样例二\n\n```\n0 1 3\n2 3 6\n```\n\n```\n1\n```\n\n\n\n![样例一](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/19d7a3762431cf8ed7d41c7aa787eb194dc6ab47.png)\n\n![样例二](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/dee255111b7c12483568555df6c88766f900f855.png)\n\n\n\n\n\n---\n\n# 思路 \n\n题目要求两个区间的重合度最大的长度。\n\n首先第一个点我们要想到：要想使两个区间的重合度最高，需要让两个区间尽可能逼近。最优的情况就是两个区间的**左端点尽可能相等**，这样重合度是最大的。\n\n即使 $la + x \\* ta = lb + y * tb$\n\n将式子进行移项得 $x \\* ta - y * tb = lb - la$ （此时我们假设$la < lb$，代码中已做相关的操作，这样只是为了方便）\n\n我们需要看式子是否有解，式子结构和**裴蜀定理**比较像，拿出来进行对比。\n\n裴蜀定理 ： 存在整数 $x, y$，满足$a \\* x + b * y = gcd(a,b)$\n\n 该式子进行$y$符号变为正，表示$y$是整数，则 $x \\* ta + y * tb = lb - la$\n\n我们令$d = gcd(ta, tb)$\n\n那么可以发现如果$d | (lb - la)$，则该式子有解，左端点可以重合。\n\n---\n\n但是如果左端点不能重合怎么办，尽可能逼近就行。\n\n此时别忘了式子右边的$lb-la$代表的是什么，是 **区间a左端点移动的距离**，那么因为$x \\* ta + y * tb = d$是存在解的，则**区间a移动的距离可进一步变为** $d$ 。\n\n>  注意：我说的区间a可以移动，是指的一定存在某种状态，上下两个人有两个区间的距离发生了变化，叫为区间移动更容易理解。如\n>\n> $ta = 3,[1,4]->[4,7]->[7,10]->[10,13]$\n>\n> $tb = 4,[3,5]->[7,9]->[11,13]$\n>\n> $[1,4][3,5]$左端点相差$2$，这是一种区间状态，通过移动，会出现另一种区间状态$[10,13][11,13]$左端点相差$1$。移动了一步（$d = gcd(3,4) = 1$）\n\n左端点不重合就尽可能逼近。\n\n有两种状态可能是合适的。\n\n> $dis$代表a区间左端点与b区间左端点相差的最小距离（a区间左端点我认为小于等于b区间左端点），即$dis = (lb - la) \\% d$\n\n- 区间a左端点移动到和区间b左端点相差$(lb-la) \\% d$，可能是距离最近的\n  -  $min(rb - lb + 1, ra - la + 1 - dis)$\n\n- 然后是上面的情况在往后移一步，即区间a左端点超过区间b左端点$d-(lb-la)%d$\n  - $dis = d - dis$ \n  - $min(ra - la + 1, rb - lb + 1 - dis)$\n\n> 两个计算请画图领悟计算方法。\n>\n> 计算：左端点重合的情况可以合并在左端点能合并的代码里面，即左端点合并是左端点不合并的特殊情况。\n\n\n\n# 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\n\n// [l[a] + k * ta, r[a] + k * ta]\n// 3 [1, 4] [4, 7] [7, 10] [10, 13] [13, 16] ---\n// 4 [3, 5] [7, 9] [11, 13]         [15, 17] ---\n// 起点尽可能相同\n// 裴蜀定理：存在x,y 使 ax + by = gcd(a, b)\n// la + x * ta = lb + y * tb\n// x * ta - y * tb = lb - la\n// gcd(ta, tb) | (lb - la)有解\n// d = gcd(ta, tb) 看成相对移动的距离\n// la -> la + d -> la + k * d    lb\n// 差 = lb - la \n// dis = (lb - la) % d\n\nvoid solve()\n{\n\tint la, ra, ta, lb, rb, tb;\n\tcin >> la >> ra >> ta >> lb >> rb >> tb;\n\tif(la > lb)\n\t{\n\t\tswap(la, lb);\n\t\tswap(ra, rb);\n\t\tswap(ta, tb);\n\t}\n\tint d = __gcd(ta, tb);\n\tint dis = (lb - la) % d; // 左端点的差\n\tint ans = 0;\n\tans = max(ans, min(rb - lb + 1, ra - la + 1 - dis));\n\tdis = d - dis; // 向右移动一步\n\tans = max(ans, min(ra - la + 1, rb - lb + 1 - dis));\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\t// cin >> t;\n\tt = 1;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n","slug":"CF1055C-Lucky-Days裴蜀定理","published":1,"updated":"2022-08-09T13:29:47.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolgy000m6kuhr4hoineg","content":"<h1 id=\"Lucky-Days\"><a href=\"#Lucky-Days\" class=\"headerlink\" title=\"Lucky Days\"></a><a href=\"https://codeforces.com/problemset/problem/1055/C\" target=\"_blank\" rel=\"noopener\">Lucky Days</a></h1><blockquote>\n<p>给定 $l_a,r_a,t_a,l_b,r_b,t_b$，对于所有的非负整数 $k$，将区间 $[l_a+kt_a,r_a+kt_a]$ 打上标记 $1$，将区间 $[l_b+kt_b,r_b+kt_b]$ 打上标记 $2$。求出最长的连续区间使得该区间中的所有位置都被同时打上的 $1,2$ 标记。</p>\n</blockquote>\n<p>样例一</p>\n<pre><code>0 2 5\n1 3 5</code></pre><pre><code>2</code></pre><p>样例二</p>\n<pre><code>0 1 3\n2 3 6</code></pre><pre><code>1</code></pre><p><img src=\"https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/19d7a3762431cf8ed7d41c7aa787eb194dc6ab47.png\" alt=\"样例一\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/dee255111b7c12483568555df6c88766f900f855.png\" alt=\"样例二\"></p>\n<hr>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>题目要求两个区间的重合度最大的长度。</p>\n<p>首先第一个点我们要想到：要想使两个区间的重合度最高，需要让两个区间尽可能逼近。最优的情况就是两个区间的<strong>左端点尽可能相等</strong>，这样重合度是最大的。</p>\n<p>即使 $la + x * ta = lb + y * tb$</p>\n<p>将式子进行移项得 $x * ta - y * tb = lb - la$ （此时我们假设$la &lt; lb$，代码中已做相关的操作，这样只是为了方便）</p>\n<p>我们需要看式子是否有解，式子结构和<strong>裴蜀定理</strong>比较像，拿出来进行对比。</p>\n<p>裴蜀定理 ： 存在整数 $x, y$，满足$a * x + b * y = gcd(a,b)$</p>\n<p> 该式子进行$y$符号变为正，表示$y$是整数，则 $x * ta + y * tb = lb - la$</p>\n<p>我们令$d = gcd(ta, tb)$</p>\n<p>那么可以发现如果$d | (lb - la)$，则该式子有解，左端点可以重合。</p>\n<hr>\n<p>但是如果左端点不能重合怎么办，尽可能逼近就行。</p>\n<p>此时别忘了式子右边的$lb-la$代表的是什么，是 <strong>区间a左端点移动的距离</strong>，那么因为$x * ta + y <em> tb = d$是存在解的，则<em>*区间a移动的距离可进一步变为</em></em> $d$ 。</p>\n<blockquote>\n<p> 注意：我说的区间a可以移动，是指的一定存在某种状态，上下两个人有两个区间的距离发生了变化，叫为区间移动更容易理解。如</p>\n<p>$ta = 3,[1,4]-&gt;[4,7]-&gt;[7,10]-&gt;[10,13]$</p>\n<p>$tb = 4,[3,5]-&gt;[7,9]-&gt;[11,13]$</p>\n<p>$[1,4][3,5]$左端点相差$2$，这是一种区间状态，通过移动，会出现另一种区间状态$[10,13][11,13]$左端点相差$1$。移动了一步（$d = gcd(3,4) = 1$）</p>\n</blockquote>\n<p>左端点不重合就尽可能逼近。</p>\n<p>有两种状态可能是合适的。</p>\n<blockquote>\n<p>$dis$代表a区间左端点与b区间左端点相差的最小距离（a区间左端点我认为小于等于b区间左端点），即$dis = (lb - la) \\% d$</p>\n</blockquote>\n<ul>\n<li><p>区间a左端点移动到和区间b左端点相差$(lb-la) \\% d$，可能是距离最近的</p>\n<ul>\n<li>$min(rb - lb + 1, ra - la + 1 - dis)$</li>\n</ul>\n</li>\n<li><p>然后是上面的情况在往后移一步，即区间a左端点超过区间b左端点$d-(lb-la)%d$</p>\n<ul>\n<li>$dis = d - dis$ </li>\n<li>$min(ra - la + 1, rb - lb + 1 - dis)$</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>两个计算请画图领悟计算方法。</p>\n<p>计算：左端点重合的情况可以合并在左端点能合并的代码里面，即左端点合并是左端点不合并的特殊情况。</p>\n</blockquote>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// [l[a] + k * ta, r[a] + k * ta]</span>\n<span class=\"token comment\" spellcheck=\"true\">// 3 [1, 4] [4, 7] [7, 10] [10, 13] [13, 16] ---</span>\n<span class=\"token comment\" spellcheck=\"true\">// 4 [3, 5] [7, 9] [11, 13]         [15, 17] ---</span>\n<span class=\"token comment\" spellcheck=\"true\">// 起点尽可能相同</span>\n<span class=\"token comment\" spellcheck=\"true\">// 裴蜀定理：存在x,y 使 ax + by = gcd(a, b)</span>\n<span class=\"token comment\" spellcheck=\"true\">// la + x * ta = lb + y * tb</span>\n<span class=\"token comment\" spellcheck=\"true\">// x * ta - y * tb = lb - la</span>\n<span class=\"token comment\" spellcheck=\"true\">// gcd(ta, tb) | (lb - la)有解</span>\n<span class=\"token comment\" spellcheck=\"true\">// d = gcd(ta, tb) 看成相对移动的距离</span>\n<span class=\"token comment\" spellcheck=\"true\">// la -> la + d -> la + k * d    lb</span>\n<span class=\"token comment\" spellcheck=\"true\">// 差 = lb - la </span>\n<span class=\"token comment\" spellcheck=\"true\">// dis = (lb - la) % d</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> la<span class=\"token punctuation\">,</span> ra<span class=\"token punctuation\">,</span> ta<span class=\"token punctuation\">,</span> lb<span class=\"token punctuation\">,</span> rb<span class=\"token punctuation\">,</span> tb<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> la <span class=\"token operator\">>></span> ra <span class=\"token operator\">>></span> ta <span class=\"token operator\">>></span> lb <span class=\"token operator\">>></span> rb <span class=\"token operator\">>></span> tb<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>la <span class=\"token operator\">></span> lb<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>la<span class=\"token punctuation\">,</span> lb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>ra<span class=\"token punctuation\">,</span> rb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">,</span> tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> <span class=\"token function\">__gcd</span><span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">,</span> tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> dis <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>lb <span class=\"token operator\">-</span> la<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> d<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 左端点的差</span>\n    <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>rb <span class=\"token operator\">-</span> lb <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> ra <span class=\"token operator\">-</span> la <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> dis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    dis <span class=\"token operator\">=</span> d <span class=\"token operator\">-</span> dis<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 向右移动一步</span>\n    ans <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>ra <span class=\"token operator\">-</span> la <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> rb <span class=\"token operator\">-</span> lb <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> dis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"Lucky-Days\"><a href=\"#Lucky-Days\" class=\"headerlink\" title=\"Lucky Days\"></a><a href=\"https://codeforces.com/problemset/problem/1055/C\" target=\"_blank\" rel=\"noopener\">Lucky Days</a></h1><blockquote>\n<p>给定 $l_a,r_a,t_a,l_b,r_b,t_b$，对于所有的非负整数 $k$，将区间 $[l_a+kt_a,r_a+kt_a]$ 打上标记 $1$，将区间 $[l_b+kt_b,r_b+kt_b]$ 打上标记 $2$。求出最长的连续区间使得该区间中的所有位置都被同时打上的 $1,2$ 标记。</p>\n</blockquote>\n<p>样例一</p>\n<pre><code>0 2 5\n1 3 5</code></pre><pre><code>2</code></pre><p>样例二</p>\n<pre><code>0 1 3\n2 3 6</code></pre><pre><code>1</code></pre><p><img src=\"https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/19d7a3762431cf8ed7d41c7aa787eb194dc6ab47.png\" alt=\"样例一\"></p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/dee255111b7c12483568555df6c88766f900f855.png\" alt=\"样例二\"></p>\n<hr>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>题目要求两个区间的重合度最大的长度。</p>\n<p>首先第一个点我们要想到：要想使两个区间的重合度最高，需要让两个区间尽可能逼近。最优的情况就是两个区间的<strong>左端点尽可能相等</strong>，这样重合度是最大的。</p>\n<p>即使 $la + x * ta = lb + y * tb$</p>\n<p>将式子进行移项得 $x * ta - y * tb = lb - la$ （此时我们假设$la &lt; lb$，代码中已做相关的操作，这样只是为了方便）</p>\n<p>我们需要看式子是否有解，式子结构和<strong>裴蜀定理</strong>比较像，拿出来进行对比。</p>\n<p>裴蜀定理 ： 存在整数 $x, y$，满足$a * x + b * y = gcd(a,b)$</p>\n<p> 该式子进行$y$符号变为正，表示$y$是整数，则 $x * ta + y * tb = lb - la$</p>\n<p>我们令$d = gcd(ta, tb)$</p>\n<p>那么可以发现如果$d | (lb - la)$，则该式子有解，左端点可以重合。</p>\n<hr>\n<p>但是如果左端点不能重合怎么办，尽可能逼近就行。</p>\n<p>此时别忘了式子右边的$lb-la$代表的是什么，是 <strong>区间a左端点移动的距离</strong>，那么因为$x * ta + y <em> tb = d$是存在解的，则<em>*区间a移动的距离可进一步变为</em></em> $d$ 。</p>\n<blockquote>\n<p> 注意：我说的区间a可以移动，是指的一定存在某种状态，上下两个人有两个区间的距离发生了变化，叫为区间移动更容易理解。如</p>\n<p>$ta = 3,[1,4]-&gt;[4,7]-&gt;[7,10]-&gt;[10,13]$</p>\n<p>$tb = 4,[3,5]-&gt;[7,9]-&gt;[11,13]$</p>\n<p>$[1,4][3,5]$左端点相差$2$，这是一种区间状态，通过移动，会出现另一种区间状态$[10,13][11,13]$左端点相差$1$。移动了一步（$d = gcd(3,4) = 1$）</p>\n</blockquote>\n<p>左端点不重合就尽可能逼近。</p>\n<p>有两种状态可能是合适的。</p>\n<blockquote>\n<p>$dis$代表a区间左端点与b区间左端点相差的最小距离（a区间左端点我认为小于等于b区间左端点），即$dis = (lb - la) \\% d$</p>\n</blockquote>\n<ul>\n<li><p>区间a左端点移动到和区间b左端点相差$(lb-la) \\% d$，可能是距离最近的</p>\n<ul>\n<li>$min(rb - lb + 1, ra - la + 1 - dis)$</li>\n</ul>\n</li>\n<li><p>然后是上面的情况在往后移一步，即区间a左端点超过区间b左端点$d-(lb-la)%d$</p>\n<ul>\n<li>$dis = d - dis$ </li>\n<li>$min(ra - la + 1, rb - lb + 1 - dis)$</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>两个计算请画图领悟计算方法。</p>\n<p>计算：左端点重合的情况可以合并在左端点能合并的代码里面，即左端点合并是左端点不合并的特殊情况。</p>\n</blockquote>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\n\n// [l[a] + k * ta, r[a] + k * ta]\n// 3 [1, 4] [4, 7] [7, 10] [10, 13] [13, 16] ---\n// 4 [3, 5] [7, 9] [11, 13]         [15, 17] ---\n// 起点尽可能相同\n// 裴蜀定理：存在x,y 使 ax + by = gcd(a, b)\n// la + x * ta = lb + y * tb\n// x * ta - y * tb = lb - la\n// gcd(ta, tb) | (lb - la)有解\n// d = gcd(ta, tb) 看成相对移动的距离\n// la -&gt; la + d -&gt; la + k * d    lb\n// 差 = lb - la \n// dis = (lb - la) % d\n\nvoid solve()\n{\n    int la, ra, ta, lb, rb, tb;\n    cin &gt;&gt; la &gt;&gt; ra &gt;&gt; ta &gt;&gt; lb &gt;&gt; rb &gt;&gt; tb;\n    if(la &gt; lb)\n    {\n        swap(la, lb);\n        swap(ra, rb);\n        swap(ta, tb);\n    }\n    int d = __gcd(ta, tb);\n    int dis = (lb - la) % d; // 左端点的差\n    int ans = 0;\n    ans = max(ans, min(rb - lb + 1, ra - la + 1 - dis));\n    dis = d - dis; // 向右移动一步\n    ans = max(ans, min(ra - la + 1, rb - lb + 1 - dis));\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    // cin &gt;&gt; t;\n    t = 1;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n"},{"title":"2022牛客多校补题3","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":3182360886,"date":"2022-09-07T14:26:25.000Z","password":null,"summary":null,"_content":"\n# [2022牛客多校3补题](https://ac.nowcoder.com/acm/contest/33188)\n\n# A\n\n> 给出两棵编号 $1-n$ 的树A和B，A和B树上每个节点均有一个权值，给出 $k$ 个关键点\n>\n> 的编号 $x_1…x_n$ ，问有多少种方案使得去掉恰好一个关键点使得剩余关键点在树A上\n>\n> LCA的权值大于树B上LCA的权值\n\n观察和不断模拟可以发现一系列的点的LCA可以通过前缀LCA实现。\n\n故预处理出关键点序列的在树A B上的前缀LCA和后缀LCA，枚举去掉的关键节点并使用前后缀LCA算出剩余节点的LCA比较权值即可。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct Tree {\n    std::vector<int> sz, top, dep, parent, in;\n    int cur;\n    std::vector<std::vector<int>> e;\n    Tree(int n) : sz(n), top(n), dep(n), parent(n, -1), e(n), in(n), cur(0) {}\n    void addEdge(int u, int v) {\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    void init() {\n        dfsSz(0);\n        dfsHLD(0);\n    }\n    void dfsSz(int u) {\n        if (parent[u] != -1)\n            e[u].erase(std::find(e[u].begin(), e[u].end(), parent[u]));\n        sz[u] = 1;\n        for (int &v : e[u]) {\n            parent[v] = u;\n            dep[v] = dep[u] + 1;\n            dfsSz(v);\n            sz[u] += sz[v];\n            if (sz[v] > sz[e[u][0]])\n                std::swap(v, e[u][0]);\n        }\n    }\n    void dfsHLD(int u) {\n        in[u] = cur++;\n        for (int v : e[u]) {\n            if (v == e[u][0]) {\n                top[v] = top[u];\n            } else {\n                top[v] = v;\n            }\n            dfsHLD(v);\n        }\n    }\n    int lca(int u, int v) {\n        while (top[u] != top[v]) {\n            if (dep[top[u]] > dep[top[v]]) {\n                u = parent[top[u]];\n            } else {\n                v = parent[top[v]];\n            }\n        }\n        if (dep[u] < dep[v]) {\n            return u;\n        } else {\n            return v;\n        }\n    }\n};\nvoid solve()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tvi x(k);\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tcin >> x[i];\n\t\tx[i]--;\n\t}\n\n\tTree A(n), B(n);\n\tvi a(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\tp--;\n\t\tA.addEdge(i, p);\n\t}\n\tvi b(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> b[i];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\tp--;\n\t\tB.addEdge(i, p);\n\t}\n\tA.init();\n\tB.init();\n\n\tvi prea(k), sufa(k), preb(k), sufb(k);\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tif(i == 0)\n\t\t\tprea[i] = preb[i] = x[i];\n\t\telse\n\t\t{\n\t\t\tprea[i] = A.lca(prea[i - 1], x[i]);\n\t\t\tpreb[i] = B.lca(preb[i - 1], x[i]);\n\t\t}\n\t}\n\tfor(int i = k - 1; i >= 0; i--)\n\t{\n\t\tif(i == k - 1)\n\t\t\tsufa[i] = sufb[i] = x[i];\n\t\telse\n\t\t{\n\t\t\tsufa[i] = A.lca(sufa[i + 1], x[i]);\n\t\t\tsufb[i] = B.lca(sufb[i + 1], x[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\tif(a[sufa[i + 1]] > b[sufb[i + 1]])\n\t\t\t\tans++;\n\t\t}\n\t\telse if(i == k - 1)\n\t\t{\n\t\t\tif(a[prea[i - 1]] > b[preb[i -  1]])\n\t\t\t\tans++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint va = A.lca(prea[i - 1], sufa[i + 1]);\n\t\t\tint vb = B.lca(preb[i - 1], sufb[i + 1]);\n\t\t\tif(a[va] > b[vb])\n\t\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# C\n\n> 题意： 给定n个字符串，求一个将他们拼接起来的方案，使得结果的字典序最小。\n\n对$n$个字符串排序， $a$ 在 $b$ 前面的条件是 $a + b < b + a$ \n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<string> s(n + 1);\n    for(int i = 1; i <= n; i++)\n        cin >> s[i];\n    sort(s.begin() + 1, s.end(), [](string a, string b){\n        return a + b < b + a;\n    });\n    for(int i = 1; i <= n; i++)\n        cout << s[i];\n    cout << \"\\n\";\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    // cin >> t;\n    t = 1;\n    while(t--)\n        solve();\n    return 0;\n}\n```\n\n\n\n# F\n\n> 给定一个n个点m条边的无向图，每次询问两点x, y，求是否存在一个n的排列，使得第一个元素为x，最后一个元素为y，且排列的任意一个前缀、任意一个后\n>\n> 缀都连通\n\n考虑一条链，那么两端的顶点是满足情况的，如果是其他的两个点那么不满足情况。\n\n考虑一个环，发现环中的任意两个点都满足情况。\n\n考虑一个图，图中可能存在环。\n\n那么对所有的点双缩点之后，必须是一条链，如果不是一条链就不能满足。首先通过tarjan求出割点以及点双。\n\n如果图本身就不连通（即有多个连通块），不满足。\n\n如果点双等于1，即是一个环，满足。\n\n接下来是对于一般的连通图，我们对于边界处的点双进行赋值，第一个边界处点双非割点全部赋为1，第二个边界处点双中非割点全部赋为2，那么询问时，如果两个点的值加和是3，即可以满足要求。\n\n主要是如何判断是否是处于边界的点双，边界处的点双，那么此点双中的割点所在点双只有2个，不能有多个，如果有多个，必然不是在边界（因为存在一个割点至少则会存在两个点双）。\n\n代码中为什么没有 $d = 2$\n\n因为存在以下情况：\n\n![满足的情况](3182360886/image-20220907221918311.png)\n\n上图是满足情况的，中间的点双连通分量的 $d = 2$ ，但是边界1和6点都已经确定了，可以通过边界确定是否满足情况。\n\n![不满足的情况](3182360886/image-20220907222225218.png)\n\n上图是不满足情况的，中间的点双中 $d = 2$，但是边界也可以确定，同样可以通过边界来判断是否满足情况。\n\n那么其他情况也是如此，都是可以通过边界点双连通分量来判断， $d = 2$ 因为牵扯到有满足情况和不满足情况的，暂不考虑（但是他们可以通过边界点双来判断）\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n// sum[i] 是点i所在点双连通分量的个数\n// ans[i] 是点i所在第几个边界的点双连通分量中\nint low[N], dfn[N], stk[N], top, ts, dcc_cnt, root = 1, sum[N], ans[N];\nvector<int> dcc[N], e[N];\nbool cut[N];\nvoid tarjan(int u)\n{\n\tdfn[u] = low[u] = ++ts;\n\tstk[++top] = u;\n\n\tint flag = 0;\n\tfor(auto v : e[u])\n\t{\n\t\tif(!dfn[v])\n\t\t{\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\tif(dfn[u] <= low[v])\n\t\t\t{\n\t\t\t\tflag++;\n\t\t\t\tdcc_cnt++;\n\t\t\t\tif(u != root || flag > 1) cut[u] = 1;\n\t\t\t\tint x;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tx = stk[top--];\n\t\t\t\t\tsum[x]++;\n\t\t\t\t\tdcc[dcc_cnt].push_back(x);\n\t\t\t\t}while(x != v);\n\t\t\t\tdcc[dcc_cnt].push_back(u);\n\t\t\t\tsum[u]++;\n\t\t\t}\n\t\t}\n\t\telse low[u] = min(low[u], dfn[v]);\n\t}\n}\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\ttarjan(1);\n\n\tbool is = 1;\n\tfor(int i = 1; i <= n && is; i++)\n\t\tif(!dfn[i])\n\t\t\tis = 0;\n\n\tif(is && dcc_cnt != 1)\n\t{\n\t\tint id = 0;\n\t\tfor(int i = 1; i <= dcc_cnt; i++)\n\t\t{\n\t\t\tint d = 0; \n\t\t\tfor(auto x : dcc[i])\n\t\t\t\tif(cut[x]) d += sum[x] - 1;\n\n\t\t\tif(d > 2) is = 0; // \n\t\t\telse if(d == 1) // 端点处的点双\n\t\t\t{\n\t\t\t\tid++; // 端点处点双个数加1\n\t\t\t\tfor(auto x : dcc[i])\n\t\t\t\t\tif(!cut[x])\n\t\t\t\t\t\tans[x] = id; // 此点双中非割点赋值\n\t\t\t}\n\t\t}\n\t}\n\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(!is) cout << \"NO\\n\";\n\t\telse if(dcc_cnt == 1) cout << \"YES\\n\";\n\t\telse\n\t\t{\n\t\t\tif(ans[x] + ans[y] == 3) cout << \"YES\\n\";\n\t\t\telse cout << \"NO\\n\";\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# H\n\n> 给出长度为 $n$ 的小写字符串A和 $k$ 个长度为 $m$ 的小写字符串 $B_1…B_k$ ，B的每个位置拥有统一的权值 $v_1…v_m$ ，对于每个 $B_i$ 求最大和区间满足该区间构成的字符串是A的子串（空区间合法）。\n\n可以将问题进行转化，相当于对 $B_i$ 的每个位置求出它作为结束位置在 A 中的最长子串长度，然后在该区间求最大子段和，所有位置的最大值即为答案。\n\n对于每个位置的最长子串，可以对 A 建后缀自动机，然后 $B_i$ 从左往右在A的后缀自动机上转移，如果当前节点无法转移则跳至父亲节点（表示去掉一个前缀字符再次进行匹配），最后无法转移则长度为 0 ，转移成功则为转移前节点的最大长度**加一**。\n\n最大子段和可以通过前缀和与ST表求，B中满足是A的子串的区间为 $[l, r]$ 时， 则最大子段和可以通过 $s[r] - min(s[j]), l \\leq j \\lt r$ 不断进行更新。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct SuffixAutomaton {\n    static constexpr int ALPHABET_SIZE = 26, N = 1e5;\n    struct Node {\n        int len;\n        int link;\n        int next[ALPHABET_SIZE];\n        Node() : len(0), link(0), next{} {}\n    } t[2 * N];\n    int cntNodes;\n    SuffixAutomaton() {\n        cntNodes = 1;\n        std::fill(t[0].next, t[0].next + ALPHABET_SIZE, 1);\n        t[0].len = -1;\n    }\n    void init(string s) {\n        int p = 1;\n        for(auto x : s)\n            p = extend(p, x - 'a');        \n    }\n    int extend(int p, int c) {\n        if (t[p].next[c]) {\n            int q = t[p].next[c];\n            if (t[q].len == t[p].len + 1)\n                return q;\n            int r = ++cntNodes;\n            t[r].len = t[p].len + 1;\n            t[r].link = t[q].link;\n            std::copy(t[q].next, t[q].next + ALPHABET_SIZE, t[r].next);\n            t[q].link = r;\n            while (t[p].next[c] == q) {\n                t[p].next[c] = r;\n                p = t[p].link;\n            }\n            return r;\n        }\n        int cur = ++cntNodes;\n        t[cur].len = t[p].len + 1;\n        while (!t[p].next[c]) {\n            t[p].next[c] = cur;\n            p = t[p].link;\n        }\n        t[cur].link = extend(p, c);\n        return cur;\n    }\n}sam;\n\nll f[N][30], a[N];\nint lg[N];\nvoid init(int n)\n{\n    lg[0] = -1;\n    for(int i = 1; i <= n; i++)\n    {\n        lg[i] = lg[i - 1] + (i & (i - 1) ? 0 : 1);\n        f[i][0] = a[i];\n    }\n    for(int j = 1; j <= lg[n]; j++)\n        for(int i = 0; i + (1 << j) - 1 <= n; i++)\n            f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n}\nll query(int l, int r)\n{\n    int k = lg[r - l + 1];\n    return min(f[l][k], f[r - (1 << k) + 1][k]);\n}\n\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    string s;\n    cin >> s;\n    sam.init(s);\n\n    for(int i = 1; i <= m; i++)\n    {\n        cin >> a[i];\n        a[i] += a[i - 1];\n    }\n    init(m);\n\n    while(k--)\n    {\n        ll ans = 0;\n        string t;\n        cin >> t;\n        t = \" \" + t;\n        int p = 1, l = 0;\n        for(int i = 1; i <= m; i++)\n        {\n            int c = t[i] - 'a';\n            while(p && !sam.t[p].next[c])\n                p = sam.t[p].link, l = sam.t[p].len;\n            if(p)\n            {\n                p = sam.t[p].next[c], l++;\n                Max(ans, a[i] - query(i - l, i - 1));\n            }\n            else p = 1, l = 0;\n        }\n        cout << ans << \"\\n\";\n    }\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# J\n\n> 给定一个城市有若干十字路口，右转不需要等红灯，直行、左转和掉头都需要，求起\n>\n> 点到终点最少等几次红灯\n\n把每条路看做点，十字路口处连边，形成一个边权为0/1的有向图。\n\n可以使用`dijkstra`求最短路。\n\n同时也可以用`01BFS`解决，此时使用deque维护队列，边权为0时入队头，边权为1时入队尾。\n\n无论一个路口四个方向怎么给，因为都是按照逆时针方向给出的，所以所有路的相对关系都可以得到，每走到一个路口，都会知道当前路口的四个方向的情况。\n\n$dis[i][j]$ 代表从起点的路到达终点路的最小等待数，因为点数过多，将第二维压缩，压缩成四个方向，即到达（ $i$，$i$ 路口的第 $j$ 个方向指向的路口）这条路上。\n\n队列中存的是路的起始和结束位置，以及到达该路上的最小等待红灯数。\n\n> 对于01BFS的理解，我们首先扩展的是距离等于0的位置（这样肯定是最优的，没有距离嘛），所以就是先走当前的最短路，然后再扩展有距离的路，也是一层一层的扩展。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 5e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint dis[N][4], to[N][4];\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tcin >> to[i][j];\n\n\tint sx, sy, fx, fy;\n\tcin >> sx >> sy >> fx >> fy;\n\n\tmemset(dis, 0x3f, sizeof dis);\n\n\tdeque<array<int, 3>> dq;\n\tdq.push_front({sx, sy, 0});\n\twhile(!dq.empty())\n\t{\n\t\tauto t = dq.front();\n\t\tdq.pop_front();\n\n\t\tint x = t[0], y = t[1], w = t[2];\n\n\t\tif(!y) continue;\n\t\tint id = -1;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tif(to[x][i] == y)\n\t\t\t\tid = i;\n\t\t}\n\t\tif(dis[x][id] > w)\n\t\t\tdis[x][id] = w;\n\t\telse continue;\n\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tif(to[y][i] == x)\n\t\t\t\tid = (i + 1) % 4;\n\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tif(i == id)\n\t\t\t\tdq.push_front({y, to[y][i], w});\n\t\t\telse dq.push_back({y, to[y][i], w + 1});\n\t\t}\n\t}\n\n\tint id = -1;\n\tfor(int i = 0; i < 4; i++)\n\t\tif(to[fx][i] == fy)\n\t\t\tid = i;\n\tif(dis[fx][id] == 0x3f3f3f3f) cout << \"-1\\n\";\n\telse cout << dis[fx][id] << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n","source":"_posts/2022牛客多校补题3.md","raw":"---\ntitle: 2022牛客多校补题3\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 多校\ncategories:\n  - 多校\nabbrlink: 3182360886\ndate: 2022-09-07 22:26:25\npassword:\nsummary:\n---\n\n# [2022牛客多校3补题](https://ac.nowcoder.com/acm/contest/33188)\n\n# A\n\n> 给出两棵编号 $1-n$ 的树A和B，A和B树上每个节点均有一个权值，给出 $k$ 个关键点\n>\n> 的编号 $x_1…x_n$ ，问有多少种方案使得去掉恰好一个关键点使得剩余关键点在树A上\n>\n> LCA的权值大于树B上LCA的权值\n\n观察和不断模拟可以发现一系列的点的LCA可以通过前缀LCA实现。\n\n故预处理出关键点序列的在树A B上的前缀LCA和后缀LCA，枚举去掉的关键节点并使用前后缀LCA算出剩余节点的LCA比较权值即可。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct Tree {\n    std::vector<int> sz, top, dep, parent, in;\n    int cur;\n    std::vector<std::vector<int>> e;\n    Tree(int n) : sz(n), top(n), dep(n), parent(n, -1), e(n), in(n), cur(0) {}\n    void addEdge(int u, int v) {\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    void init() {\n        dfsSz(0);\n        dfsHLD(0);\n    }\n    void dfsSz(int u) {\n        if (parent[u] != -1)\n            e[u].erase(std::find(e[u].begin(), e[u].end(), parent[u]));\n        sz[u] = 1;\n        for (int &v : e[u]) {\n            parent[v] = u;\n            dep[v] = dep[u] + 1;\n            dfsSz(v);\n            sz[u] += sz[v];\n            if (sz[v] > sz[e[u][0]])\n                std::swap(v, e[u][0]);\n        }\n    }\n    void dfsHLD(int u) {\n        in[u] = cur++;\n        for (int v : e[u]) {\n            if (v == e[u][0]) {\n                top[v] = top[u];\n            } else {\n                top[v] = v;\n            }\n            dfsHLD(v);\n        }\n    }\n    int lca(int u, int v) {\n        while (top[u] != top[v]) {\n            if (dep[top[u]] > dep[top[v]]) {\n                u = parent[top[u]];\n            } else {\n                v = parent[top[v]];\n            }\n        }\n        if (dep[u] < dep[v]) {\n            return u;\n        } else {\n            return v;\n        }\n    }\n};\nvoid solve()\n{\n\tint n, k;\n\tcin >> n >> k;\n\tvi x(k);\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tcin >> x[i];\n\t\tx[i]--;\n\t}\n\n\tTree A(n), B(n);\n\tvi a(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\tp--;\n\t\tA.addEdge(i, p);\n\t}\n\tvi b(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> b[i];\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\tp--;\n\t\tB.addEdge(i, p);\n\t}\n\tA.init();\n\tB.init();\n\n\tvi prea(k), sufa(k), preb(k), sufb(k);\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tif(i == 0)\n\t\t\tprea[i] = preb[i] = x[i];\n\t\telse\n\t\t{\n\t\t\tprea[i] = A.lca(prea[i - 1], x[i]);\n\t\t\tpreb[i] = B.lca(preb[i - 1], x[i]);\n\t\t}\n\t}\n\tfor(int i = k - 1; i >= 0; i--)\n\t{\n\t\tif(i == k - 1)\n\t\t\tsufa[i] = sufb[i] = x[i];\n\t\telse\n\t\t{\n\t\t\tsufa[i] = A.lca(sufa[i + 1], x[i]);\n\t\t\tsufb[i] = B.lca(sufb[i + 1], x[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tif(i == 0)\n\t\t{\n\t\t\tif(a[sufa[i + 1]] > b[sufb[i + 1]])\n\t\t\t\tans++;\n\t\t}\n\t\telse if(i == k - 1)\n\t\t{\n\t\t\tif(a[prea[i - 1]] > b[preb[i -  1]])\n\t\t\t\tans++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint va = A.lca(prea[i - 1], sufa[i + 1]);\n\t\t\tint vb = B.lca(preb[i - 1], sufb[i + 1]);\n\t\t\tif(a[va] > b[vb])\n\t\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# C\n\n> 题意： 给定n个字符串，求一个将他们拼接起来的方案，使得结果的字典序最小。\n\n对$n$个字符串排序， $a$ 在 $b$ 前面的条件是 $a + b < b + a$ \n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<string> s(n + 1);\n    for(int i = 1; i <= n; i++)\n        cin >> s[i];\n    sort(s.begin() + 1, s.end(), [](string a, string b){\n        return a + b < b + a;\n    });\n    for(int i = 1; i <= n; i++)\n        cout << s[i];\n    cout << \"\\n\";\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    // cin >> t;\n    t = 1;\n    while(t--)\n        solve();\n    return 0;\n}\n```\n\n\n\n# F\n\n> 给定一个n个点m条边的无向图，每次询问两点x, y，求是否存在一个n的排列，使得第一个元素为x，最后一个元素为y，且排列的任意一个前缀、任意一个后\n>\n> 缀都连通\n\n考虑一条链，那么两端的顶点是满足情况的，如果是其他的两个点那么不满足情况。\n\n考虑一个环，发现环中的任意两个点都满足情况。\n\n考虑一个图，图中可能存在环。\n\n那么对所有的点双缩点之后，必须是一条链，如果不是一条链就不能满足。首先通过tarjan求出割点以及点双。\n\n如果图本身就不连通（即有多个连通块），不满足。\n\n如果点双等于1，即是一个环，满足。\n\n接下来是对于一般的连通图，我们对于边界处的点双进行赋值，第一个边界处点双非割点全部赋为1，第二个边界处点双中非割点全部赋为2，那么询问时，如果两个点的值加和是3，即可以满足要求。\n\n主要是如何判断是否是处于边界的点双，边界处的点双，那么此点双中的割点所在点双只有2个，不能有多个，如果有多个，必然不是在边界（因为存在一个割点至少则会存在两个点双）。\n\n代码中为什么没有 $d = 2$\n\n因为存在以下情况：\n\n![满足的情况](3182360886/image-20220907221918311.png)\n\n上图是满足情况的，中间的点双连通分量的 $d = 2$ ，但是边界1和6点都已经确定了，可以通过边界确定是否满足情况。\n\n![不满足的情况](3182360886/image-20220907222225218.png)\n\n上图是不满足情况的，中间的点双中 $d = 2$，但是边界也可以确定，同样可以通过边界来判断是否满足情况。\n\n那么其他情况也是如此，都是可以通过边界点双连通分量来判断， $d = 2$ 因为牵扯到有满足情况和不满足情况的，暂不考虑（但是他们可以通过边界点双来判断）\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n// sum[i] 是点i所在点双连通分量的个数\n// ans[i] 是点i所在第几个边界的点双连通分量中\nint low[N], dfn[N], stk[N], top, ts, dcc_cnt, root = 1, sum[N], ans[N];\nvector<int> dcc[N], e[N];\nbool cut[N];\nvoid tarjan(int u)\n{\n\tdfn[u] = low[u] = ++ts;\n\tstk[++top] = u;\n\n\tint flag = 0;\n\tfor(auto v : e[u])\n\t{\n\t\tif(!dfn[v])\n\t\t{\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\tif(dfn[u] <= low[v])\n\t\t\t{\n\t\t\t\tflag++;\n\t\t\t\tdcc_cnt++;\n\t\t\t\tif(u != root || flag > 1) cut[u] = 1;\n\t\t\t\tint x;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tx = stk[top--];\n\t\t\t\t\tsum[x]++;\n\t\t\t\t\tdcc[dcc_cnt].push_back(x);\n\t\t\t\t}while(x != v);\n\t\t\t\tdcc[dcc_cnt].push_back(u);\n\t\t\t\tsum[u]++;\n\t\t\t}\n\t\t}\n\t\telse low[u] = min(low[u], dfn[v]);\n\t}\n}\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\ttarjan(1);\n\n\tbool is = 1;\n\tfor(int i = 1; i <= n && is; i++)\n\t\tif(!dfn[i])\n\t\t\tis = 0;\n\n\tif(is && dcc_cnt != 1)\n\t{\n\t\tint id = 0;\n\t\tfor(int i = 1; i <= dcc_cnt; i++)\n\t\t{\n\t\t\tint d = 0; \n\t\t\tfor(auto x : dcc[i])\n\t\t\t\tif(cut[x]) d += sum[x] - 1;\n\n\t\t\tif(d > 2) is = 0; // \n\t\t\telse if(d == 1) // 端点处的点双\n\t\t\t{\n\t\t\t\tid++; // 端点处点双个数加1\n\t\t\t\tfor(auto x : dcc[i])\n\t\t\t\t\tif(!cut[x])\n\t\t\t\t\t\tans[x] = id; // 此点双中非割点赋值\n\t\t\t}\n\t\t}\n\t}\n\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(!is) cout << \"NO\\n\";\n\t\telse if(dcc_cnt == 1) cout << \"YES\\n\";\n\t\telse\n\t\t{\n\t\t\tif(ans[x] + ans[y] == 3) cout << \"YES\\n\";\n\t\t\telse cout << \"NO\\n\";\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# H\n\n> 给出长度为 $n$ 的小写字符串A和 $k$ 个长度为 $m$ 的小写字符串 $B_1…B_k$ ，B的每个位置拥有统一的权值 $v_1…v_m$ ，对于每个 $B_i$ 求最大和区间满足该区间构成的字符串是A的子串（空区间合法）。\n\n可以将问题进行转化，相当于对 $B_i$ 的每个位置求出它作为结束位置在 A 中的最长子串长度，然后在该区间求最大子段和，所有位置的最大值即为答案。\n\n对于每个位置的最长子串，可以对 A 建后缀自动机，然后 $B_i$ 从左往右在A的后缀自动机上转移，如果当前节点无法转移则跳至父亲节点（表示去掉一个前缀字符再次进行匹配），最后无法转移则长度为 0 ，转移成功则为转移前节点的最大长度**加一**。\n\n最大子段和可以通过前缀和与ST表求，B中满足是A的子串的区间为 $[l, r]$ 时， 则最大子段和可以通过 $s[r] - min(s[j]), l \\leq j \\lt r$ 不断进行更新。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct SuffixAutomaton {\n    static constexpr int ALPHABET_SIZE = 26, N = 1e5;\n    struct Node {\n        int len;\n        int link;\n        int next[ALPHABET_SIZE];\n        Node() : len(0), link(0), next{} {}\n    } t[2 * N];\n    int cntNodes;\n    SuffixAutomaton() {\n        cntNodes = 1;\n        std::fill(t[0].next, t[0].next + ALPHABET_SIZE, 1);\n        t[0].len = -1;\n    }\n    void init(string s) {\n        int p = 1;\n        for(auto x : s)\n            p = extend(p, x - 'a');        \n    }\n    int extend(int p, int c) {\n        if (t[p].next[c]) {\n            int q = t[p].next[c];\n            if (t[q].len == t[p].len + 1)\n                return q;\n            int r = ++cntNodes;\n            t[r].len = t[p].len + 1;\n            t[r].link = t[q].link;\n            std::copy(t[q].next, t[q].next + ALPHABET_SIZE, t[r].next);\n            t[q].link = r;\n            while (t[p].next[c] == q) {\n                t[p].next[c] = r;\n                p = t[p].link;\n            }\n            return r;\n        }\n        int cur = ++cntNodes;\n        t[cur].len = t[p].len + 1;\n        while (!t[p].next[c]) {\n            t[p].next[c] = cur;\n            p = t[p].link;\n        }\n        t[cur].link = extend(p, c);\n        return cur;\n    }\n}sam;\n\nll f[N][30], a[N];\nint lg[N];\nvoid init(int n)\n{\n    lg[0] = -1;\n    for(int i = 1; i <= n; i++)\n    {\n        lg[i] = lg[i - 1] + (i & (i - 1) ? 0 : 1);\n        f[i][0] = a[i];\n    }\n    for(int j = 1; j <= lg[n]; j++)\n        for(int i = 0; i + (1 << j) - 1 <= n; i++)\n            f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n}\nll query(int l, int r)\n{\n    int k = lg[r - l + 1];\n    return min(f[l][k], f[r - (1 << k) + 1][k]);\n}\n\nvoid solve()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    string s;\n    cin >> s;\n    sam.init(s);\n\n    for(int i = 1; i <= m; i++)\n    {\n        cin >> a[i];\n        a[i] += a[i - 1];\n    }\n    init(m);\n\n    while(k--)\n    {\n        ll ans = 0;\n        string t;\n        cin >> t;\n        t = \" \" + t;\n        int p = 1, l = 0;\n        for(int i = 1; i <= m; i++)\n        {\n            int c = t[i] - 'a';\n            while(p && !sam.t[p].next[c])\n                p = sam.t[p].link, l = sam.t[p].len;\n            if(p)\n            {\n                p = sam.t[p].next[c], l++;\n                Max(ans, a[i] - query(i - l, i - 1));\n            }\n            else p = 1, l = 0;\n        }\n        cout << ans << \"\\n\";\n    }\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n# J\n\n> 给定一个城市有若干十字路口，右转不需要等红灯，直行、左转和掉头都需要，求起\n>\n> 点到终点最少等几次红灯\n\n把每条路看做点，十字路口处连边，形成一个边权为0/1的有向图。\n\n可以使用`dijkstra`求最短路。\n\n同时也可以用`01BFS`解决，此时使用deque维护队列，边权为0时入队头，边权为1时入队尾。\n\n无论一个路口四个方向怎么给，因为都是按照逆时针方向给出的，所以所有路的相对关系都可以得到，每走到一个路口，都会知道当前路口的四个方向的情况。\n\n$dis[i][j]$ 代表从起点的路到达终点路的最小等待数，因为点数过多，将第二维压缩，压缩成四个方向，即到达（ $i$，$i$ 路口的第 $j$ 个方向指向的路口）这条路上。\n\n队列中存的是路的起始和结束位置，以及到达该路上的最小等待红灯数。\n\n> 对于01BFS的理解，我们首先扩展的是距离等于0的位置（这样肯定是最优的，没有距离嘛），所以就是先走当前的最短路，然后再扩展有距离的路，也是一层一层的扩展。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 5e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint dis[N][4], to[N][4];\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j < 4; j++)\n\t\t\tcin >> to[i][j];\n\n\tint sx, sy, fx, fy;\n\tcin >> sx >> sy >> fx >> fy;\n\n\tmemset(dis, 0x3f, sizeof dis);\n\n\tdeque<array<int, 3>> dq;\n\tdq.push_front({sx, sy, 0});\n\twhile(!dq.empty())\n\t{\n\t\tauto t = dq.front();\n\t\tdq.pop_front();\n\n\t\tint x = t[0], y = t[1], w = t[2];\n\n\t\tif(!y) continue;\n\t\tint id = -1;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tif(to[x][i] == y)\n\t\t\t\tid = i;\n\t\t}\n\t\tif(dis[x][id] > w)\n\t\t\tdis[x][id] = w;\n\t\telse continue;\n\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tif(to[y][i] == x)\n\t\t\t\tid = (i + 1) % 4;\n\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tif(i == id)\n\t\t\t\tdq.push_front({y, to[y][i], w});\n\t\t\telse dq.push_back({y, to[y][i], w + 1});\n\t\t}\n\t}\n\n\tint id = -1;\n\tfor(int i = 0; i < 4; i++)\n\t\tif(to[fx][i] == fy)\n\t\t\tid = i;\n\tif(dis[fx][id] == 0x3f3f3f3f) cout << \"-1\\n\";\n\telse cout << dis[fx][id] << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n","slug":"2022牛客多校补题3","published":1,"updated":"2022-09-07T14:31:34.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolh0000n6kuhcaerbdt4","content":"<h1 id=\"2022牛客多校3补题\"><a href=\"#2022牛客多校3补题\" class=\"headerlink\" title=\"2022牛客多校3补题\"></a><a href=\"https://ac.nowcoder.com/acm/contest/33188\" target=\"_blank\" rel=\"noopener\">2022牛客多校3补题</a></h1><h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><blockquote>\n<p>给出两棵编号 $1-n$ 的树A和B，A和B树上每个节点均有一个权值，给出 $k$ 个关键点</p>\n<p>的编号 $x_1…x_n$ ，问有多少种方案使得去掉恰好一个关键点使得剩余关键点在树A上</p>\n<p>LCA的权值大于树B上LCA的权值</p>\n</blockquote>\n<p>观察和不断模拟可以发现一系列的点的LCA可以通过前缀LCA实现。</p>\n<p>故预处理出关键点序列的在树A B上的前缀LCA和后缀LCA，枚举去掉的关键节点并使用前后缀LCA算出剩余节点的LCA比较权值即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ull <span class=\"token operator\">=</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> Tree <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> sz<span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">,</span> dep<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">,</span> in<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cur<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Tree</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">sz</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">top</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">dep</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">parent</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">e</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">in</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">cur</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">addEdge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        e<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dfsSz</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfsHLD</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">dfsSz</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sz<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>v <span class=\"token operator\">:</span> e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> u<span class=\"token punctuation\">;</span>\n            dep<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfsSz</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            sz<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sz<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> sz<span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                std<span class=\"token operator\">::</span><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">dfsHLD</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        in<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cur<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v <span class=\"token operator\">:</span> e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">==</span> e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                top<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> top<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                top<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">dfsHLD</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">lca</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                u <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                v <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dep<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> u<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> k<span class=\"token punctuation\">;</span>\n    vi <span class=\"token function\">x</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    Tree <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">B</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vi <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> p<span class=\"token punctuation\">;</span>\n        p<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        A<span class=\"token punctuation\">.</span><span class=\"token function\">addEdge</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    vi <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> b<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> p<span class=\"token punctuation\">;</span>\n        p<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        B<span class=\"token punctuation\">.</span><span class=\"token function\">addEdge</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    A<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    B<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    vi <span class=\"token function\">prea</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">sufa</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">preb</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">sufb</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            prea<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> preb<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            prea<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">.</span><span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>prea<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            preb<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> B<span class=\"token punctuation\">.</span><span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>preb<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            sufa<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sufb<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            sufa<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">.</span><span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>sufa<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            sufb<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> B<span class=\"token punctuation\">.</span><span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>sufb<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>sufa<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> b<span class=\"token punctuation\">[</span>sufb<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                ans<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>prea<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> b<span class=\"token punctuation\">[</span>preb<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                ans<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> va <span class=\"token operator\">=</span> A<span class=\"token punctuation\">.</span><span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>prea<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sufa<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> vb <span class=\"token operator\">=</span> B<span class=\"token punctuation\">.</span><span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>preb<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sufb<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>va<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> b<span class=\"token punctuation\">[</span>vb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                ans<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><blockquote>\n<p>题意： 给定n个字符串，求一个将他们拼接起来的方案，使得结果的字典序最小。</p>\n</blockquote>\n<p>对$n$个字符串排序， $a$ 在 $b$ 前面的条件是 $a + b &lt; b + a$ </p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">s</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>string a<span class=\"token punctuation\">,</span> string b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">+</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><blockquote>\n<p>给定一个n个点m条边的无向图，每次询问两点x, y，求是否存在一个n的排列，使得第一个元素为x，最后一个元素为y，且排列的任意一个前缀、任意一个后</p>\n<p>缀都连通</p>\n</blockquote>\n<p>考虑一条链，那么两端的顶点是满足情况的，如果是其他的两个点那么不满足情况。</p>\n<p>考虑一个环，发现环中的任意两个点都满足情况。</p>\n<p>考虑一个图，图中可能存在环。</p>\n<p>那么对所有的点双缩点之后，必须是一条链，如果不是一条链就不能满足。首先通过tarjan求出割点以及点双。</p>\n<p>如果图本身就不连通（即有多个连通块），不满足。</p>\n<p>如果点双等于1，即是一个环，满足。</p>\n<p>接下来是对于一般的连通图，我们对于边界处的点双进行赋值，第一个边界处点双非割点全部赋为1，第二个边界处点双中非割点全部赋为2，那么询问时，如果两个点的值加和是3，即可以满足要求。</p>\n<p>主要是如何判断是否是处于边界的点双，边界处的点双，那么此点双中的割点所在点双只有2个，不能有多个，如果有多个，必然不是在边界（因为存在一个割点至少则会存在两个点双）。</p>\n<p>代码中为什么没有 $d = 2$</p>\n<p>因为存在以下情况：</p>\n<p><img src=\"3182360886/image-20220907221918311.png\" alt=\"满足的情况\"></p>\n<p>上图是满足情况的，中间的点双连通分量的 $d = 2$ ，但是边界1和6点都已经确定了，可以通过边界确定是否满足情况。</p>\n<p><img src=\"3182360886/image-20220907222225218.png\" alt=\"不满足的情况\"></p>\n<p>上图是不满足情况的，中间的点双中 $d = 2$，但是边界也可以确定，同样可以通过边界来判断是否满足情况。</p>\n<p>那么其他情况也是如此，都是可以通过边界点双连通分量来判断， $d = 2$ 因为牵扯到有满足情况和不满足情况的，暂不考虑（但是他们可以通过边界点双来判断）</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ull <span class=\"token operator\">=</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// sum[i] 是点i所在点双连通分量的个数</span>\n<span class=\"token comment\" spellcheck=\"true\">// ans[i] 是点i所在第几个边界的点双连通分量中</span>\n<span class=\"token keyword\">int</span> low<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dfn<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> stk<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">,</span> ts<span class=\"token punctuation\">,</span> dcc_cnt<span class=\"token punctuation\">,</span> root <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ans<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> dcc<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> cut<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">tarjan</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    dfn<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> low<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>ts<span class=\"token punctuation\">;</span>\n    stk<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>top<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> u<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>dfn<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">tarjan</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            low<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dfn<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> low<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                flag<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                dcc_cnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">!=</span> root <span class=\"token operator\">||</span> flag <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> cut<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">do</span>\n                <span class=\"token punctuation\">{</span>\n                    x <span class=\"token operator\">=</span> stk<span class=\"token punctuation\">[</span>top<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    sum<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    dcc<span class=\"token punctuation\">[</span>dcc_cnt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">!=</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                dcc<span class=\"token punctuation\">[</span>dcc_cnt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                sum<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> low<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dfn<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        e<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        e<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">tarjan</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">bool</span> is <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">&amp;&amp;</span> is<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>dfn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            is <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>is <span class=\"token operator\">&amp;&amp;</span> dcc_cnt <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> id <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> dcc_cnt<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x <span class=\"token operator\">:</span> dcc<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cut<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> d <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sum<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">></span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> is <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// </span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>d <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 端点处的点双</span>\n            <span class=\"token punctuation\">{</span>\n                id<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 端点处点双个数加1</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x <span class=\"token operator\">:</span> dcc<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cut<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                        ans<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 此点双中非割点赋值</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> x <span class=\"token operator\">>></span> y<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>is<span class=\"token punctuation\">)</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"NO\\n\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dcc_cnt <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"YES\\n\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> ans<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"YES\\n\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"NO\\n\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h1><blockquote>\n<p>给出长度为 $n$ 的小写字符串A和 $k$ 个长度为 $m$ 的小写字符串 $B_1…B_k$ ，B的每个位置拥有统一的权值 $v_1…v_m$ ，对于每个 $B_i$ 求最大和区间满足该区间构成的字符串是A的子串（空区间合法）。</p>\n</blockquote>\n<p>可以将问题进行转化，相当于对 $B_i$ 的每个位置求出它作为结束位置在 A 中的最长子串长度，然后在该区间求最大子段和，所有位置的最大值即为答案。</p>\n<p>对于每个位置的最长子串，可以对 A 建后缀自动机，然后 $B_i$ 从左往右在A的后缀自动机上转移，如果当前节点无法转移则跳至父亲节点（表示去掉一个前缀字符再次进行匹配），最后无法转移则长度为 0 ，转移成功则为转移前节点的最大长度<strong>加一</strong>。</p>\n<p>最大子段和可以通过前缀和与ST表求，B中满足是A的子串的区间为 $[l, r]$ 时， 则最大子段和可以通过 $s[r] - min(s[j]), l \\leq j \\lt r$ 不断进行更新。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ull <span class=\"token operator\">=</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> SuffixAutomaton <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">constexpr</span> <span class=\"token keyword\">int</span> ALPHABET_SIZE <span class=\"token operator\">=</span> <span class=\"token number\">26</span><span class=\"token punctuation\">,</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> Node <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> link<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> next<span class=\"token punctuation\">[</span>ALPHABET_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">link</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> t<span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cntNodes<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">SuffixAutomaton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cntNodes <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token operator\">::</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">+</span> ALPHABET_SIZE<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        t<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x <span class=\"token operator\">:</span> s<span class=\"token punctuation\">)</span>\n            p <span class=\"token operator\">=</span> <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> x <span class=\"token operator\">-</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> q <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">==</span> t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> q<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>cntNodes<span class=\"token punctuation\">;</span>\n            t<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            t<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link<span class=\"token punctuation\">;</span>\n            std<span class=\"token operator\">::</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">+</span> ALPHABET_SIZE<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            t<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link <span class=\"token operator\">=</span> r<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r<span class=\"token punctuation\">;</span>\n                p <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> cur <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>cntNodes<span class=\"token punctuation\">;</span>\n        t<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">;</span>\n            p <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        t<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link <span class=\"token operator\">=</span> <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> cur<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>sam<span class=\"token punctuation\">;</span>\n\nll f<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">30</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> lg<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    lg<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        lg<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> lg<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> lg<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nll <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> lg<span class=\"token punctuation\">[</span>r <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>r <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> k<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m <span class=\"token operator\">>></span> k<span class=\"token punctuation\">;</span>\n\n    string s<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">;</span>\n    sam<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">init</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>k<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        string t<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">;</span>\n        t <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> t<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>sam<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                p <span class=\"token operator\">=</span> sam<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>link<span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> sam<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>len<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                p <span class=\"token operator\">=</span> sam<span class=\"token punctuation\">.</span>t<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> l<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> l<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> p <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h1><blockquote>\n<p>给定一个城市有若干十字路口，右转不需要等红灯，直行、左转和掉头都需要，求起</p>\n<p>点到终点最少等几次红灯</p>\n</blockquote>\n<p>把每条路看做点，十字路口处连边，形成一个边权为0/1的有向图。</p>\n<p>可以使用<code>dijkstra</code>求最短路。</p>\n<p>同时也可以用<code>01BFS</code>解决，此时使用deque维护队列，边权为0时入队头，边权为1时入队尾。</p>\n<p>无论一个路口四个方向怎么给，因为都是按照逆时针方向给出的，所以所有路的相对关系都可以得到，每走到一个路口，都会知道当前路口的四个方向的情况。</p>\n<p>$dis[i][j]$ 代表从起点的路到达终点路的最小等待数，因为点数过多，将第二维压缩，压缩成四个方向，即到达（ $i$，$i$ 路口的第 $j$ 个方向指向的路口）这条路上。</p>\n<p>队列中存的是路的起始和结束位置，以及到达该路上的最小等待红灯数。</p>\n<blockquote>\n<p>对于01BFS的理解，我们首先扩展的是距离等于0的位置（这样肯定是最优的，没有距离嘛），所以就是先走当前的最短路，然后再扩展有距离的路，也是一层一层的扩展。</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ull <span class=\"token operator\">=</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">5e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> dis<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            cin <span class=\"token operator\">>></span> to<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> sx<span class=\"token punctuation\">,</span> sy<span class=\"token punctuation\">,</span> fx<span class=\"token punctuation\">,</span> fy<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> sx <span class=\"token operator\">>></span> sy <span class=\"token operator\">>></span> fx <span class=\"token operator\">>></span> fy<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>dis<span class=\"token punctuation\">,</span> <span class=\"token number\">0x3f</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span> dis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    deque<span class=\"token operator\">&lt;</span>array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">>></span> dq<span class=\"token punctuation\">;</span>\n    dq<span class=\"token punctuation\">.</span><span class=\"token function\">push_front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>sx<span class=\"token punctuation\">,</span> sy<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>dq<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">auto</span> t <span class=\"token operator\">=</span> dq<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dq<span class=\"token punctuation\">.</span><span class=\"token function\">pop_front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> w <span class=\"token operator\">=</span> t<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> id <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span>\n                id <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dis<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> w<span class=\"token punctuation\">)</span>\n            dis<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n                id <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> id<span class=\"token punctuation\">)</span>\n                dq<span class=\"token punctuation\">.</span><span class=\"token function\">push_front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>y<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> dq<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>y<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> w <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> id <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">[</span>fx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> fy<span class=\"token punctuation\">)</span>\n            id <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dis<span class=\"token punctuation\">[</span>fx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0x3f3f3f3f</span><span class=\"token punctuation\">)</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"-1\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> cout <span class=\"token operator\">&lt;&lt;</span> dis<span class=\"token punctuation\">[</span>fx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"2022牛客多校3补题\"><a href=\"#2022牛客多校3补题\" class=\"headerlink\" title=\"2022牛客多校3补题\"></a><a href=\"https://ac.nowcoder.com/acm/contest/33188\" target=\"_blank\" rel=\"noopener\">2022牛客多校3补题</a></h1><h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><blockquote>\n<p>给出两棵编号 $1-n$ 的树A和B，A和B树上每个节点均有一个权值，给出 $k$ 个关键点</p>\n<p>的编号 $x_1…x_n$ ，问有多少种方案使得去掉恰好一个关键点使得剩余关键点在树A上</p>\n<p>LCA的权值大于树B上LCA的权值</p>\n</blockquote>\n<p>观察和不断模拟可以发现一系列的点的LCA可以通过前缀LCA实现。</p>\n<p>故预处理出关键点序列的在树A B上的前缀LCA和后缀LCA，枚举去掉的关键节点并使用前后缀LCA算出剩余节点的LCA比较权值即可。</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct Tree {\n    std::vector&lt;int&gt; sz, top, dep, parent, in;\n    int cur;\n    std::vector&lt;std::vector&lt;int&gt;&gt; e;\n    Tree(int n) : sz(n), top(n), dep(n), parent(n, -1), e(n), in(n), cur(0) {}\n    void addEdge(int u, int v) {\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    void init() {\n        dfsSz(0);\n        dfsHLD(0);\n    }\n    void dfsSz(int u) {\n        if (parent[u] != -1)\n            e[u].erase(std::find(e[u].begin(), e[u].end(), parent[u]));\n        sz[u] = 1;\n        for (int &amp;v : e[u]) {\n            parent[v] = u;\n            dep[v] = dep[u] + 1;\n            dfsSz(v);\n            sz[u] += sz[v];\n            if (sz[v] &gt; sz[e[u][0]])\n                std::swap(v, e[u][0]);\n        }\n    }\n    void dfsHLD(int u) {\n        in[u] = cur++;\n        for (int v : e[u]) {\n            if (v == e[u][0]) {\n                top[v] = top[u];\n            } else {\n                top[v] = v;\n            }\n            dfsHLD(v);\n        }\n    }\n    int lca(int u, int v) {\n        while (top[u] != top[v]) {\n            if (dep[top[u]] &gt; dep[top[v]]) {\n                u = parent[top[u]];\n            } else {\n                v = parent[top[v]];\n            }\n        }\n        if (dep[u] &lt; dep[v]) {\n            return u;\n        } else {\n            return v;\n        }\n    }\n};\nvoid solve()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vi x(k);\n    for(int i = 0; i &lt; k; i++)\n    {\n        cin &gt;&gt; x[i];\n        x[i]--;\n    }\n\n    Tree A(n), B(n);\n    vi a(n);\n    for(int i = 0; i &lt; n; i++)\n        cin &gt;&gt; a[i];\n    for(int i = 1; i &lt; n; i++)\n    {\n        int p;\n        cin &gt;&gt; p;\n        p--;\n        A.addEdge(i, p);\n    }\n    vi b(n);\n    for(int i = 0; i &lt; n; i++)\n        cin &gt;&gt; b[i];\n    for(int i = 1; i &lt; n; i++)\n    {\n        int p;\n        cin &gt;&gt; p;\n        p--;\n        B.addEdge(i, p);\n    }\n    A.init();\n    B.init();\n\n    vi prea(k), sufa(k), preb(k), sufb(k);\n    for(int i = 0; i &lt; k; i++)\n    {\n        if(i == 0)\n            prea[i] = preb[i] = x[i];\n        else\n        {\n            prea[i] = A.lca(prea[i - 1], x[i]);\n            preb[i] = B.lca(preb[i - 1], x[i]);\n        }\n    }\n    for(int i = k - 1; i &gt;= 0; i--)\n    {\n        if(i == k - 1)\n            sufa[i] = sufb[i] = x[i];\n        else\n        {\n            sufa[i] = A.lca(sufa[i + 1], x[i]);\n            sufb[i] = B.lca(sufb[i + 1], x[i]);\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i &lt; k; i++)\n    {\n        if(i == 0)\n        {\n            if(a[sufa[i + 1]] &gt; b[sufb[i + 1]])\n                ans++;\n        }\n        else if(i == k - 1)\n        {\n            if(a[prea[i - 1]] &gt; b[preb[i -  1]])\n                ans++;\n        }\n        else\n        {\n            int va = A.lca(prea[i - 1], sufa[i + 1]);\n            int vb = B.lca(preb[i - 1], sufb[i + 1]);\n            if(a[va] &gt; b[vb])\n                ans++;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><blockquote>\n<p>题意： 给定n个字符串，求一个将他们拼接起来的方案，使得结果的字典序最小。</p>\n</blockquote>\n<p>对$n$个字符串排序， $a$ 在 $b$ 前面的条件是 $a + b &lt; b + a$ </p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;string&gt; s(n + 1);\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; s[i];\n    sort(s.begin() + 1, s.end(), [](string a, string b){\n        return a + b &lt; b + a;\n    });\n    for(int i = 1; i &lt;= n; i++)\n        cout &lt;&lt; s[i];\n    cout &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    // cin &gt;&gt; t;\n    t = 1;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><blockquote>\n<p>给定一个n个点m条边的无向图，每次询问两点x, y，求是否存在一个n的排列，使得第一个元素为x，最后一个元素为y，且排列的任意一个前缀、任意一个后</p>\n<p>缀都连通</p>\n</blockquote>\n<p>考虑一条链，那么两端的顶点是满足情况的，如果是其他的两个点那么不满足情况。</p>\n<p>考虑一个环，发现环中的任意两个点都满足情况。</p>\n<p>考虑一个图，图中可能存在环。</p>\n<p>那么对所有的点双缩点之后，必须是一条链，如果不是一条链就不能满足。首先通过tarjan求出割点以及点双。</p>\n<p>如果图本身就不连通（即有多个连通块），不满足。</p>\n<p>如果点双等于1，即是一个环，满足。</p>\n<p>接下来是对于一般的连通图，我们对于边界处的点双进行赋值，第一个边界处点双非割点全部赋为1，第二个边界处点双中非割点全部赋为2，那么询问时，如果两个点的值加和是3，即可以满足要求。</p>\n<p>主要是如何判断是否是处于边界的点双，边界处的点双，那么此点双中的割点所在点双只有2个，不能有多个，如果有多个，必然不是在边界（因为存在一个割点至少则会存在两个点双）。</p>\n<p>代码中为什么没有 $d = 2$</p>\n<p>因为存在以下情况：</p>\n<p><img src=\"3182360886/image-20220907221918311.png\" alt=\"满足的情况\"></p>\n<p>上图是满足情况的，中间的点双连通分量的 $d = 2$ ，但是边界1和6点都已经确定了，可以通过边界确定是否满足情况。</p>\n<p><img src=\"3182360886/image-20220907222225218.png\" alt=\"不满足的情况\"></p>\n<p>上图是不满足情况的，中间的点双中 $d = 2$，但是边界也可以确定，同样可以通过边界来判断是否满足情况。</p>\n<p>那么其他情况也是如此，都是可以通过边界点双连通分量来判断， $d = 2$ 因为牵扯到有满足情况和不满足情况的，暂不考虑（但是他们可以通过边界点双来判断）</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n// sum[i] 是点i所在点双连通分量的个数\n// ans[i] 是点i所在第几个边界的点双连通分量中\nint low[N], dfn[N], stk[N], top, ts, dcc_cnt, root = 1, sum[N], ans[N];\nvector&lt;int&gt; dcc[N], e[N];\nbool cut[N];\nvoid tarjan(int u)\n{\n    dfn[u] = low[u] = ++ts;\n    stk[++top] = u;\n\n    int flag = 0;\n    for(auto v : e[u])\n    {\n        if(!dfn[v])\n        {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n            if(dfn[u] &lt;= low[v])\n            {\n                flag++;\n                dcc_cnt++;\n                if(u != root || flag &gt; 1) cut[u] = 1;\n                int x;\n                do\n                {\n                    x = stk[top--];\n                    sum[x]++;\n                    dcc[dcc_cnt].push_back(x);\n                }while(x != v);\n                dcc[dcc_cnt].push_back(u);\n                sum[u]++;\n            }\n        }\n        else low[u] = min(low[u], dfn[v]);\n    }\n}\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= m; i++)\n    {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    tarjan(1);\n\n    bool is = 1;\n    for(int i = 1; i &lt;= n &amp;&amp; is; i++)\n        if(!dfn[i])\n            is = 0;\n\n    if(is &amp;&amp; dcc_cnt != 1)\n    {\n        int id = 0;\n        for(int i = 1; i &lt;= dcc_cnt; i++)\n        {\n            int d = 0; \n            for(auto x : dcc[i])\n                if(cut[x]) d += sum[x] - 1;\n\n            if(d &gt; 2) is = 0; // \n            else if(d == 1) // 端点处的点双\n            {\n                id++; // 端点处点双个数加1\n                for(auto x : dcc[i])\n                    if(!cut[x])\n                        ans[x] = id; // 此点双中非割点赋值\n            }\n        }\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while(q--)\n    {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        if(!is) cout &lt;&lt; &quot;NO\\n&quot;;\n        else if(dcc_cnt == 1) cout &lt;&lt; &quot;YES\\n&quot;;\n        else\n        {\n            if(ans[x] + ans[y] == 3) cout &lt;&lt; &quot;YES\\n&quot;;\n            else cout &lt;&lt; &quot;NO\\n&quot;;\n        }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h1><blockquote>\n<p>给出长度为 $n$ 的小写字符串A和 $k$ 个长度为 $m$ 的小写字符串 $B_1…B_k$ ，B的每个位置拥有统一的权值 $v_1…v_m$ ，对于每个 $B_i$ 求最大和区间满足该区间构成的字符串是A的子串（空区间合法）。</p>\n</blockquote>\n<p>可以将问题进行转化，相当于对 $B_i$ 的每个位置求出它作为结束位置在 A 中的最长子串长度，然后在该区间求最大子段和，所有位置的最大值即为答案。</p>\n<p>对于每个位置的最长子串，可以对 A 建后缀自动机，然后 $B_i$ 从左往右在A的后缀自动机上转移，如果当前节点无法转移则跳至父亲节点（表示去掉一个前缀字符再次进行匹配），最后无法转移则长度为 0 ，转移成功则为转移前节点的最大长度<strong>加一</strong>。</p>\n<p>最大子段和可以通过前缀和与ST表求，B中满足是A的子串的区间为 $[l, r]$ 时， 则最大子段和可以通过 $s[r] - min(s[j]), l \\leq j \\lt r$ 不断进行更新。</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct SuffixAutomaton {\n    static constexpr int ALPHABET_SIZE = 26, N = 1e5;\n    struct Node {\n        int len;\n        int link;\n        int next[ALPHABET_SIZE];\n        Node() : len(0), link(0), next{} {}\n    } t[2 * N];\n    int cntNodes;\n    SuffixAutomaton() {\n        cntNodes = 1;\n        std::fill(t[0].next, t[0].next + ALPHABET_SIZE, 1);\n        t[0].len = -1;\n    }\n    void init(string s) {\n        int p = 1;\n        for(auto x : s)\n            p = extend(p, x - &#39;a&#39;);        \n    }\n    int extend(int p, int c) {\n        if (t[p].next[c]) {\n            int q = t[p].next[c];\n            if (t[q].len == t[p].len + 1)\n                return q;\n            int r = ++cntNodes;\n            t[r].len = t[p].len + 1;\n            t[r].link = t[q].link;\n            std::copy(t[q].next, t[q].next + ALPHABET_SIZE, t[r].next);\n            t[q].link = r;\n            while (t[p].next[c] == q) {\n                t[p].next[c] = r;\n                p = t[p].link;\n            }\n            return r;\n        }\n        int cur = ++cntNodes;\n        t[cur].len = t[p].len + 1;\n        while (!t[p].next[c]) {\n            t[p].next[c] = cur;\n            p = t[p].link;\n        }\n        t[cur].link = extend(p, c);\n        return cur;\n    }\n}sam;\n\nll f[N][30], a[N];\nint lg[N];\nvoid init(int n)\n{\n    lg[0] = -1;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        lg[i] = lg[i - 1] + (i &amp; (i - 1) ? 0 : 1);\n        f[i][0] = a[i];\n    }\n    for(int j = 1; j &lt;= lg[n]; j++)\n        for(int i = 0; i + (1 &lt;&lt; j) - 1 &lt;= n; i++)\n            f[i][j] = min(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);\n}\nll query(int l, int r)\n{\n    int k = lg[r - l + 1];\n    return min(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);\n}\n\nvoid solve()\n{\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\n    string s;\n    cin &gt;&gt; s;\n    sam.init(s);\n\n    for(int i = 1; i &lt;= m; i++)\n    {\n        cin &gt;&gt; a[i];\n        a[i] += a[i - 1];\n    }\n    init(m);\n\n    while(k--)\n    {\n        ll ans = 0;\n        string t;\n        cin &gt;&gt; t;\n        t = &quot; &quot; + t;\n        int p = 1, l = 0;\n        for(int i = 1; i &lt;= m; i++)\n        {\n            int c = t[i] - &#39;a&#39;;\n            while(p &amp;&amp; !sam.t[p].next[c])\n                p = sam.t[p].link, l = sam.t[p].len;\n            if(p)\n            {\n                p = sam.t[p].next[c], l++;\n                Max(ans, a[i] - query(i - l, i - 1));\n            }\n            else p = 1, l = 0;\n        }\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    }\n\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h1><blockquote>\n<p>给定一个城市有若干十字路口，右转不需要等红灯，直行、左转和掉头都需要，求起</p>\n<p>点到终点最少等几次红灯</p>\n</blockquote>\n<p>把每条路看做点，十字路口处连边，形成一个边权为0/1的有向图。</p>\n<p>可以使用<code>dijkstra</code>求最短路。</p>\n<p>同时也可以用<code>01BFS</code>解决，此时使用deque维护队列，边权为0时入队头，边权为1时入队尾。</p>\n<p>无论一个路口四个方向怎么给，因为都是按照逆时针方向给出的，所以所有路的相对关系都可以得到，每走到一个路口，都会知道当前路口的四个方向的情况。</p>\n<p>$dis[i][j]$ 代表从起点的路到达终点路的最小等待数，因为点数过多，将第二维压缩，压缩成四个方向，即到达（ $i$，$i$ 路口的第 $j$ 个方向指向的路口）这条路上。</p>\n<p>队列中存的是路的起始和结束位置，以及到达该路上的最小等待红灯数。</p>\n<blockquote>\n<p>对于01BFS的理解，我们首先扩展的是距离等于0的位置（这样肯定是最优的，没有距离嘛），所以就是先走当前的最短路，然后再扩展有距离的路，也是一层一层的扩展。</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 5e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nint dis[N][4], to[N][4];\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++)\n        for(int j = 0; j &lt; 4; j++)\n            cin &gt;&gt; to[i][j];\n\n    int sx, sy, fx, fy;\n    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;\n\n    memset(dis, 0x3f, sizeof dis);\n\n    deque&lt;array&lt;int, 3&gt;&gt; dq;\n    dq.push_front({sx, sy, 0});\n    while(!dq.empty())\n    {\n        auto t = dq.front();\n        dq.pop_front();\n\n        int x = t[0], y = t[1], w = t[2];\n\n        if(!y) continue;\n        int id = -1;\n        for(int i = 0; i &lt; 4; i++)\n        {\n            if(to[x][i] == y)\n                id = i;\n        }\n        if(dis[x][id] &gt; w)\n            dis[x][id] = w;\n        else continue;\n\n        for(int i = 0; i &lt; 4; i++)\n            if(to[y][i] == x)\n                id = (i + 1) % 4;\n\n        for(int i = 0; i &lt; 4; i++)\n        {\n            if(i == id)\n                dq.push_front({y, to[y][i], w});\n            else dq.push_back({y, to[y][i], w + 1});\n        }\n    }\n\n    int id = -1;\n    for(int i = 0; i &lt; 4; i++)\n        if(to[fx][i] == fy)\n            id = i;\n    if(dis[fx][id] == 0x3f3f3f3f) cout &lt;&lt; &quot;-1\\n&quot;;\n    else cout &lt;&lt; dis[fx][id] &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n"},{"title":"AtCoder Beginner Contest 266 A-G","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":2022907814,"date":"2022-08-30T01:07:31.000Z","password":null,"summary":null,"_content":"\n# AtCoder Beginner Contest 266 A-G\n\n# A \n\n直接输出字符串中间字符即可。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tstring s;\n\tcin >> s;\n\tcout << s[s.size() / 2];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# B\n\n令 $m = 998244353$ 。\n$$\nN - x = k \\times m, k \\in Z\n$$\n\n$$\nx = N - k \\times m, 0 \\leq x \\leq m - 1\n$$\n\n$$\nx = (N \\bmod m + m) \\bmod m\n$$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 998244353;\nconst ld eps = 1e-8;\n// x = n - k mod\nvoid solve()\n{\n\tll n;\n\tcin >> n;\n\tcout << (n % mod + mod) % mod << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# C\n\n直接暴力判断叉积是否小于等于0即可。\n\n> 叉积计算的是三角形面积，当在右手系的情况下， 叉积计算出来的值就是三角形的正面积，如果计算出的值为负值，即三角形不存在。\n>\n> $A,B,C$ 三个点，$\\frac {\\overrightarrow {AB} \\times \\overrightarrow {AC}}{2}$ 即为对应的三角形面积， 只需判断上面分母的叉积是否小于等于 0 即可。两个向量分别为 $(x1, y1),(x2, y2)$ ，则 $S_{\\triangle ABC} = x1 \\cdot y2  - x2 \\cdot y1$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n\nvoid solve()\n{\n\tvector<pii> p(10);\n\tfor(int i = 0; i < 4; i++)\n\t\tcin >> p[i].first >> p[i].second;\n\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tpii a = {p[(i + 1) % 4].first - p[i].first, p[(i + 1) % 4].second - p[i].second};\n\t\tpii b = {p[(i - 1 + 4) % 4].first - p[i].first, p[(i - 1 + 4) % 4].second - p[i].second};\n\t\tif(a.first * b.second - b.first * a.second <= 0)\n\t\t{\n\t\t\tcout << \"No\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"Yes\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# D\n\n$f[i]$ 代表前 $i$ 个蛇， 抓了第 $i$ 个，得到的最大价值。\n\n可以发现，当抓了第 $i$ 个蛇后， 那么位置必须处于 $p[i]$ 处，那么首先可以暴力的想怎么转移， 就是我们可以两层循环， 对于每一个 $f[i]$ ，我们找前面的可以进行转移（即在时间限制内可以到达 $f[j]$ ）的位置 $j,j \\lt i$ ，每一个位置进行判断。 复杂度 $O(n^2)$\n\n但是本题有一个特点，位置数极少，只有5个，那么 $i$ 位置往前5个之后一定是可以转移的位置（在时间限制内一定可以到达 $i$）。 所以我们暴力判断 $i$ 位置的前几个，然后对此进行转移即可。\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvi t(n + 1), p(n + 1), w(n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> t[i] >> p[i] >> w[i];\n\n\tvl f(n + 1, -2e18);\n\tf[0] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = max(0, i - 10); j < i; j++)\n\t\t{\n\t\t\tif(t[i] - t[j] >= abs(p[i] - p[j]))\n\t\t\t\tMax(f[i], f[j] + w[i]);\n\t\t}\n\t}\n\tll ans = *max_element(f.begin() + 1, f.end());\n\tif(ans <= 0) cout << 0 << \"\\n\";\n\telse cout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# E\n\n$$\nf[x] = \\frac{1}{6}max(1, f[x - 1]) + \\frac{1}{6}max(2, f[x - 1]) \\\\ + \\frac{1}{6}max(3, f[x - 1]) + \\frac{1}{6}max(4, f[x - 1]) \\\\ + \\frac{1}{6}max(5, f[x - 1]) + \\frac{1}{6}max(6, f[x - 1])\n$$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tdb ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tdb t = 0;\n\t\tfor(int j = 1; j <= 6; j++)\n\t\t\tt += max(ans, (db)j) / 6;\n\t\tans = t;\n\t}\n\tcout << fixed << setprecision(10) << ans << \"\\n\";\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# F\n\n> 一颗基环树， q个询问， 问两点之间是否存在单一路径。\n\n我们首先需要找到这个环，标记一下环上的点，那么以环为树根，单颗子树上的节点（除环上的点）都有单一路径，我们使用并查集将他们连成一个集合即可。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct DSU\n{\n\tvector<int> f, sz;\n\tDSU(int n): f(n), sz(n, 1) { iota(f.begin(), f.end(), 0); }\n\tint find(int x)\n\t{\n\t\tif(x == f[x]) return x;\n\t\treturn f[x] = find(f[x]);\n\t}\n    bool same(int x, int y) { return find(x) == find(y); }\n\tvoid merge(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(sz[x] < sz[y]) swap(x, y);\n\t\tf[y] = x;\n\t\tsz[x] += sz[y];\n\t\tsz[y] = 0;\n\t}\n};\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvector<vi> g(n);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tvector<bool> cyc(n);\n\tvi fa(n, -1), vis(n, -1);\n\tint cur = 0;\n\n\tfunction<void(int)> dfs = [&](int u)\n\t{\n\t\tvis[u] = cur++;\n\t\tfor(auto v : g[u])\n\t\t{\n\t\t\tif(v == fa[u]) continue;\n\t\t\tif(vis[v] == -1)\n\t\t\t{\n\t\t\t\tfa[v] = u;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t\telse if(vis[v] < vis[u])\n\t\t\t{\n\t\t\t\tfor(int i = u; i != v; i = fa[i])\n\t\t\t\t\tcyc[i] = 1;\n\t\t\t\tcyc[v] = 1;\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0);\n\n\tDSU dsu(n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(auto j : g[i])\n\t\t\tif(!cyc[i] || !cyc[j])\n\t\t\t\tdsu.merge(i, j);\n\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tcout << (dsu.same(u, v) ? \"Yes\\n\" : \"No\\n\");\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# G\n\n> 问有`R` 个字符 `R`，`G` 个字符 `G`，`B` 个字符 `B`，`K` 个字符 `RG`的字符串的个数。\n\n排列组合知识。\n\n首先安排G和B，共$C_{G+B}^{B}$ 种。\n\n然后安排K个R，只能在G的前面填，共`G`个位置，凑成`RG`，共 $C_G^K$ 种。\n\n剩下了 $R-K$ 个`R` ，需要填进去同时保证`RG`的数量不会增加，那么只能在`B` 和 `RG` 的前面以及最后一个位置填，共 $B+K+1$ 个位置。\n\n即 $B+K+1$ 个位置填 $R-K$ 个`R` 。我们使用隔板法， 即等价于将 $B+K+1 + R-K$ 个`R`分成 $B+K+1$ 份， 答案为 $C_{B+R}^{B+K}$ 种。\n\n> 以下为隔板法描述：\n\n**一般隔板法：**\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 1$ 的可行解个数。\n\n**添元素隔板法**：\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n+k-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 0$ 的可行解个数。\n\n> 此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+...+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 3e6 + 5, M = N;\nconst int mod = 998244353;\nconst ld eps = 1e-8;\n\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += mod;\n    }\n    if (x >= mod) {\n        x -= mod;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, ll b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(ll x) : x(norm(x % mod)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(mod - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, mod - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = ll(x) * rhs.x % mod;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        ll v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nvoid solve()\n{\n\tint R, G, B, K;\n\tcin >> R >> G >> B >> K;\n\n\tvector<Z> fac(N), invfac(N);\n\tfac[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tfac[i] = fac[i - 1] * i;\n\n\tinvfac[N - 1] = fac[N - 1].inv();\n\tfor(int i = N - 1; i; i--)\n\t\tinvfac[i - 1] = invfac[i] * i;\n\n\tauto C = [&](int n, int m)\n\t{\n\t\treturn fac[n] * invfac[m] * invfac[n - m];\n\t};\n\tZ ans = C(G + B, G) * C(G, K) * C(B + R, B + K);\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/ABC-266-A-G.md","raw":"---\ntitle: AtCoder Beginner Contest 266 A-G\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags: AT\ncategories: AT\nabbrlink: 2022907814\ndate: 2022-08-30 09:07:31\npassword:\nsummary:\n---\n\n# AtCoder Beginner Contest 266 A-G\n\n# A \n\n直接输出字符串中间字符即可。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tstring s;\n\tcin >> s;\n\tcout << s[s.size() / 2];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# B\n\n令 $m = 998244353$ 。\n$$\nN - x = k \\times m, k \\in Z\n$$\n\n$$\nx = N - k \\times m, 0 \\leq x \\leq m - 1\n$$\n\n$$\nx = (N \\bmod m + m) \\bmod m\n$$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 998244353;\nconst ld eps = 1e-8;\n// x = n - k mod\nvoid solve()\n{\n\tll n;\n\tcin >> n;\n\tcout << (n % mod + mod) % mod << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# C\n\n直接暴力判断叉积是否小于等于0即可。\n\n> 叉积计算的是三角形面积，当在右手系的情况下， 叉积计算出来的值就是三角形的正面积，如果计算出的值为负值，即三角形不存在。\n>\n> $A,B,C$ 三个点，$\\frac {\\overrightarrow {AB} \\times \\overrightarrow {AC}}{2}$ 即为对应的三角形面积， 只需判断上面分母的叉积是否小于等于 0 即可。两个向量分别为 $(x1, y1),(x2, y2)$ ，则 $S_{\\triangle ABC} = x1 \\cdot y2  - x2 \\cdot y1$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n\nvoid solve()\n{\n\tvector<pii> p(10);\n\tfor(int i = 0; i < 4; i++)\n\t\tcin >> p[i].first >> p[i].second;\n\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tpii a = {p[(i + 1) % 4].first - p[i].first, p[(i + 1) % 4].second - p[i].second};\n\t\tpii b = {p[(i - 1 + 4) % 4].first - p[i].first, p[(i - 1 + 4) % 4].second - p[i].second};\n\t\tif(a.first * b.second - b.first * a.second <= 0)\n\t\t{\n\t\t\tcout << \"No\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"Yes\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# D\n\n$f[i]$ 代表前 $i$ 个蛇， 抓了第 $i$ 个，得到的最大价值。\n\n可以发现，当抓了第 $i$ 个蛇后， 那么位置必须处于 $p[i]$ 处，那么首先可以暴力的想怎么转移， 就是我们可以两层循环， 对于每一个 $f[i]$ ，我们找前面的可以进行转移（即在时间限制内可以到达 $f[j]$ ）的位置 $j,j \\lt i$ ，每一个位置进行判断。 复杂度 $O(n^2)$\n\n但是本题有一个特点，位置数极少，只有5个，那么 $i$ 位置往前5个之后一定是可以转移的位置（在时间限制内一定可以到达 $i$）。 所以我们暴力判断 $i$ 位置的前几个，然后对此进行转移即可。\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvi t(n + 1), p(n + 1), w(n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> t[i] >> p[i] >> w[i];\n\n\tvl f(n + 1, -2e18);\n\tf[0] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = max(0, i - 10); j < i; j++)\n\t\t{\n\t\t\tif(t[i] - t[j] >= abs(p[i] - p[j]))\n\t\t\t\tMax(f[i], f[j] + w[i]);\n\t\t}\n\t}\n\tll ans = *max_element(f.begin() + 1, f.end());\n\tif(ans <= 0) cout << 0 << \"\\n\";\n\telse cout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# E\n\n$$\nf[x] = \\frac{1}{6}max(1, f[x - 1]) + \\frac{1}{6}max(2, f[x - 1]) \\\\ + \\frac{1}{6}max(3, f[x - 1]) + \\frac{1}{6}max(4, f[x - 1]) \\\\ + \\frac{1}{6}max(5, f[x - 1]) + \\frac{1}{6}max(6, f[x - 1])\n$$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tdb ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tdb t = 0;\n\t\tfor(int j = 1; j <= 6; j++)\n\t\t\tt += max(ans, (db)j) / 6;\n\t\tans = t;\n\t}\n\tcout << fixed << setprecision(10) << ans << \"\\n\";\n\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# F\n\n> 一颗基环树， q个询问， 问两点之间是否存在单一路径。\n\n我们首先需要找到这个环，标记一下环上的点，那么以环为树根，单颗子树上的节点（除环上的点）都有单一路径，我们使用并查集将他们连成一个集合即可。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct DSU\n{\n\tvector<int> f, sz;\n\tDSU(int n): f(n), sz(n, 1) { iota(f.begin(), f.end(), 0); }\n\tint find(int x)\n\t{\n\t\tif(x == f[x]) return x;\n\t\treturn f[x] = find(f[x]);\n\t}\n    bool same(int x, int y) { return find(x) == find(y); }\n\tvoid merge(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(sz[x] < sz[y]) swap(x, y);\n\t\tf[y] = x;\n\t\tsz[x] += sz[y];\n\t\tsz[y] = 0;\n\t}\n};\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvector<vi> g(n);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tvector<bool> cyc(n);\n\tvi fa(n, -1), vis(n, -1);\n\tint cur = 0;\n\n\tfunction<void(int)> dfs = [&](int u)\n\t{\n\t\tvis[u] = cur++;\n\t\tfor(auto v : g[u])\n\t\t{\n\t\t\tif(v == fa[u]) continue;\n\t\t\tif(vis[v] == -1)\n\t\t\t{\n\t\t\t\tfa[v] = u;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t\telse if(vis[v] < vis[u])\n\t\t\t{\n\t\t\t\tfor(int i = u; i != v; i = fa[i])\n\t\t\t\t\tcyc[i] = 1;\n\t\t\t\tcyc[v] = 1;\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0);\n\n\tDSU dsu(n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(auto j : g[i])\n\t\t\tif(!cyc[i] || !cyc[j])\n\t\t\t\tdsu.merge(i, j);\n\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tcout << (dsu.same(u, v) ? \"Yes\\n\" : \"No\\n\");\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n# G\n\n> 问有`R` 个字符 `R`，`G` 个字符 `G`，`B` 个字符 `B`，`K` 个字符 `RG`的字符串的个数。\n\n排列组合知识。\n\n首先安排G和B，共$C_{G+B}^{B}$ 种。\n\n然后安排K个R，只能在G的前面填，共`G`个位置，凑成`RG`，共 $C_G^K$ 种。\n\n剩下了 $R-K$ 个`R` ，需要填进去同时保证`RG`的数量不会增加，那么只能在`B` 和 `RG` 的前面以及最后一个位置填，共 $B+K+1$ 个位置。\n\n即 $B+K+1$ 个位置填 $R-K$ 个`R` 。我们使用隔板法， 即等价于将 $B+K+1 + R-K$ 个`R`分成 $B+K+1$ 份， 答案为 $C_{B+R}^{B+K}$ 种。\n\n> 以下为隔板法描述：\n\n**一般隔板法：**\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 1$ 的可行解个数。\n\n**添元素隔板法**：\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n+k-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 0$ 的可行解个数。\n\n> 此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+...+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\ntemplate <class T> void Min(T &a, const T b) { if (a > b) a = b; }\ntemplate <class T> void Max(T &a, const T b) { if (a < b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 3e6 + 5, M = N;\nconst int mod = 998244353;\nconst ld eps = 1e-8;\n\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += mod;\n    }\n    if (x >= mod) {\n        x -= mod;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, ll b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(ll x) : x(norm(x % mod)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(mod - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, mod - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = ll(x) * rhs.x % mod;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        ll v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nvoid solve()\n{\n\tint R, G, B, K;\n\tcin >> R >> G >> B >> K;\n\n\tvector<Z> fac(N), invfac(N);\n\tfac[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tfac[i] = fac[i - 1] * i;\n\n\tinvfac[N - 1] = fac[N - 1].inv();\n\tfor(int i = N - 1; i; i--)\n\t\tinvfac[i - 1] = invfac[i] * i;\n\n\tauto C = [&](int n, int m)\n\t{\n\t\treturn fac[n] * invfac[m] * invfac[n - m];\n\t};\n\tZ ans = C(G + B, G) * C(G, K) * C(B + R, B + K);\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n","slug":"ABC-266-A-G","published":1,"updated":"2022-08-30T01:10:47.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolh5000s6kuhm8od29ji","content":"<h1 id=\"AtCoder-Beginner-Contest-266-A-G\"><a href=\"#AtCoder-Beginner-Contest-266-A-G\" class=\"headerlink\" title=\"AtCoder Beginner Contest 266 A-G\"></a>AtCoder Beginner Contest 266 A-G</h1><h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><p>直接输出字符串中间字符即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    string s<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><p>令 $m = 998244353$ 。<br>$$<br>N - x = k \\times m, k \\in Z<br>$$</p>\n<p>$$<br>x = N - k \\times m, 0 \\leq x \\leq m - 1<br>$$</p>\n<p>$$<br>x = (N \\bmod m + m) \\bmod m<br>$$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">998244353</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// x = n - k mod</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> mod <span class=\"token operator\">+</span> mod<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><p>直接暴力判断叉积是否小于等于0即可。</p>\n<blockquote>\n<p>叉积计算的是三角形面积，当在右手系的情况下， 叉积计算出来的值就是三角形的正面积，如果计算出的值为负值，即三角形不存在。</p>\n<p>$A,B,C$ 三个点，$\\frac {\\overrightarrow {AB} \\times \\overrightarrow {AC}}{2}$ 即为对应的三角形面积， 只需判断上面分母的叉积是否小于等于 0 即可。两个向量分别为 $(x1, y1),(x2, y2)$ ，则 $S_{\\triangle ABC} = x1 \\cdot y2  - x2 \\cdot y1$</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span>pii<span class=\"token operator\">></span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">>></span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        pii a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">-</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second <span class=\"token operator\">-</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        pii b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">-</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second <span class=\"token operator\">-</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>first <span class=\"token operator\">*</span> b<span class=\"token punctuation\">.</span>second <span class=\"token operator\">-</span> b<span class=\"token punctuation\">.</span>first <span class=\"token operator\">*</span> a<span class=\"token punctuation\">.</span>second <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"No\\n\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Yes\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><p>$f[i]$ 代表前 $i$ 个蛇， 抓了第 $i$ 个，得到的最大价值。</p>\n<p>可以发现，当抓了第 $i$ 个蛇后， 那么位置必须处于 $p[i]$ 处，那么首先可以暴力的想怎么转移， 就是我们可以两层循环， 对于每一个 $f[i]$ ，我们找前面的可以进行转移（即在时间限制内可以到达 $f[j]$ ）的位置 $j,j \\lt i$ ，每一个位置进行判断。 复杂度 $O(n^2)$</p>\n<p>但是本题有一个特点，位置数极少，只有5个，那么 $i$ 位置往前5个之后一定是可以转移的位置（在时间限制内一定可以到达 $i$）。 所以我们暴力判断 $i$ 位置的前几个，然后对此进行转移即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    vi <span class=\"token function\">t</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">w</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> t<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">>></span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">>></span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    vl <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2e18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    f<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> t<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> p<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    ll ans <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">max_element</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ans <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h1><p>$$<br>f[x] = \\frac{1}{6}max(1, f[x - 1]) + \\frac{1}{6}max(2, f[x - 1]) \\\\ + \\frac{1}{6}max(3, f[x - 1]) + \\frac{1}{6}max(4, f[x - 1]) \\\\ + \\frac{1}{6}max(5, f[x - 1]) + \\frac{1}{6}max(6, f[x - 1])<br>$$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    db ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        db t <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            t <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span>j<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> fixed <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">setprecision</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><blockquote>\n<p>一颗基环树， q个询问， 问两点之间是否存在单一路径。</p>\n</blockquote>\n<p>我们首先需要找到这个环，标记一下环上的点，那么以环为树根，单颗子树上的节点（除环上的点）都有单一路径，我们使用并查集将他们连成一个集合即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> DSU\n<span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">DSU</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">sz</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">iota</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> f<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">same</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        y <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        f<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n        sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span>vi<span class=\"token operator\">></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        u<span class=\"token operator\">--</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        g<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> <span class=\"token function\">cyc</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vi <span class=\"token function\">fa</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vis</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cur <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> dfs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        vis<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cur<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>v <span class=\"token operator\">==</span> fa<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>vis<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                fa<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> u<span class=\"token punctuation\">;</span>\n                <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>vis<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> vis<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> u<span class=\"token punctuation\">;</span> i <span class=\"token operator\">!=</span> v<span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> fa<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    cyc<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                cyc<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    DSU <span class=\"token function\">dsu</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> j <span class=\"token operator\">:</span> g<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cyc<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>cyc<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                dsu<span class=\"token punctuation\">.</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        u<span class=\"token operator\">--</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>dsu<span class=\"token punctuation\">.</span><span class=\"token function\">same</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"Yes\\n\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"No\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><blockquote>\n<p>问有<code>R</code> 个字符 <code>R</code>，<code>G</code> 个字符 <code>G</code>，<code>B</code> 个字符 <code>B</code>，<code>K</code> 个字符 <code>RG</code>的字符串的个数。</p>\n</blockquote>\n<p>排列组合知识。</p>\n<p>首先安排G和B，共$C_{G+B}^{B}$ 种。</p>\n<p>然后安排K个R，只能在G的前面填，共<code>G</code>个位置，凑成<code>RG</code>，共 $C_G^K$ 种。</p>\n<p>剩下了 $R-K$ 个<code>R</code> ，需要填进去同时保证<code>RG</code>的数量不会增加，那么只能在<code>B</code> 和 <code>RG</code> 的前面以及最后一个位置填，共 $B+K+1$ 个位置。</p>\n<p>即 $B+K+1$ 个位置填 $R-K$ 个<code>R</code> 。我们使用隔板法， 即等价于将 $B+K+1 + R-K$ 个<code>R</code>分成 $B+K+1$ 份， 答案为 $C_{B+R}^{B+K}$ 种。</p>\n<blockquote>\n<p>以下为隔板法描述：</p>\n</blockquote>\n<p><strong>一般隔板法：</strong></p>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 1$ 的可行解个数。</p>\n<p><strong>添元素隔板法</strong>：</p>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n+k-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 0$ 的可行解个数。</p>\n<blockquote>\n<p>此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+…+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> db <span class=\"token operator\">=</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ld <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">double</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Min</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token keyword\">void</span> <span class=\"token function\">Max</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> dy<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">3e6</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">998244353</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> ld eps <span class=\"token operator\">=</span> <span class=\"token number\">1e-8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// assume -P &lt;= x &lt; 2P</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">norm</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">+</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">>=</span> mod<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">-</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\nT <span class=\"token function\">power</span><span class=\"token punctuation\">(</span>T a<span class=\"token punctuation\">,</span> ll b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    T res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> b<span class=\"token punctuation\">;</span> b <span class=\"token operator\">/</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">*</span><span class=\"token operator\">=</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            res <span class=\"token operator\">*</span><span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">struct</span> Z <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span>ll x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token keyword\">operator</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span><span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>mod <span class=\"token operator\">-</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token function\">inv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">power</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">ll</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> rhs<span class=\"token punctuation\">.</span>x <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> rhs<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">-</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> rhs<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">/</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span> <span class=\"token operator\">*</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">inv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">*</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">+</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">-</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">/</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> std<span class=\"token operator\">::</span>istream <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>istream <span class=\"token operator\">&amp;</span>is<span class=\"token punctuation\">,</span> Z <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ll v<span class=\"token punctuation\">;</span>\n        is <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> is<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> std<span class=\"token operator\">::</span>ostream <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>ostream <span class=\"token operator\">&amp;</span>os<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> os <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> R <span class=\"token operator\">>></span> G <span class=\"token operator\">>></span> B <span class=\"token operator\">>></span> K<span class=\"token punctuation\">;</span>\n\n    vector<span class=\"token operator\">&lt;</span>Z<span class=\"token operator\">></span> <span class=\"token function\">fac</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">invfac</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    fac<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        fac<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fac<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span>\n\n    invfac<span class=\"token punctuation\">[</span>N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fac<span class=\"token punctuation\">[</span>N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">inv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        invfac<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> invfac<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">auto</span> C <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> fac<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> invfac<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> invfac<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    Z ans <span class=\"token operator\">=</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>G <span class=\"token operator\">+</span> B<span class=\"token punctuation\">,</span> G<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>B <span class=\"token operator\">+</span> R<span class=\"token punctuation\">,</span> B <span class=\"token operator\">+</span> K<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"AtCoder-Beginner-Contest-266-A-G\"><a href=\"#AtCoder-Beginner-Contest-266-A-G\" class=\"headerlink\" title=\"AtCoder Beginner Contest 266 A-G\"></a>AtCoder Beginner Contest 266 A-G</h1><h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><p>直接输出字符串中间字符即可。</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; s[s.size() / 2];\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><p>令 $m = 998244353$ 。<br>$$<br>N - x = k \\times m, k \\in Z<br>$$</p>\n<p>$$<br>x = N - k \\times m, 0 \\leq x \\leq m - 1<br>$$</p>\n<p>$$<br>x = (N \\bmod m + m) \\bmod m<br>$$</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 998244353;\nconst ld eps = 1e-8;\n// x = n - k mod\nvoid solve()\n{\n    ll n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; (n % mod + mod) % mod &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><p>直接暴力判断叉积是否小于等于0即可。</p>\n<blockquote>\n<p>叉积计算的是三角形面积，当在右手系的情况下， 叉积计算出来的值就是三角形的正面积，如果计算出的值为负值，即三角形不存在。</p>\n<p>$A,B,C$ 三个点，$\\frac {\\overrightarrow {AB} \\times \\overrightarrow {AC}}{2}$ 即为对应的三角形面积， 只需判断上面分母的叉积是否小于等于 0 即可。两个向量分别为 $(x1, y1),(x2, y2)$ ，则 $S_{\\triangle ABC} = x1 \\cdot y2  - x2 \\cdot y1$</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n\nvoid solve()\n{\n    vector&lt;pii&gt; p(10);\n    for(int i = 0; i &lt; 4; i++)\n        cin &gt;&gt; p[i].first &gt;&gt; p[i].second;\n\n    for(int i = 0; i &lt; 4; i++)\n    {\n        pii a = {p[(i + 1) % 4].first - p[i].first, p[(i + 1) % 4].second - p[i].second};\n        pii b = {p[(i - 1 + 4) % 4].first - p[i].first, p[(i - 1 + 4) % 4].second - p[i].second};\n        if(a.first * b.second - b.first * a.second &lt;= 0)\n        {\n            cout &lt;&lt; &quot;No\\n&quot;;\n            return;\n        }\n    }\n    cout &lt;&lt; &quot;Yes\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><p>$f[i]$ 代表前 $i$ 个蛇， 抓了第 $i$ 个，得到的最大价值。</p>\n<p>可以发现，当抓了第 $i$ 个蛇后， 那么位置必须处于 $p[i]$ 处，那么首先可以暴力的想怎么转移， 就是我们可以两层循环， 对于每一个 $f[i]$ ，我们找前面的可以进行转移（即在时间限制内可以到达 $f[j]$ ）的位置 $j,j \\lt i$ ，每一个位置进行判断。 复杂度 $O(n^2)$</p>\n<p>但是本题有一个特点，位置数极少，只有5个，那么 $i$ 位置往前5个之后一定是可以转移的位置（在时间限制内一定可以到达 $i$）。 所以我们暴力判断 $i$ 位置的前几个，然后对此进行转移即可。</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vi t(n + 1), p(n + 1), w(n + 1);\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; t[i] &gt;&gt; p[i] &gt;&gt; w[i];\n\n    vl f(n + 1, -2e18);\n    f[0] = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        for(int j = max(0, i - 10); j &lt; i; j++)\n        {\n            if(t[i] - t[j] &gt;= abs(p[i] - p[j]))\n                Max(f[i], f[j] + w[i]);\n        }\n    }\n    ll ans = *max_element(f.begin() + 1, f.end());\n    if(ans &lt;= 0) cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;;\n    else cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h1><p>$$<br>f[x] = \\frac{1}{6}max(1, f[x - 1]) + \\frac{1}{6}max(2, f[x - 1]) \\\\ + \\frac{1}{6}max(3, f[x - 1]) + \\frac{1}{6}max(4, f[x - 1]) \\\\ + \\frac{1}{6}max(5, f[x - 1]) + \\frac{1}{6}max(6, f[x - 1])<br>$$</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    db ans = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        db t = 0;\n        for(int j = 1; j &lt;= 6; j++)\n            t += max(ans, (db)j) / 6;\n        ans = t;\n    }\n    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><blockquote>\n<p>一颗基环树， q个询问， 问两点之间是否存在单一路径。</p>\n</blockquote>\n<p>我们首先需要找到这个环，标记一下环上的点，那么以环为树根，单颗子树上的节点（除环上的点）都有单一路径，我们使用并查集将他们连成一个集合即可。</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-8;\n\nstruct DSU\n{\n    vector&lt;int&gt; f, sz;\n    DSU(int n): f(n), sz(n, 1) { iota(f.begin(), f.end(), 0); }\n    int find(int x)\n    {\n        if(x == f[x]) return x;\n        return f[x] = find(f[x]);\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n    void merge(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] &lt; sz[y]) swap(x, y);\n        f[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n};\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;vi&gt; g(n);\n    for(int i = 1; i &lt;= n; i++)\n    {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector&lt;bool&gt; cyc(n);\n    vi fa(n, -1), vis(n, -1);\n    int cur = 0;\n\n    function&lt;void(int)&gt; dfs = [&amp;](int u)\n    {\n        vis[u] = cur++;\n        for(auto v : g[u])\n        {\n            if(v == fa[u]) continue;\n            if(vis[v] == -1)\n            {\n                fa[v] = u;\n                dfs(v);\n            }\n            else if(vis[v] &lt; vis[u])\n            {\n                for(int i = u; i != v; i = fa[i])\n                    cyc[i] = 1;\n                cyc[v] = 1;\n            }\n        }\n    };\n    dfs(0);\n\n    DSU dsu(n);\n    for(int i = 0; i &lt; n; i++)\n        for(auto j : g[i])\n            if(!cyc[i] || !cyc[j])\n                dsu.merge(i, j);\n\n    int q;\n    cin &gt;&gt; q;\n    while(q--)\n    {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        u--, v--;\n        cout &lt;&lt; (dsu.same(u, v) ? &quot;Yes\\n&quot; : &quot;No\\n&quot;);\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><blockquote>\n<p>问有<code>R</code> 个字符 <code>R</code>，<code>G</code> 个字符 <code>G</code>，<code>B</code> 个字符 <code>B</code>，<code>K</code> 个字符 <code>RG</code>的字符串的个数。</p>\n</blockquote>\n<p>排列组合知识。</p>\n<p>首先安排G和B，共$C_{G+B}^{B}$ 种。</p>\n<p>然后安排K个R，只能在G的前面填，共<code>G</code>个位置，凑成<code>RG</code>，共 $C_G^K$ 种。</p>\n<p>剩下了 $R-K$ 个<code>R</code> ，需要填进去同时保证<code>RG</code>的数量不会增加，那么只能在<code>B</code> 和 <code>RG</code> 的前面以及最后一个位置填，共 $B+K+1$ 个位置。</p>\n<p>即 $B+K+1$ 个位置填 $R-K$ 个<code>R</code> 。我们使用隔板法， 即等价于将 $B+K+1 + R-K$ 个<code>R</code>分成 $B+K+1$ 份， 答案为 $C_{B+R}^{B+K}$ 种。</p>\n<blockquote>\n<p>以下为隔板法描述：</p>\n</blockquote>\n<p><strong>一般隔板法：</strong></p>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 1$ 的可行解个数。</p>\n<p><strong>添元素隔板法</strong>：</p>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n+k-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 0$ 的可行解个数。</p>\n<blockquote>\n<p>此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+…+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\ntemplate &lt;class T&gt; void Min(T &amp;a, const T b) { if (a &gt; b) a = b; }\ntemplate &lt;class T&gt; void Max(T &amp;a, const T b) { if (a &lt; b) a = b; }\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nconst int N = 3e6 + 5, M = N;\nconst int mod = 998244353;\nconst ld eps = 1e-8;\n\n// assume -P &lt;= x &lt; 2P\nint norm(int x) {\n    if (x &lt; 0) {\n        x += mod;\n    }\n    if (x &gt;= mod) {\n        x -= mod;\n    }\n    return x;\n}\ntemplate&lt;class T&gt;\nT power(T a, ll b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(ll x) : x(norm(x % mod)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(mod - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, mod - 2);\n    }\n    Z &amp;operator*=(const Z &amp;rhs) {\n        x = ll(x) * rhs.x % mod;\n        return *this;\n    }\n    Z &amp;operator+=(const Z &amp;rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &amp;operator-=(const Z &amp;rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &amp;operator/=(const Z &amp;rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;a) {\n        ll v;\n        is &gt;&gt; v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;a) {\n        return os &lt;&lt; a.val();\n    }\n};\n\nvoid solve()\n{\n    int R, G, B, K;\n    cin &gt;&gt; R &gt;&gt; G &gt;&gt; B &gt;&gt; K;\n\n    vector&lt;Z&gt; fac(N), invfac(N);\n    fac[0] = 1;\n    for(int i = 1; i &lt; N; i++)\n        fac[i] = fac[i - 1] * i;\n\n    invfac[N - 1] = fac[N - 1].inv();\n    for(int i = N - 1; i; i--)\n        invfac[i - 1] = invfac[i] * i;\n\n    auto C = [&amp;](int n, int m)\n    {\n        return fac[n] * invfac[m] * invfac[n - m];\n    };\n    Z ans = C(G + B, G) * C(G, K) * C(B + R, B + K);\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n"},{"title":"CF1181C Flag-子矩阵数量统计","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":2396599521,"date":"2022-06-29T08:03:02.000Z","password":null,"summary":null,"_content":"\n\n\n# CF1181C Flag子矩阵数量统计\n\n## 题目介绍\n\n题目链接：\n\n[https://codeforces.com/problemset/problem/1181/C](https://codeforces.com/problemset/problem/1181/C)\n\n![题目描述](2396599521/image-20220629160509729.png)\n\n## 思路\n\n### 维护变量\n\n统计子矩阵一般都需要维护一些数组，大部分都是纵向维护或者横向维护。\n\n本题维护两个数组：\n\n$d[i][j]$ : $(i, j)$位置向下最多延伸相同颜色的块数\n\n$r[i][j]$：$(i, j)$位置向右最多延伸相同颜色的块数\n\n\n\n我们先考虑宽度为$1$的情况，统计该列的贡献时再考虑该列横向向右能达到的最大贡献。\n\n同时需要再维护两个横向延伸的最小值数组：\n\n$r[i][j]$ ：**前缀**（横向数组）最小值，$(x, j)$到$(i, j),x < i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值\n\n> $r[i][j]$和声明的一样，但是此$r[i][j]$是利用上述数组更新来的（具体见代码）\n\n$lmn[i][j]$ : **后缀**（横向数组）最小值，$(x, j)$到$(i, j), x > i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值\n\n\n\n---\n\n### 实现\n\n先考虑宽度为1时，在纵向方向上能否构成国旗\n\n即下面的条件（满足的旗子共三行，如题要求）\n\n- $i + 3 * d[i][j] - 1 <= n$  第三行的旗子不越界\n\n- $d[i][j] == d[i + d[i][j]][j]$ 第二行和第一行的长度相同\n\n- $d[i + 2 \\* d[i][j]][j] >= d[i][j]$ 第三行的长度**大于等于**上面的行长度（大于等于请思考为什么，只要大于等于就能统计上）\n\n\n\n纵向能够形成旗子，那么考虑改纵向旗子的贡献。\n\n> 求贡献：\n>\n> 因为每一个满足条件的纵向旗子都会求贡献，所以每个纵向旗子求贡献只用向右求就行。\n>\n> 以下为举例：\n>\n> AAA\n>\n> BBB\n>\n> CCC\n>\n> 最左边一列，可形成3种情况\n>\n> 中间一列，可形成2种情况\n>\n> 最右边一列，可形成1种情况\n>\n> 包含了所有的情况，总贡献就是 3 + 2 + 1\n>\n> 其实就是$n(n + 1) / 2$，亦或是递推式$f[i] = f[i - 1] + i$，思想基本一样\n\n\n\n那么就要求贡献了\n\n我们肯定需要找**最小**的向右扩展的长度才能算当前整体的贡献，最小向右扩展长度需要是**上中下**三部分的最小值。\n\n故需要用到上述最小值（前缀和后缀）数组。\n\n>  为什么要用到后缀数组?\n>\n> 以下为举例：满足情况的列用粗体标明\n>\n> A （无关紧要行）\n>\n> **A**\n>\n> **A**\n>\n> **B**\n>\n> **B**\n>\n> **C**\n>\n> **C**\n>\n> C（无关紧要行）\n>\n> 但是上下各多出一个字母，如果统计最小值时，上面部分用到前缀最小值数组，就会把第一行向右扩展的长度统计上去，造成统计错误。下面部分同理。\n>\n> 故上面部分需要用到后缀数组，下面部分需要用到前缀数组，中间部分无所谓\n\n则当前列能够造成的贡献为 $min(lmn[i][j], r[i + 2 \\* d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j])$\n\n\n\n具体整体实现见代码。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 1005, mod = 1e9 + 7;\n\nint d[N][N], r[N][N], lmn[N][N];\nchar s[N][N];\n\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> (s[i] + 1);\n\n\tfor(int i = n; i; i--)\n\t{\n\t\tfor(int j = m; j; j--)\n\t\t{\n\t\t\td[i][j] = d[i + 1][j], r[i][j] = r[i][j + 1];\n\n\t\t\tif(s[i][j] == s[i + 1][j])\n\t\t\t\td[i][j] ++;\n\t\t\telse d[i][j] = 1;\n\t\t\t\n\t\t\tif(s[i][j] == s[i][j + 1])\n\t\t\t\tr[i][j] ++;\n\t\t\telse r[i][j] = 1;\n\t\t}\n\t}\n\n\tfor(int i = n; i; i--)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tlmn[i][j] = r[i][j];\n\t\t\tif(i < n && s[i + 1][j] == s[i][j])\n\t\t\t\tlmn[i][j] = min(lmn[i][j], lmn[i + 1][j]);\n\t\t}\n\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif(s[i][j] == s[i - 1][j])\n\t\t\t\tr[i][j] = min(r[i][j], r[i - 1][j]);\n\t\t}\n\n\n\tll ans = 0;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif(i + 3 * d[i][j] - 1 <= n && d[i][j] == d[i + d[i][j]][j] && d[i + 2 * d[i][j]][j] >= d[i][j])\n\t\t\t\tans += min({lmn[i][j], r[i + 2 * d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j]});\n\t\t}\n\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\t// cin >> t;\n\tt = 1;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n![](/medias/gzh.jpg)\n","source":"_posts/CF1181C-Flag-子矩阵数量统计.md","raw":"---\ntitle: CF1181C Flag-子矩阵数量统计\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - CF\n  - DP\ncategories:\n  - DP\nabbrlink: 2396599521\ndate: 2022-06-29 16:03:02\npassword:\nsummary:\n---\n\n\n\n# CF1181C Flag子矩阵数量统计\n\n## 题目介绍\n\n题目链接：\n\n[https://codeforces.com/problemset/problem/1181/C](https://codeforces.com/problemset/problem/1181/C)\n\n![题目描述](2396599521/image-20220629160509729.png)\n\n## 思路\n\n### 维护变量\n\n统计子矩阵一般都需要维护一些数组，大部分都是纵向维护或者横向维护。\n\n本题维护两个数组：\n\n$d[i][j]$ : $(i, j)$位置向下最多延伸相同颜色的块数\n\n$r[i][j]$：$(i, j)$位置向右最多延伸相同颜色的块数\n\n\n\n我们先考虑宽度为$1$的情况，统计该列的贡献时再考虑该列横向向右能达到的最大贡献。\n\n同时需要再维护两个横向延伸的最小值数组：\n\n$r[i][j]$ ：**前缀**（横向数组）最小值，$(x, j)$到$(i, j),x < i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值\n\n> $r[i][j]$和声明的一样，但是此$r[i][j]$是利用上述数组更新来的（具体见代码）\n\n$lmn[i][j]$ : **后缀**（横向数组）最小值，$(x, j)$到$(i, j), x > i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值\n\n\n\n---\n\n### 实现\n\n先考虑宽度为1时，在纵向方向上能否构成国旗\n\n即下面的条件（满足的旗子共三行，如题要求）\n\n- $i + 3 * d[i][j] - 1 <= n$  第三行的旗子不越界\n\n- $d[i][j] == d[i + d[i][j]][j]$ 第二行和第一行的长度相同\n\n- $d[i + 2 \\* d[i][j]][j] >= d[i][j]$ 第三行的长度**大于等于**上面的行长度（大于等于请思考为什么，只要大于等于就能统计上）\n\n\n\n纵向能够形成旗子，那么考虑改纵向旗子的贡献。\n\n> 求贡献：\n>\n> 因为每一个满足条件的纵向旗子都会求贡献，所以每个纵向旗子求贡献只用向右求就行。\n>\n> 以下为举例：\n>\n> AAA\n>\n> BBB\n>\n> CCC\n>\n> 最左边一列，可形成3种情况\n>\n> 中间一列，可形成2种情况\n>\n> 最右边一列，可形成1种情况\n>\n> 包含了所有的情况，总贡献就是 3 + 2 + 1\n>\n> 其实就是$n(n + 1) / 2$，亦或是递推式$f[i] = f[i - 1] + i$，思想基本一样\n\n\n\n那么就要求贡献了\n\n我们肯定需要找**最小**的向右扩展的长度才能算当前整体的贡献，最小向右扩展长度需要是**上中下**三部分的最小值。\n\n故需要用到上述最小值（前缀和后缀）数组。\n\n>  为什么要用到后缀数组?\n>\n> 以下为举例：满足情况的列用粗体标明\n>\n> A （无关紧要行）\n>\n> **A**\n>\n> **A**\n>\n> **B**\n>\n> **B**\n>\n> **C**\n>\n> **C**\n>\n> C（无关紧要行）\n>\n> 但是上下各多出一个字母，如果统计最小值时，上面部分用到前缀最小值数组，就会把第一行向右扩展的长度统计上去，造成统计错误。下面部分同理。\n>\n> 故上面部分需要用到后缀数组，下面部分需要用到前缀数组，中间部分无所谓\n\n则当前列能够造成的贡献为 $min(lmn[i][j], r[i + 2 \\* d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j])$\n\n\n\n具体整体实现见代码。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 1005, mod = 1e9 + 7;\n\nint d[N][N], r[N][N], lmn[N][N];\nchar s[N][N];\n\nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> (s[i] + 1);\n\n\tfor(int i = n; i; i--)\n\t{\n\t\tfor(int j = m; j; j--)\n\t\t{\n\t\t\td[i][j] = d[i + 1][j], r[i][j] = r[i][j + 1];\n\n\t\t\tif(s[i][j] == s[i + 1][j])\n\t\t\t\td[i][j] ++;\n\t\t\telse d[i][j] = 1;\n\t\t\t\n\t\t\tif(s[i][j] == s[i][j + 1])\n\t\t\t\tr[i][j] ++;\n\t\t\telse r[i][j] = 1;\n\t\t}\n\t}\n\n\tfor(int i = n; i; i--)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tlmn[i][j] = r[i][j];\n\t\t\tif(i < n && s[i + 1][j] == s[i][j])\n\t\t\t\tlmn[i][j] = min(lmn[i][j], lmn[i + 1][j]);\n\t\t}\n\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif(s[i][j] == s[i - 1][j])\n\t\t\t\tr[i][j] = min(r[i][j], r[i - 1][j]);\n\t\t}\n\n\n\tll ans = 0;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif(i + 3 * d[i][j] - 1 <= n && d[i][j] == d[i + d[i][j]][j] && d[i + 2 * d[i][j]][j] >= d[i][j])\n\t\t\t\tans += min({lmn[i][j], r[i + 2 * d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j]});\n\t\t}\n\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\t// cin >> t;\n\tt = 1;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n![](/medias/gzh.jpg)\n","slug":"CF1181C-Flag-子矩阵数量统计","published":1,"updated":"2022-08-04T07:15:56.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolh8000t6kuhppn3mw48","content":"<h1 id=\"CF1181C-Flag子矩阵数量统计\"><a href=\"#CF1181C-Flag子矩阵数量统计\" class=\"headerlink\" title=\"CF1181C Flag子矩阵数量统计\"></a>CF1181C Flag子矩阵数量统计</h1><h2 id=\"题目介绍\"><a href=\"#题目介绍\" class=\"headerlink\" title=\"题目介绍\"></a>题目介绍</h2><p>题目链接：</p>\n<p><a href=\"https://codeforces.com/problemset/problem/1181/C\" target=\"_blank\" rel=\"noopener\">https://codeforces.com/problemset/problem/1181/C</a></p>\n<p><img src=\"2396599521/image-20220629160509729.png\" alt=\"题目描述\"></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"维护变量\"><a href=\"#维护变量\" class=\"headerlink\" title=\"维护变量\"></a>维护变量</h3><p>统计子矩阵一般都需要维护一些数组，大部分都是纵向维护或者横向维护。</p>\n<p>本题维护两个数组：</p>\n<p>$d[i][j]$ : $(i, j)$位置向下最多延伸相同颜色的块数</p>\n<p>$r[i][j]$：$(i, j)$位置向右最多延伸相同颜色的块数</p>\n<p>我们先考虑宽度为$1$的情况，统计该列的贡献时再考虑该列横向向右能达到的最大贡献。</p>\n<p>同时需要再维护两个横向延伸的最小值数组：</p>\n<p>$r[i][j]$ ：<strong>前缀</strong>（横向数组）最小值，$(x, j)$到$(i, j),x &lt; i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值</p>\n<blockquote>\n<p>$r[i][j]$和声明的一样，但是此$r[i][j]$是利用上述数组更新来的（具体见代码）</p>\n</blockquote>\n<p>$lmn[i][j]$ : <strong>后缀</strong>（横向数组）最小值，$(x, j)$到$(i, j), x &gt; i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值</p>\n<hr>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>先考虑宽度为1时，在纵向方向上能否构成国旗</p>\n<p>即下面的条件（满足的旗子共三行，如题要求）</p>\n<ul>\n<li><p>$i + 3 * d[i][j] - 1 &lt;= n$  第三行的旗子不越界</p>\n</li>\n<li><p>$d[i][j] == d[i + d[i][j]][j]$ 第二行和第一行的长度相同</p>\n</li>\n<li><p>$d[i + 2 * d[i][j]][j] &gt;= d[i][j]$ 第三行的长度<strong>大于等于</strong>上面的行长度（大于等于请思考为什么，只要大于等于就能统计上）</p>\n</li>\n</ul>\n<p>纵向能够形成旗子，那么考虑改纵向旗子的贡献。</p>\n<blockquote>\n<p>求贡献：</p>\n<p>因为每一个满足条件的纵向旗子都会求贡献，所以每个纵向旗子求贡献只用向右求就行。</p>\n<p>以下为举例：</p>\n<p>AAA</p>\n<p>BBB</p>\n<p>CCC</p>\n<p>最左边一列，可形成3种情况</p>\n<p>中间一列，可形成2种情况</p>\n<p>最右边一列，可形成1种情况</p>\n<p>包含了所有的情况，总贡献就是 3 + 2 + 1</p>\n<p>其实就是$n(n + 1) / 2$，亦或是递推式$f[i] = f[i - 1] + i$，思想基本一样</p>\n</blockquote>\n<p>那么就要求贡献了</p>\n<p>我们肯定需要找<strong>最小</strong>的向右扩展的长度才能算当前整体的贡献，最小向右扩展长度需要是<strong>上中下</strong>三部分的最小值。</p>\n<p>故需要用到上述最小值（前缀和后缀）数组。</p>\n<blockquote>\n<p> 为什么要用到后缀数组?</p>\n<p>以下为举例：满足情况的列用粗体标明</p>\n<p>A （无关紧要行）</p>\n<p><strong>A</strong></p>\n<p><strong>A</strong></p>\n<p><strong>B</strong></p>\n<p><strong>B</strong></p>\n<p><strong>C</strong></p>\n<p><strong>C</strong></p>\n<p>C（无关紧要行）</p>\n<p>但是上下各多出一个字母，如果统计最小值时，上面部分用到前缀最小值数组，就会把第一行向右扩展的长度统计上去，造成统计错误。下面部分同理。</p>\n<p>故上面部分需要用到后缀数组，下面部分需要用到前缀数组，中间部分无所谓</p>\n</blockquote>\n<p>则当前列能够造成的贡献为 $min(lmn[i][j], r[i + 2 * d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j])$</p>\n<p>具体整体实现见代码。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1005</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> d<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> lmn<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> s<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> m<span class=\"token punctuation\">;</span> j<span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> d<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            lmn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                lmn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>lmn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> lmn<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;=</span> n <span class=\"token operator\">&amp;&amp;</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> d<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> d<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>lmn<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> d<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"/medias/gzh.jpg\" alt></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"CF1181C-Flag子矩阵数量统计\"><a href=\"#CF1181C-Flag子矩阵数量统计\" class=\"headerlink\" title=\"CF1181C Flag子矩阵数量统计\"></a>CF1181C Flag子矩阵数量统计</h1><h2 id=\"题目介绍\"><a href=\"#题目介绍\" class=\"headerlink\" title=\"题目介绍\"></a>题目介绍</h2><p>题目链接：</p>\n<p><a href=\"https://codeforces.com/problemset/problem/1181/C\" target=\"_blank\" rel=\"noopener\">https://codeforces.com/problemset/problem/1181/C</a></p>\n<p><img src=\"2396599521/image-20220629160509729.png\" alt=\"题目描述\"></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"维护变量\"><a href=\"#维护变量\" class=\"headerlink\" title=\"维护变量\"></a>维护变量</h3><p>统计子矩阵一般都需要维护一些数组，大部分都是纵向维护或者横向维护。</p>\n<p>本题维护两个数组：</p>\n<p>$d[i][j]$ : $(i, j)$位置向下最多延伸相同颜色的块数</p>\n<p>$r[i][j]$：$(i, j)$位置向右最多延伸相同颜色的块数</p>\n<p>我们先考虑宽度为$1$的情况，统计该列的贡献时再考虑该列横向向右能达到的最大贡献。</p>\n<p>同时需要再维护两个横向延伸的最小值数组：</p>\n<p>$r[i][j]$ ：<strong>前缀</strong>（横向数组）最小值，$(x, j)$到$(i, j),x &lt; i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值</p>\n<blockquote>\n<p>$r[i][j]$和声明的一样，但是此$r[i][j]$是利用上述数组更新来的（具体见代码）</p>\n</blockquote>\n<p>$lmn[i][j]$ : <strong>后缀</strong>（横向数组）最小值，$(x, j)$到$(i, j), x &gt; i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值</p>\n<hr>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>先考虑宽度为1时，在纵向方向上能否构成国旗</p>\n<p>即下面的条件（满足的旗子共三行，如题要求）</p>\n<ul>\n<li><p>$i + 3 * d[i][j] - 1 &lt;= n$  第三行的旗子不越界</p>\n</li>\n<li><p>$d[i][j] == d[i + d[i][j]][j]$ 第二行和第一行的长度相同</p>\n</li>\n<li><p>$d[i + 2 * d[i][j]][j] &gt;= d[i][j]$ 第三行的长度<strong>大于等于</strong>上面的行长度（大于等于请思考为什么，只要大于等于就能统计上）</p>\n</li>\n</ul>\n<p>纵向能够形成旗子，那么考虑改纵向旗子的贡献。</p>\n<blockquote>\n<p>求贡献：</p>\n<p>因为每一个满足条件的纵向旗子都会求贡献，所以每个纵向旗子求贡献只用向右求就行。</p>\n<p>以下为举例：</p>\n<p>AAA</p>\n<p>BBB</p>\n<p>CCC</p>\n<p>最左边一列，可形成3种情况</p>\n<p>中间一列，可形成2种情况</p>\n<p>最右边一列，可形成1种情况</p>\n<p>包含了所有的情况，总贡献就是 3 + 2 + 1</p>\n<p>其实就是$n(n + 1) / 2$，亦或是递推式$f[i] = f[i - 1] + i$，思想基本一样</p>\n</blockquote>\n<p>那么就要求贡献了</p>\n<p>我们肯定需要找<strong>最小</strong>的向右扩展的长度才能算当前整体的贡献，最小向右扩展长度需要是<strong>上中下</strong>三部分的最小值。</p>\n<p>故需要用到上述最小值（前缀和后缀）数组。</p>\n<blockquote>\n<p> 为什么要用到后缀数组?</p>\n<p>以下为举例：满足情况的列用粗体标明</p>\n<p>A （无关紧要行）</p>\n<p><strong>A</strong></p>\n<p><strong>A</strong></p>\n<p><strong>B</strong></p>\n<p><strong>B</strong></p>\n<p><strong>C</strong></p>\n<p><strong>C</strong></p>\n<p>C（无关紧要行）</p>\n<p>但是上下各多出一个字母，如果统计最小值时，上面部分用到前缀最小值数组，就会把第一行向右扩展的长度统计上去，造成统计错误。下面部分同理。</p>\n<p>故上面部分需要用到后缀数组，下面部分需要用到前缀数组，中间部分无所谓</p>\n</blockquote>\n<p>则当前列能够造成的贡献为 $min(lmn[i][j], r[i + 2 * d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j])$</p>\n<p>具体整体实现见代码。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nconst int N = 1005, mod = 1e9 + 7;\n\nint d[N][N], r[N][N], lmn[N][N];\nchar s[N][N];\n\nvoid solve()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; (s[i] + 1);\n\n    for(int i = n; i; i--)\n    {\n        for(int j = m; j; j--)\n        {\n            d[i][j] = d[i + 1][j], r[i][j] = r[i][j + 1];\n\n            if(s[i][j] == s[i + 1][j])\n                d[i][j] ++;\n            else d[i][j] = 1;\n\n            if(s[i][j] == s[i][j + 1])\n                r[i][j] ++;\n            else r[i][j] = 1;\n        }\n    }\n\n    for(int i = n; i; i--)\n        for(int j = 1; j &lt;= m; j++)\n        {\n            lmn[i][j] = r[i][j];\n            if(i &lt; n &amp;&amp; s[i + 1][j] == s[i][j])\n                lmn[i][j] = min(lmn[i][j], lmn[i + 1][j]);\n        }\n\n    for(int i = 2; i &lt;= n; i++)\n        for(int j = 1; j &lt;= m; j++)\n        {\n            if(s[i][j] == s[i - 1][j])\n                r[i][j] = min(r[i][j], r[i - 1][j]);\n        }\n\n\n    ll ans = 0;\n\n    for(int i = 1; i &lt;= n; i++)\n        for(int j = 1; j &lt;= m; j++)\n        {\n            if(i + 3 * d[i][j] - 1 &lt;= n &amp;&amp; d[i][j] == d[i + d[i][j]][j] &amp;&amp; d[i + 2 * d[i][j]][j] &gt;= d[i][j])\n                ans += min({lmn[i][j], r[i + 2 * d[i][j] - 1][j], r[i + 3 * d[i][j] - 1][j]});\n        }\n\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    // cin &gt;&gt; t;\n    t = 1;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<p><img src=\"/medias/gzh.jpg\" alt></p>\n"},{"title":"CF1076E.Vasya and a Tree|树上差分","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":3632168690,"date":"2022-08-03T11:26:20.000Z","password":null,"summary":null,"_content":"\n\n\n# CF 1076E. Vasya and a Tree|树上差分\n\n## 题意\n\n> 一棵树，它有n个节点，1号节点为根节点，初始所有点的权值为0。\n>\n> 定义以下两个东西：\n>\n> - 函数$d(i,j)$ : 指节点$i$到$j$所经过边的数量。\n>\n> - $x$节点的$k$级子树，指满足以下条件点的集合：\n>\n>   ① x为该点的祖先，规定自己也是自己的祖先。\n>\n>   ②$d(i,j) \\leq k$。\n>\n> $m$条要求要你来解决：\n>\n> 给出$v,d,x$，将以$v$节点的$d$级子树的权值加上$x$。\n>\n> 当处理完所有的要求时，输出所有点的权值。\n\n## 思路\n\n题目要求对一段深度的某节点的子树进行加和操作，这种操作类似单纯的一维前缀和差分操作，所以可以在树上进行差分操作。\n\n首先就是将所有的操作离线下来，将所有操作挂在节点上。对应下面的代码\n\n```cpp\nvector<vector<pair<int, int>>> q(n + 1);\n\nfor(int i = 1; i <= m; i++)\n{\n    int u, d, v;\n    cin >> u >> d >> v;\n    q[u].push_back({d, v});\n}\n```\n\n---\n\n接下来的关键点就是如何在树上进行差分操作（对应一维差分 区间左端点的加 和 区间右端点的减）。\n\n因为树中的遍历是基于DFS序的，**访问一个子树过后才会访问到另一棵子树**。\n\n我们在DFS过程中维护差分数组（$b[i]$），DFS时携带一个前缀和（$sum$）变量，每访问到一个节点时，先遍历该节点的所有操作，将前缀和（其实就是该路径上差分数组的前缀和，等于当前节点的值）加上操作的值，然后标记差分数组结束的位置（就是在该位置减去操作的那个值）。\n\n当回溯的时候，删除之前打的标记。树遍历是DFS序的，删除之后才会访问到另一棵树相同的深度节点，不会影响$b[i]$的值。\n\n> $b[i]$ : 代表深度为$i$的节点的标记值\n\n标记：\n\n```cpp\nif(dep[u] + d < n - 1)\n    b[dep[u] + d + 1] -= v;//mark\n```\n\n删除标记：\n\n```cpp\nfor(auto [d, v] : q[u])\n{\n    if(dep[u] + d < n - 1)\n        b[dep[u] + d + 1] += v;\n}\n```\n\n\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> g(n + 1);\n\tvector<int> dep(n + 1);\n\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tint m;\n\tcin >> m;\n\n\tvector<vector<pair<int, int>>> q(n + 1);\n\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, d, v;\n\t\tcin >> u >> d >> v;\n\t\tq[u].push_back({d, v});\n\t}\n\n\tvector<ll> b(3e5 + 1);\n\tvector<ll> ans(n + 1);\n\tfunction<void(int, int, ll)> dfs = [&](int u, int fa, ll sum)\n\t{\n        // 加上标记值\n\t\tsum += b[dep[u]]; // minus\n        // 枚举节点操作\n\t\tfor(auto [d, v] : q[u])\n\t\t{\n\t\t\tsum += v;//累加\n\t\t\tif(dep[u] + d < n - 1)\n\t\t\t\tb[dep[u] + d + 1] -= v;//mark\n\t\t}\n\t\tans[u] = sum;\n\t\tfor(auto v : g[u])\n\t\t{\n\t\t\tif(v == fa) continue;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tdfs(v, u, sum);\n\t\t}\n        // 删除标记\n\t\tfor(auto [d, v] : q[u])\n\t\t{\n\t\t\tif(dep[u] + d < n - 1)\n\t\t\t\tb[dep[u] + d + 1] += v;\n\t\t}\n\t};\n\tdfs(1, -1, 0);\n\tfor(int i = 1; i <= n; i++)\n\t\tcout << ans[i] << \" \\n\"[i == n];\n\treturn 0;\n}\n```\n\n","source":"_posts/CF1076E.Vasya and a Tree树上差分.md","raw":"---\ntitle: CF1076E.Vasya and a Tree|树上差分\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - DFS\n  - 树\n  - CF\ncategories:\n  - 树\nabbrlink: 3632168690\ndate: 2022-08-03 19:26:20\npassword:\nsummary:\n---\n\n\n\n# CF 1076E. Vasya and a Tree|树上差分\n\n## 题意\n\n> 一棵树，它有n个节点，1号节点为根节点，初始所有点的权值为0。\n>\n> 定义以下两个东西：\n>\n> - 函数$d(i,j)$ : 指节点$i$到$j$所经过边的数量。\n>\n> - $x$节点的$k$级子树，指满足以下条件点的集合：\n>\n>   ① x为该点的祖先，规定自己也是自己的祖先。\n>\n>   ②$d(i,j) \\leq k$。\n>\n> $m$条要求要你来解决：\n>\n> 给出$v,d,x$，将以$v$节点的$d$级子树的权值加上$x$。\n>\n> 当处理完所有的要求时，输出所有点的权值。\n\n## 思路\n\n题目要求对一段深度的某节点的子树进行加和操作，这种操作类似单纯的一维前缀和差分操作，所以可以在树上进行差分操作。\n\n首先就是将所有的操作离线下来，将所有操作挂在节点上。对应下面的代码\n\n```cpp\nvector<vector<pair<int, int>>> q(n + 1);\n\nfor(int i = 1; i <= m; i++)\n{\n    int u, d, v;\n    cin >> u >> d >> v;\n    q[u].push_back({d, v});\n}\n```\n\n---\n\n接下来的关键点就是如何在树上进行差分操作（对应一维差分 区间左端点的加 和 区间右端点的减）。\n\n因为树中的遍历是基于DFS序的，**访问一个子树过后才会访问到另一棵子树**。\n\n我们在DFS过程中维护差分数组（$b[i]$），DFS时携带一个前缀和（$sum$）变量，每访问到一个节点时，先遍历该节点的所有操作，将前缀和（其实就是该路径上差分数组的前缀和，等于当前节点的值）加上操作的值，然后标记差分数组结束的位置（就是在该位置减去操作的那个值）。\n\n当回溯的时候，删除之前打的标记。树遍历是DFS序的，删除之后才会访问到另一棵树相同的深度节点，不会影响$b[i]$的值。\n\n> $b[i]$ : 代表深度为$i$的节点的标记值\n\n标记：\n\n```cpp\nif(dep[u] + d < n - 1)\n    b[dep[u] + d + 1] -= v;//mark\n```\n\n删除标记：\n\n```cpp\nfor(auto [d, v] : q[u])\n{\n    if(dep[u] + d < n - 1)\n        b[dep[u] + d + 1] += v;\n}\n```\n\n\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> g(n + 1);\n\tvector<int> dep(n + 1);\n\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tint m;\n\tcin >> m;\n\n\tvector<vector<pair<int, int>>> q(n + 1);\n\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, d, v;\n\t\tcin >> u >> d >> v;\n\t\tq[u].push_back({d, v});\n\t}\n\n\tvector<ll> b(3e5 + 1);\n\tvector<ll> ans(n + 1);\n\tfunction<void(int, int, ll)> dfs = [&](int u, int fa, ll sum)\n\t{\n        // 加上标记值\n\t\tsum += b[dep[u]]; // minus\n        // 枚举节点操作\n\t\tfor(auto [d, v] : q[u])\n\t\t{\n\t\t\tsum += v;//累加\n\t\t\tif(dep[u] + d < n - 1)\n\t\t\t\tb[dep[u] + d + 1] -= v;//mark\n\t\t}\n\t\tans[u] = sum;\n\t\tfor(auto v : g[u])\n\t\t{\n\t\t\tif(v == fa) continue;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tdfs(v, u, sum);\n\t\t}\n        // 删除标记\n\t\tfor(auto [d, v] : q[u])\n\t\t{\n\t\t\tif(dep[u] + d < n - 1)\n\t\t\t\tb[dep[u] + d + 1] += v;\n\t\t}\n\t};\n\tdfs(1, -1, 0);\n\tfor(int i = 1; i <= n; i++)\n\t\tcout << ans[i] << \" \\n\"[i == n];\n\treturn 0;\n}\n```\n\n","slug":"CF1076E.Vasya and a Tree树上差分","published":1,"updated":"2022-08-04T06:47:14.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhb000x6kuh9meduo20","content":"<h1 id=\"CF-1076E-Vasya-and-a-Tree-树上差分\"><a href=\"#CF-1076E-Vasya-and-a-Tree-树上差分\" class=\"headerlink\" title=\"CF 1076E. Vasya and a Tree|树上差分\"></a>CF 1076E. Vasya and a Tree|树上差分</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><blockquote>\n<p>一棵树，它有n个节点，1号节点为根节点，初始所有点的权值为0。</p>\n<p>定义以下两个东西：</p>\n<ul>\n<li><p>函数$d(i,j)$ : 指节点$i$到$j$所经过边的数量。</p>\n</li>\n<li><p>$x$节点的$k$级子树，指满足以下条件点的集合：</p>\n<p>① x为该点的祖先，规定自己也是自己的祖先。</p>\n<p>②$d(i,j) \\leq k$。</p>\n</li>\n</ul>\n<p>$m$条要求要你来解决：</p>\n<p>给出$v,d,x$，将以$v$节点的$d$级子树的权值加上$x$。</p>\n<p>当处理完所有的要求时，输出所有点的权值。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>题目要求对一段深度的某节点的子树进行加和操作，这种操作类似单纯的一维前缀和差分操作，所以可以在树上进行差分操作。</p>\n<p>首先就是将所有的操作离线下来，将所有操作挂在节点上。对应下面的代码</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token function\">q</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> d <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<p>接下来的关键点就是如何在树上进行差分操作（对应一维差分 区间左端点的加 和 区间右端点的减）。</p>\n<p>因为树中的遍历是基于DFS序的，<strong>访问一个子树过后才会访问到另一棵子树</strong>。</p>\n<p>我们在DFS过程中维护差分数组（$b[i]$），DFS时携带一个前缀和（$sum$）变量，每访问到一个节点时，先遍历该节点的所有操作，将前缀和（其实就是该路径上差分数组的前缀和，等于当前节点的值）加上操作的值，然后标记差分数组结束的位置（就是在该位置减去操作的那个值）。</p>\n<p>当回溯的时候，删除之前打的标记。树遍历是DFS序的，删除之后才会访问到另一棵树相同的深度节点，不会影响$b[i]$的值。</p>\n<blockquote>\n<p>$b[i]$ : 代表深度为$i$的节点的标记值</p>\n</blockquote>\n<p>标记：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    b<span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span><span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//mark</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>删除标记：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> q<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        b<span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">dep</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        g<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n\n    vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span><span class=\"token operator\">></span> <span class=\"token function\">q</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> d <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        q<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token number\">3e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span> <span class=\"token function\">ans</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> ll<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> dfs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> fa<span class=\"token punctuation\">,</span> ll sum<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 加上标记值</span>\n        sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> b<span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// minus</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 枚举节点操作</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> q<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//累加</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                b<span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span><span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//mark</span>\n        <span class=\"token punctuation\">}</span>\n        ans<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>v <span class=\"token operator\">==</span> fa<span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            dep<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 删除标记</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> q<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                b<span class=\"token punctuation\">[</span>dep<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> d <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> ans<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \\n\"</span><span class=\"token punctuation\">[</span>i <span class=\"token operator\">==</span> n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"CF-1076E-Vasya-and-a-Tree-树上差分\"><a href=\"#CF-1076E-Vasya-and-a-Tree-树上差分\" class=\"headerlink\" title=\"CF 1076E. Vasya and a Tree|树上差分\"></a>CF 1076E. Vasya and a Tree|树上差分</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><blockquote>\n<p>一棵树，它有n个节点，1号节点为根节点，初始所有点的权值为0。</p>\n<p>定义以下两个东西：</p>\n<ul>\n<li><p>函数$d(i,j)$ : 指节点$i$到$j$所经过边的数量。</p>\n</li>\n<li><p>$x$节点的$k$级子树，指满足以下条件点的集合：</p>\n<p>① x为该点的祖先，规定自己也是自己的祖先。</p>\n<p>②$d(i,j) \\leq k$。</p>\n</li>\n</ul>\n<p>$m$条要求要你来解决：</p>\n<p>给出$v,d,x$，将以$v$节点的$d$级子树的权值加上$x$。</p>\n<p>当处理完所有的要求时，输出所有点的权值。</p>\n</blockquote>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>题目要求对一段深度的某节点的子树进行加和操作，这种操作类似单纯的一维前缀和差分操作，所以可以在树上进行差分操作。</p>\n<p>首先就是将所有的操作离线下来，将所有操作挂在节点上。对应下面的代码</p>\n<pre><code class=\"cpp\">vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; q(n + 1);\n\nfor(int i = 1; i &lt;= m; i++)\n{\n    int u, d, v;\n    cin &gt;&gt; u &gt;&gt; d &gt;&gt; v;\n    q[u].push_back({d, v});\n}</code></pre>\n<hr>\n<p>接下来的关键点就是如何在树上进行差分操作（对应一维差分 区间左端点的加 和 区间右端点的减）。</p>\n<p>因为树中的遍历是基于DFS序的，<strong>访问一个子树过后才会访问到另一棵子树</strong>。</p>\n<p>我们在DFS过程中维护差分数组（$b[i]$），DFS时携带一个前缀和（$sum$）变量，每访问到一个节点时，先遍历该节点的所有操作，将前缀和（其实就是该路径上差分数组的前缀和，等于当前节点的值）加上操作的值，然后标记差分数组结束的位置（就是在该位置减去操作的那个值）。</p>\n<p>当回溯的时候，删除之前打的标记。树遍历是DFS序的，删除之后才会访问到另一棵树相同的深度节点，不会影响$b[i]$的值。</p>\n<blockquote>\n<p>$b[i]$ : 代表深度为$i$的节点的标记值</p>\n</blockquote>\n<p>标记：</p>\n<pre><code class=\"cpp\">if(dep[u] + d &lt; n - 1)\n    b[dep[u] + d + 1] -= v;//mark</code></pre>\n<p>删除标记：</p>\n<pre><code class=\"cpp\">for(auto [d, v] : q[u])\n{\n    if(dep[u] + d &lt; n - 1)\n        b[dep[u] + d + 1] += v;\n}</code></pre>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; g(n + 1);\n    vector&lt;int&gt; dep(n + 1);\n\n    for(int i = 1; i &lt; n; i++)\n    {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int m;\n    cin &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; q(n + 1);\n\n    for(int i = 1; i &lt;= m; i++)\n    {\n        int u, d, v;\n        cin &gt;&gt; u &gt;&gt; d &gt;&gt; v;\n        q[u].push_back({d, v});\n    }\n\n    vector&lt;ll&gt; b(3e5 + 1);\n    vector&lt;ll&gt; ans(n + 1);\n    function&lt;void(int, int, ll)&gt; dfs = [&amp;](int u, int fa, ll sum)\n    {\n        // 加上标记值\n        sum += b[dep[u]]; // minus\n        // 枚举节点操作\n        for(auto [d, v] : q[u])\n        {\n            sum += v;//累加\n            if(dep[u] + d &lt; n - 1)\n                b[dep[u] + d + 1] -= v;//mark\n        }\n        ans[u] = sum;\n        for(auto v : g[u])\n        {\n            if(v == fa) continue;\n            dep[v] = dep[u] + 1;\n            dfs(v, u, sum);\n        }\n        // 删除标记\n        for(auto [d, v] : q[u])\n        {\n            if(dep[u] + d &lt; n - 1)\n                b[dep[u] + d + 1] += v;\n        }\n    };\n    dfs(1, -1, 0);\n    for(int i = 1; i &lt;= n; i++)\n        cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == n];\n    return 0;\n}</code></pre>\n"},{"title":"docker|常用命令","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1146830909,"date":"2022-07-02T03:27:31.000Z","password":null,"summary":null,"_content":"\n> 将当前用户添加到docker用户组\n>\n> 为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组（可以参考官方文档）：\n>\n> `sudo usermod -aG docker $USER`\n>\n> 执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。\n\n# 镜像（images）\n\n`docker pull ubuntu:20.04`：拉取一个镜像\n\n`docker images`：列出本地所有镜像\n\n`docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04`：删除镜像ubuntu:20.04\n\n`docker [container] commit CONTAINER IMAGE_NAME:TAG`：创建某个container的镜像\n\n`docker save -o ubuntu_20_04.tar ubuntu:20.04`：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中\n\n`docker load -i ubuntu_20_04.tar`：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来\n\n# 容器（container）\n\n`docker [container] create -it ubuntu:20.04`：利用镜像ubuntu:20.04创建一个容器。\n\n`docker ps -a`：查看本地的所有容器\n\n`docker [container] start CONTAINER`：启动容器\n\n`docker [container] stop CONTAINER`：停止容器\n\n`docker [container] restart CONTAINER`：重启容器\n\n`docker [contaienr] run -itd ubuntu:20.04`：创建并启动一个容器\n\n`docker [container] attach CONTAINER`：进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器\n\n`docker [container] exec CONTAINER COMMAND`：在容器中执行命令\n\n`docker [container] rm CONTAINER`：删除容器\n\n`docker container prune`：删除所有已停止的容器\n\n`docker export -o xxx.tar CONTAINER`：将容器CONTAINER导出到本地文件xxx.tar中\n\n`docker import xxx.tar image_name:tag`：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag\n\n`docker export/import`与`docker save/load`的区别：\n\n- export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态\n\n- save/load会保存完整记录，体积更大\n\n`docker top CONTAINER`：查看某个容器内的所有进程\n\n`docker stats`：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息\n\n`docker cp xxx CONTAINER:xxx` 或 `docker cp CONTAINER:xxx xxx`：在本地和容器间复制文件\n\n`docker rename CONTAINER1 CONTAINER2`：重命名容器\n\n`docker update CONTAINER --memory 500MB`：修改容器限制\n\n# 示例\n\n\n\n```bash\nscp docker_1_0.tar server_name  # 将镜像上传到自己租的云端服务器\n\nssh server_name  # 登录自己的云端服务器\n\ndocker load -i docker_1_0.tar  # 将镜像加载到本地\n\ndocker run -p 20000:22 --name my_docker_server -itd docker:1.0  # 创建并运行docker:1.0镜像, 20000端口映射到22\n\ndocker attach my_docker_server  # 进入创建的docker容器\n```\n\n\n\n# 常用操作\n\n## 查询\n\n```bash\ndocker images # 列出本地所有镜像\ndocker ps -a # 列出本地所有容器\ndocker ps # 列出运行中的容器\n```\n\n## 镜像操作\n\n```bash\ndocker pull ubuntu:20.04 # 拉取一个镜像\ndocker image rm ubuntu:20.04 # 删除一个镜像\n\n```\n\n\n\n## 容器操作\n\n```bash\ndocker container start CONTAINER #启动容器\ndocker container stop CONTAINER #停止容器\ndocker container attach CONTAINER #进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器(容器必须启动才可进入)\n```\n\n\n\n## 镜像与容器操作\n\n```bash\ndocker container create -it ubuntu:20.04 name # 利用镜像ubuntu:20.04创建一个名为name的容器\ndocker container commit CONTAINER IMAGE_NAME:TAG #创建某个container的镜像\ndocker run -p 20000:22 --name NAME -itd docker:1.0  # 利用docker:1.0镜像创建一个名为NAME的容器并运行容器, 并将主机20000端口映射到容器22\n```\n\n","source":"_posts/docker总结.md","raw":"---\ntitle: docker|常用命令\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - docker\n  - linux\ncategories:\n  - 知识总结\nabbrlink: 1146830909\ndate: 2022-07-02 11:27:31\npassword:\nsummary:\n---\n\n> 将当前用户添加到docker用户组\n>\n> 为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组（可以参考官方文档）：\n>\n> `sudo usermod -aG docker $USER`\n>\n> 执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。\n\n# 镜像（images）\n\n`docker pull ubuntu:20.04`：拉取一个镜像\n\n`docker images`：列出本地所有镜像\n\n`docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04`：删除镜像ubuntu:20.04\n\n`docker [container] commit CONTAINER IMAGE_NAME:TAG`：创建某个container的镜像\n\n`docker save -o ubuntu_20_04.tar ubuntu:20.04`：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中\n\n`docker load -i ubuntu_20_04.tar`：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来\n\n# 容器（container）\n\n`docker [container] create -it ubuntu:20.04`：利用镜像ubuntu:20.04创建一个容器。\n\n`docker ps -a`：查看本地的所有容器\n\n`docker [container] start CONTAINER`：启动容器\n\n`docker [container] stop CONTAINER`：停止容器\n\n`docker [container] restart CONTAINER`：重启容器\n\n`docker [contaienr] run -itd ubuntu:20.04`：创建并启动一个容器\n\n`docker [container] attach CONTAINER`：进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器\n\n`docker [container] exec CONTAINER COMMAND`：在容器中执行命令\n\n`docker [container] rm CONTAINER`：删除容器\n\n`docker container prune`：删除所有已停止的容器\n\n`docker export -o xxx.tar CONTAINER`：将容器CONTAINER导出到本地文件xxx.tar中\n\n`docker import xxx.tar image_name:tag`：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag\n\n`docker export/import`与`docker save/load`的区别：\n\n- export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态\n\n- save/load会保存完整记录，体积更大\n\n`docker top CONTAINER`：查看某个容器内的所有进程\n\n`docker stats`：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息\n\n`docker cp xxx CONTAINER:xxx` 或 `docker cp CONTAINER:xxx xxx`：在本地和容器间复制文件\n\n`docker rename CONTAINER1 CONTAINER2`：重命名容器\n\n`docker update CONTAINER --memory 500MB`：修改容器限制\n\n# 示例\n\n\n\n```bash\nscp docker_1_0.tar server_name  # 将镜像上传到自己租的云端服务器\n\nssh server_name  # 登录自己的云端服务器\n\ndocker load -i docker_1_0.tar  # 将镜像加载到本地\n\ndocker run -p 20000:22 --name my_docker_server -itd docker:1.0  # 创建并运行docker:1.0镜像, 20000端口映射到22\n\ndocker attach my_docker_server  # 进入创建的docker容器\n```\n\n\n\n# 常用操作\n\n## 查询\n\n```bash\ndocker images # 列出本地所有镜像\ndocker ps -a # 列出本地所有容器\ndocker ps # 列出运行中的容器\n```\n\n## 镜像操作\n\n```bash\ndocker pull ubuntu:20.04 # 拉取一个镜像\ndocker image rm ubuntu:20.04 # 删除一个镜像\n\n```\n\n\n\n## 容器操作\n\n```bash\ndocker container start CONTAINER #启动容器\ndocker container stop CONTAINER #停止容器\ndocker container attach CONTAINER #进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器(容器必须启动才可进入)\n```\n\n\n\n## 镜像与容器操作\n\n```bash\ndocker container create -it ubuntu:20.04 name # 利用镜像ubuntu:20.04创建一个名为name的容器\ndocker container commit CONTAINER IMAGE_NAME:TAG #创建某个container的镜像\ndocker run -p 20000:22 --name NAME -itd docker:1.0  # 利用docker:1.0镜像创建一个名为NAME的容器并运行容器, 并将主机20000端口映射到容器22\n```\n\n","slug":"docker总结","published":1,"updated":"2022-08-06T07:10:18.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhc000z6kuhf8w59a4h","content":"<blockquote>\n<p>将当前用户添加到docker用户组</p>\n<p>为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组（可以参考官方文档）：</p>\n<p><code>sudo usermod -aG docker $USER</code></p>\n<p>执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。</p>\n</blockquote>\n<h1 id=\"镜像（images）\"><a href=\"#镜像（images）\" class=\"headerlink\" title=\"镜像（images）\"></a>镜像（images）</h1><p><code>docker pull ubuntu:20.04</code>：拉取一个镜像</p>\n<p><code>docker images</code>：列出本地所有镜像</p>\n<p><code>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04</code>：删除镜像ubuntu:20.04</p>\n<p><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>：创建某个container的镜像</p>\n<p><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中</p>\n<p><code>docker load -i ubuntu_20_04.tar</code>：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来</p>\n<h1 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h1><p><code>docker [container] create -it ubuntu:20.04</code>：利用镜像ubuntu:20.04创建一个容器。</p>\n<p><code>docker ps -a</code>：查看本地的所有容器</p>\n<p><code>docker [container] start CONTAINER</code>：启动容器</p>\n<p><code>docker [container] stop CONTAINER</code>：停止容器</p>\n<p><code>docker [container] restart CONTAINER</code>：重启容器</p>\n<p><code>docker [contaienr] run -itd ubuntu:20.04</code>：创建并启动一个容器</p>\n<p><code>docker [container] attach CONTAINER</code>：进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器</p>\n<p><code>docker [container] exec CONTAINER COMMAND</code>：在容器中执行命令</p>\n<p><code>docker [container] rm CONTAINER</code>：删除容器</p>\n<p><code>docker container prune</code>：删除所有已停止的容器</p>\n<p><code>docker export -o xxx.tar CONTAINER</code>：将容器CONTAINER导出到本地文件xxx.tar中</p>\n<p><code>docker import xxx.tar image_name:tag</code>：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag</p>\n<p><code>docker export/import</code>与<code>docker save/load</code>的区别：</p>\n<ul>\n<li><p>export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态</p>\n</li>\n<li><p>save/load会保存完整记录，体积更大</p>\n</li>\n</ul>\n<p><code>docker top CONTAINER</code>：查看某个容器内的所有进程</p>\n<p><code>docker stats</code>：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息</p>\n<p><code>docker cp xxx CONTAINER:xxx</code> 或 <code>docker cp CONTAINER:xxx xxx</code>：在本地和容器间复制文件</p>\n<p><code>docker rename CONTAINER1 CONTAINER2</code>：重命名容器</p>\n<p><code>docker update CONTAINER --memory 500MB</code>：修改容器限制</p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">scp</span> docker_1_0.tar server_name  <span class=\"token comment\" spellcheck=\"true\"># 将镜像上传到自己租的云端服务器</span>\n\n<span class=\"token function\">ssh</span> server_name  <span class=\"token comment\" spellcheck=\"true\"># 登录自己的云端服务器</span>\n\ndocker load -i docker_1_0.tar  <span class=\"token comment\" spellcheck=\"true\"># 将镜像加载到本地</span>\n\ndocker run -p 20000:22 --name my_docker_server -itd docker:1.0  <span class=\"token comment\" spellcheck=\"true\"># 创建并运行docker:1.0镜像, 20000端口映射到22</span>\n\ndocker attach my_docker_server  <span class=\"token comment\" spellcheck=\"true\"># 进入创建的docker容器</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h1><h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker images <span class=\"token comment\" spellcheck=\"true\"># 列出本地所有镜像</span>\ndocker <span class=\"token function\">ps</span> -a <span class=\"token comment\" spellcheck=\"true\"># 列出本地所有容器</span>\ndocker <span class=\"token function\">ps</span> <span class=\"token comment\" spellcheck=\"true\"># 列出运行中的容器</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"镜像操作\"><a href=\"#镜像操作\" class=\"headerlink\" title=\"镜像操作\"></a>镜像操作</h2><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker pull ubuntu:20.04 <span class=\"token comment\" spellcheck=\"true\"># 拉取一个镜像</span>\ndocker image <span class=\"token function\">rm</span> ubuntu:20.04 <span class=\"token comment\" spellcheck=\"true\"># 删除一个镜像</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"容器操作\"><a href=\"#容器操作\" class=\"headerlink\" title=\"容器操作\"></a>容器操作</h2><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker container start CONTAINER <span class=\"token comment\" spellcheck=\"true\">#启动容器</span>\ndocker container stop CONTAINER <span class=\"token comment\" spellcheck=\"true\">#停止容器</span>\ndocker container attach CONTAINER <span class=\"token comment\" spellcheck=\"true\">#进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器(容器必须启动才可进入)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"镜像与容器操作\"><a href=\"#镜像与容器操作\" class=\"headerlink\" title=\"镜像与容器操作\"></a>镜像与容器操作</h2><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker container create -it ubuntu:20.04 name <span class=\"token comment\" spellcheck=\"true\"># 利用镜像ubuntu:20.04创建一个名为name的容器</span>\ndocker container commit CONTAINER IMAGE_NAME:TAG <span class=\"token comment\" spellcheck=\"true\">#创建某个container的镜像</span>\ndocker run -p 20000:22 --name NAME -itd docker:1.0  <span class=\"token comment\" spellcheck=\"true\"># 利用docker:1.0镜像创建一个名为NAME的容器并运行容器, 并将主机20000端口映射到容器22</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<blockquote>\n<p>将当前用户添加到docker用户组</p>\n<p>为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组（可以参考官方文档）：</p>\n<p><code>sudo usermod -aG docker $USER</code></p>\n<p>执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。</p>\n</blockquote>\n<h1 id=\"镜像（images）\"><a href=\"#镜像（images）\" class=\"headerlink\" title=\"镜像（images）\"></a>镜像（images）</h1><p><code>docker pull ubuntu:20.04</code>：拉取一个镜像</p>\n<p><code>docker images</code>：列出本地所有镜像</p>\n<p><code>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04</code>：删除镜像ubuntu:20.04</p>\n<p><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>：创建某个container的镜像</p>\n<p><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中</p>\n<p><code>docker load -i ubuntu_20_04.tar</code>：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来</p>\n<h1 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h1><p><code>docker [container] create -it ubuntu:20.04</code>：利用镜像ubuntu:20.04创建一个容器。</p>\n<p><code>docker ps -a</code>：查看本地的所有容器</p>\n<p><code>docker [container] start CONTAINER</code>：启动容器</p>\n<p><code>docker [container] stop CONTAINER</code>：停止容器</p>\n<p><code>docker [container] restart CONTAINER</code>：重启容器</p>\n<p><code>docker [contaienr] run -itd ubuntu:20.04</code>：创建并启动一个容器</p>\n<p><code>docker [container] attach CONTAINER</code>：进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器</p>\n<p><code>docker [container] exec CONTAINER COMMAND</code>：在容器中执行命令</p>\n<p><code>docker [container] rm CONTAINER</code>：删除容器</p>\n<p><code>docker container prune</code>：删除所有已停止的容器</p>\n<p><code>docker export -o xxx.tar CONTAINER</code>：将容器CONTAINER导出到本地文件xxx.tar中</p>\n<p><code>docker import xxx.tar image_name:tag</code>：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag</p>\n<p><code>docker export/import</code>与<code>docker save/load</code>的区别：</p>\n<ul>\n<li><p>export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态</p>\n</li>\n<li><p>save/load会保存完整记录，体积更大</p>\n</li>\n</ul>\n<p><code>docker top CONTAINER</code>：查看某个容器内的所有进程</p>\n<p><code>docker stats</code>：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息</p>\n<p><code>docker cp xxx CONTAINER:xxx</code> 或 <code>docker cp CONTAINER:xxx xxx</code>：在本地和容器间复制文件</p>\n<p><code>docker rename CONTAINER1 CONTAINER2</code>：重命名容器</p>\n<p><code>docker update CONTAINER --memory 500MB</code>：修改容器限制</p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><pre><code class=\"bash\">scp docker_1_0.tar server_name  # 将镜像上传到自己租的云端服务器\n\nssh server_name  # 登录自己的云端服务器\n\ndocker load -i docker_1_0.tar  # 将镜像加载到本地\n\ndocker run -p 20000:22 --name my_docker_server -itd docker:1.0  # 创建并运行docker:1.0镜像, 20000端口映射到22\n\ndocker attach my_docker_server  # 进入创建的docker容器</code></pre>\n<h1 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h1><h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><pre><code class=\"bash\">docker images # 列出本地所有镜像\ndocker ps -a # 列出本地所有容器\ndocker ps # 列出运行中的容器</code></pre>\n<h2 id=\"镜像操作\"><a href=\"#镜像操作\" class=\"headerlink\" title=\"镜像操作\"></a>镜像操作</h2><pre><code class=\"bash\">docker pull ubuntu:20.04 # 拉取一个镜像\ndocker image rm ubuntu:20.04 # 删除一个镜像\n</code></pre>\n<h2 id=\"容器操作\"><a href=\"#容器操作\" class=\"headerlink\" title=\"容器操作\"></a>容器操作</h2><pre><code class=\"bash\">docker container start CONTAINER #启动容器\ndocker container stop CONTAINER #停止容器\ndocker container attach CONTAINER #进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器(容器必须启动才可进入)</code></pre>\n<h2 id=\"镜像与容器操作\"><a href=\"#镜像与容器操作\" class=\"headerlink\" title=\"镜像与容器操作\"></a>镜像与容器操作</h2><pre><code class=\"bash\">docker container create -it ubuntu:20.04 name # 利用镜像ubuntu:20.04创建一个名为name的容器\ndocker container commit CONTAINER IMAGE_NAME:TAG #创建某个container的镜像\ndocker run -p 20000:22 --name NAME -itd docker:1.0  # 利用docker:1.0镜像创建一个名为NAME的容器并运行容器, 并将主机20000端口映射到容器22</code></pre>\n"},{"title":"Git|详解|命令","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1843856130,"date":"2022-06-30T02:14:41.000Z","password":null,"summary":null,"_content":"\n# Git | 详解 | 命令\n\n# 概念\n\nGit是基于树进行维护的，每一个节点都是一个历史版本，可以进行代码管理。\n\n![Git图示](1843856130/webp.webp)\n\n> 工作区（Workspace） \n>\n> 暂存区（Index / Stage）  \n>\n> 本地仓库（Repository）  \n>\n> 远程仓库（Remote）\n\n\n\n# 常用命令\n\n`git config [--global] user.name xxx`：设置全局用户名，信息记录在`~/.gitconfig`文件中\n\n`git config [--global] user.email xxx@xxx.com`：设置全局邮箱地址，信息记录在`~/.gitconfig`文件中\n\n`git init`：将当前目录配置成git仓库，信息记录在隐藏的`.git`文件夹中\n\n`git status`：显示有变更的文件\n\n`git add .`：将当前工作区的所有文件的修改信息加入**暂存区**\n\n`git log`：查看当前分支的所有版本\n\n`git remote add origin git@github.com:XXX/XXX.git`：将本地仓库关联到远程仓库\n\n`git clone git@github.com:XXX/XXX.git`：将远程仓库XXX下载到当前目录下\n\n`git branch --set-upstream-to=origin/branch_name1 branch_name2`：将远程的branch_name1分支与本地的branch_name2分支对应\n\n`git push -u ` （第一次需要-u以后不需要）：将当前分支推送到远程仓库\n\n`git pull`：将远程仓库的当前分支与本地仓库的当前分支合并\n\n\n\n# 配置\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n`git config --list` : 显示当前的Git配置\n\n`git config -e [--global]` : 编辑Git配置文件\n\n`git config [--global] user.name xxx`：设置全局用户名，信息记录在`~/.gitconfig`文件中\n\n`git config [--global] user.email xxx@xxx.com`：设置全局邮箱地址，信息记录在`~/.gitconfig`文件中\n\n`git init`：将当前目录配置成git仓库，信息记录在隐藏的`.git`文件夹中\n\n# 工作区\n\n`git status`：显示有变更的文件\n\n`git restore XXX` : 将工作区的XXX文件的修改（该修改未添加到暂存区）恢复\n\n`git add XX`：将XX文件的 **修改信息** 添加到**暂存区**\n\n`git add .`：将当前工作区的所有文件的修改信息加入**暂存区**\n\n`git rm [file1] [file2] ...` : 删除工作区文件，并把这次删除加入到暂存区\n\n`git diff XX`：查看XX文件相对于暂存区修改了哪些内容\n\n`git checkout — XX`或`git restore XX`：将XX文件尚未加入暂存区的修改全部撤销\n\n> 更多撤销操作见下文 【撤销回退】\n\n#  暂存区\n\n`git rm --cached XX`：将文件XX从暂存区中删掉，停止追踪指定文件，但该文件会保留在工作区\n\n`git restore --staged XXX` ： 将**暂存区**的XXX清空，工作区**不变**\n\n`git commit -m \"给自己看的备注信息\"`：将**暂存区**的内容提交到当前分支（可持久化）\n\n`git checkout [file] `: 恢复暂存区的指定文件到工作区（工作区文件发生改变）\n\n`git reset [file]` : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n> 更多撤销操作见下文 【撤销回退】\n\n# 分支\n\n## 本地分支\n\n`git branch `: 列出所有本地分支\n\n`git branch branch_name`：创建新分支，但依然停留在当前分支\n\n`git checkout branch_name`：切换到branch_name这个分支，并更新工作区\n\n`git checkout -b branch_name`：创建并切换到branch_name这个分支\n\n`git branch -m oldBranchName newBranchName` ： 修改本地分支名字\n\n`git merge branch_name`：将分支branch_name合并到当前分支上\n\n`git checkout - `： 切换到上一个分支\n\n`git cherry-pick [commit]` ： 选择一个commit，合并进当前分支\n\n`git branch -d branch_name`：删除本地仓库的branch_name分支\n\n## 远程分支\n\n`git branch -r` : 列出所有远程分支\n\n`git branch [branch] [commit] `： 新建一个分支，指向指定commit\n\n`git push origin --delete [branch-name]` ： 删除远程分支\n\n`git branch -dr [remote/branch]` ： 删除远程分支\n\n## 本地和远程\n\n`git branch -a` ： 列出所有本地分支和远程分支\n\n`git branch --track [branch] [remote-branch]` ： 新建一个分支，与指定的远程分支建立追踪关系\n\n`git branch --set-upstream [branch] [remote-branch]` ： 建立追踪关系，在现有分支与指定的远程分支之间 （现在已经不支持）\n\n`git branch --set-upstream-to=origin/branch_name1 branch_name2`：将远程的branch_name1分支与本地的branch_name2分支对应\n\n# 信息查看\n\n`git log`：查看当前分支的所有版本\n\n`git reflog`：查看HEAD指针的移动历史（包括被回滚的版本）\n\n`git status` : 显示有变更的文件\n\n`git log --stat` : 显示commit历史，以及每次commit发生变更的文件\n\n`git log -S [keyword] `: 搜索提交历史，根据关键词\n\n`git log [tag] HEAD --pretty=format:%s` : 显示某个commit之后的所有变动，每个commit占据一行\n\n`git log [tag] HEAD --grep feature` : 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n`git log --follow [file] `: 显示某个文件的版本历史，包括文件改名\n\n`git whatchanged [file]` : 显示某个文件的版本历史，包括文件改名\n\n`git log -p [file]` : 显示指定文件相关的每一次diff\n\n`git log -5 --pretty --oneline `: 显示过去5次提交\n\n`git shortlog -sn` : 显示所有提交过的用户，按提交次数排序\n\n`git blame [file]` : 显示指定文件是什么人在什么时间修改过\n\n`git diff` : 显示暂存区和工作区的差异\n\n`git diff --cached [file]` : 显示暂存区和上一个commit的差异\n\n`git diff HEAD `: 显示工作区与当前分支最新commit之间的差异\n\n`git diff [first-branch]...[second-branch] `: 显示两次提交之间的差异\n\n`git diff --shortstat \"@{0 day ago}\"` : 显示今天你写了多少行代码\n\n`git show [commit]` : 显示某次提交的元数据和内容变化\n\n`git show --name-only [commit] `: 显示某次提交发生变化的文件\n\n`git show [commit]:[filename]` : 显示某次提交时，某个文件的内容\n\n# 远程同步\n\n`git remote add origin git@github.com:xxx/XXX.git`：将本地仓库关联到远程仓库\n\n`git push -u ` （第一次需要-u以后不需要）：将当前分支推送到远程仓库\n\n`git push origin branch_name`：将本地的某个分支推送到远程仓库\n\n`git clone git@github.com:anda522/XXX.git`：将远程仓库XXX下载到当前目录下\n\n`git pull`：将远程仓库的当前分支与本地仓库的当前分支合并\n\n`git pull origin branch_name`：将远程仓库的branch_name分支与本地仓库的当前分支合并\n\n`git push --set-upstream origin branch_name`：设置本地的branch_name分支对应远程仓库的branch_name分支\n\n`git push -d origin branch_name`：删除远程仓库的branch_name分支\n\n`git checkout -t origin/branch_name`: 将远程的branch_name分支拉取到本地\n\n# 撤销回退\n\n`git reset --hard `: 重置暂存区与工作区，与上一次commit保持一致\n\n`git reset --hard HEAD^` 或 `git reset --hard HEAD~`：将代码库回滚到上一个版本\n\n`git reset --hard HEAD^^`：往上回滚两次，以此类推\n\n`git reset --hard HEAD~100`：往上回滚100个版本\n\n`git reset --hard 版本号`：回滚到某一特定版本\n\n`git stash`：将工作区和暂存区中尚未提交的修改存入栈中\n\n`git stash apply`：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素\n\n`git stash drop`：删除栈顶存储的修改\n\n`git stash pop`：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素\n\n`git stash list`：查看栈中所有元素\n\n`git checkout [file] `: 恢复暂存区的指定文件到工作区\n\n`git checkout [commit] [file]` : 恢复某个commit的指定文件到暂存区和工作区\n\n`git checkout .` : 恢复暂存区的所有文件到工作区\n\n`git reset [file]` : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n`git reset [commit] `: 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n\n`git reset --hard [commit]` : 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n\n`git reset --keep [commit]` : 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n\n`git revert [commit]` : 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支\n\n\n\n","source":"_posts/git命令总结.md","raw":"---\ntitle: Git|详解|命令\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - git\ncategories:\n  - 知识总结\nabbrlink: 1843856130\ndate: 2022-06-30 10:14:41\npassword:\nsummary:\n---\n\n# Git | 详解 | 命令\n\n# 概念\n\nGit是基于树进行维护的，每一个节点都是一个历史版本，可以进行代码管理。\n\n![Git图示](1843856130/webp.webp)\n\n> 工作区（Workspace） \n>\n> 暂存区（Index / Stage）  \n>\n> 本地仓库（Repository）  \n>\n> 远程仓库（Remote）\n\n\n\n# 常用命令\n\n`git config [--global] user.name xxx`：设置全局用户名，信息记录在`~/.gitconfig`文件中\n\n`git config [--global] user.email xxx@xxx.com`：设置全局邮箱地址，信息记录在`~/.gitconfig`文件中\n\n`git init`：将当前目录配置成git仓库，信息记录在隐藏的`.git`文件夹中\n\n`git status`：显示有变更的文件\n\n`git add .`：将当前工作区的所有文件的修改信息加入**暂存区**\n\n`git log`：查看当前分支的所有版本\n\n`git remote add origin git@github.com:XXX/XXX.git`：将本地仓库关联到远程仓库\n\n`git clone git@github.com:XXX/XXX.git`：将远程仓库XXX下载到当前目录下\n\n`git branch --set-upstream-to=origin/branch_name1 branch_name2`：将远程的branch_name1分支与本地的branch_name2分支对应\n\n`git push -u ` （第一次需要-u以后不需要）：将当前分支推送到远程仓库\n\n`git pull`：将远程仓库的当前分支与本地仓库的当前分支合并\n\n\n\n# 配置\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n`git config --list` : 显示当前的Git配置\n\n`git config -e [--global]` : 编辑Git配置文件\n\n`git config [--global] user.name xxx`：设置全局用户名，信息记录在`~/.gitconfig`文件中\n\n`git config [--global] user.email xxx@xxx.com`：设置全局邮箱地址，信息记录在`~/.gitconfig`文件中\n\n`git init`：将当前目录配置成git仓库，信息记录在隐藏的`.git`文件夹中\n\n# 工作区\n\n`git status`：显示有变更的文件\n\n`git restore XXX` : 将工作区的XXX文件的修改（该修改未添加到暂存区）恢复\n\n`git add XX`：将XX文件的 **修改信息** 添加到**暂存区**\n\n`git add .`：将当前工作区的所有文件的修改信息加入**暂存区**\n\n`git rm [file1] [file2] ...` : 删除工作区文件，并把这次删除加入到暂存区\n\n`git diff XX`：查看XX文件相对于暂存区修改了哪些内容\n\n`git checkout — XX`或`git restore XX`：将XX文件尚未加入暂存区的修改全部撤销\n\n> 更多撤销操作见下文 【撤销回退】\n\n#  暂存区\n\n`git rm --cached XX`：将文件XX从暂存区中删掉，停止追踪指定文件，但该文件会保留在工作区\n\n`git restore --staged XXX` ： 将**暂存区**的XXX清空，工作区**不变**\n\n`git commit -m \"给自己看的备注信息\"`：将**暂存区**的内容提交到当前分支（可持久化）\n\n`git checkout [file] `: 恢复暂存区的指定文件到工作区（工作区文件发生改变）\n\n`git reset [file]` : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n> 更多撤销操作见下文 【撤销回退】\n\n# 分支\n\n## 本地分支\n\n`git branch `: 列出所有本地分支\n\n`git branch branch_name`：创建新分支，但依然停留在当前分支\n\n`git checkout branch_name`：切换到branch_name这个分支，并更新工作区\n\n`git checkout -b branch_name`：创建并切换到branch_name这个分支\n\n`git branch -m oldBranchName newBranchName` ： 修改本地分支名字\n\n`git merge branch_name`：将分支branch_name合并到当前分支上\n\n`git checkout - `： 切换到上一个分支\n\n`git cherry-pick [commit]` ： 选择一个commit，合并进当前分支\n\n`git branch -d branch_name`：删除本地仓库的branch_name分支\n\n## 远程分支\n\n`git branch -r` : 列出所有远程分支\n\n`git branch [branch] [commit] `： 新建一个分支，指向指定commit\n\n`git push origin --delete [branch-name]` ： 删除远程分支\n\n`git branch -dr [remote/branch]` ： 删除远程分支\n\n## 本地和远程\n\n`git branch -a` ： 列出所有本地分支和远程分支\n\n`git branch --track [branch] [remote-branch]` ： 新建一个分支，与指定的远程分支建立追踪关系\n\n`git branch --set-upstream [branch] [remote-branch]` ： 建立追踪关系，在现有分支与指定的远程分支之间 （现在已经不支持）\n\n`git branch --set-upstream-to=origin/branch_name1 branch_name2`：将远程的branch_name1分支与本地的branch_name2分支对应\n\n# 信息查看\n\n`git log`：查看当前分支的所有版本\n\n`git reflog`：查看HEAD指针的移动历史（包括被回滚的版本）\n\n`git status` : 显示有变更的文件\n\n`git log --stat` : 显示commit历史，以及每次commit发生变更的文件\n\n`git log -S [keyword] `: 搜索提交历史，根据关键词\n\n`git log [tag] HEAD --pretty=format:%s` : 显示某个commit之后的所有变动，每个commit占据一行\n\n`git log [tag] HEAD --grep feature` : 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n`git log --follow [file] `: 显示某个文件的版本历史，包括文件改名\n\n`git whatchanged [file]` : 显示某个文件的版本历史，包括文件改名\n\n`git log -p [file]` : 显示指定文件相关的每一次diff\n\n`git log -5 --pretty --oneline `: 显示过去5次提交\n\n`git shortlog -sn` : 显示所有提交过的用户，按提交次数排序\n\n`git blame [file]` : 显示指定文件是什么人在什么时间修改过\n\n`git diff` : 显示暂存区和工作区的差异\n\n`git diff --cached [file]` : 显示暂存区和上一个commit的差异\n\n`git diff HEAD `: 显示工作区与当前分支最新commit之间的差异\n\n`git diff [first-branch]...[second-branch] `: 显示两次提交之间的差异\n\n`git diff --shortstat \"@{0 day ago}\"` : 显示今天你写了多少行代码\n\n`git show [commit]` : 显示某次提交的元数据和内容变化\n\n`git show --name-only [commit] `: 显示某次提交发生变化的文件\n\n`git show [commit]:[filename]` : 显示某次提交时，某个文件的内容\n\n# 远程同步\n\n`git remote add origin git@github.com:xxx/XXX.git`：将本地仓库关联到远程仓库\n\n`git push -u ` （第一次需要-u以后不需要）：将当前分支推送到远程仓库\n\n`git push origin branch_name`：将本地的某个分支推送到远程仓库\n\n`git clone git@github.com:anda522/XXX.git`：将远程仓库XXX下载到当前目录下\n\n`git pull`：将远程仓库的当前分支与本地仓库的当前分支合并\n\n`git pull origin branch_name`：将远程仓库的branch_name分支与本地仓库的当前分支合并\n\n`git push --set-upstream origin branch_name`：设置本地的branch_name分支对应远程仓库的branch_name分支\n\n`git push -d origin branch_name`：删除远程仓库的branch_name分支\n\n`git checkout -t origin/branch_name`: 将远程的branch_name分支拉取到本地\n\n# 撤销回退\n\n`git reset --hard `: 重置暂存区与工作区，与上一次commit保持一致\n\n`git reset --hard HEAD^` 或 `git reset --hard HEAD~`：将代码库回滚到上一个版本\n\n`git reset --hard HEAD^^`：往上回滚两次，以此类推\n\n`git reset --hard HEAD~100`：往上回滚100个版本\n\n`git reset --hard 版本号`：回滚到某一特定版本\n\n`git stash`：将工作区和暂存区中尚未提交的修改存入栈中\n\n`git stash apply`：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素\n\n`git stash drop`：删除栈顶存储的修改\n\n`git stash pop`：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素\n\n`git stash list`：查看栈中所有元素\n\n`git checkout [file] `: 恢复暂存区的指定文件到工作区\n\n`git checkout [commit] [file]` : 恢复某个commit的指定文件到暂存区和工作区\n\n`git checkout .` : 恢复暂存区的所有文件到工作区\n\n`git reset [file]` : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n\n`git reset [commit] `: 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n\n`git reset --hard [commit]` : 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n\n`git reset --keep [commit]` : 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n\n`git revert [commit]` : 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支\n\n\n\n","slug":"git命令总结","published":1,"updated":"2022-08-04T07:09:16.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhe00136kuhpapkpswn","content":"<h1 id=\"Git-详解-命令\"><a href=\"#Git-详解-命令\" class=\"headerlink\" title=\"Git | 详解 | 命令\"></a>Git | 详解 | 命令</h1><h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>Git是基于树进行维护的，每一个节点都是一个历史版本，可以进行代码管理。</p>\n<p><img src=\"1843856130/webp.webp\" alt=\"Git图示\"></p>\n<blockquote>\n<p>工作区（Workspace） </p>\n<p>暂存区（Index / Stage）  </p>\n<p>本地仓库（Repository）  </p>\n<p>远程仓库（Remote）</p>\n</blockquote>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p><code>git config [--global] user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git config [--global] user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中</p>\n<p><code>git status</code>：显示有变更的文件</p>\n<p><code>git add .</code>：将当前工作区的所有文件的修改信息加入<strong>暂存区</strong></p>\n<p><code>git log</code>：查看当前分支的所有版本</p>\n<p><code>git remote add origin git@github.com:XXX/XXX.git</code>：将本地仓库关联到远程仓库</p>\n<p><code>git clone git@github.com:XXX/XXX.git</code>：将远程仓库XXX下载到当前目录下</p>\n<p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p>\n<p><code>git push -u</code> （第一次需要-u以后不需要）：将当前分支推送到远程仓库</p>\n<p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<p><code>git config --list</code> : 显示当前的Git配置</p>\n<p><code>git config -e [--global]</code> : 编辑Git配置文件</p>\n<p><code>git config [--global] user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git config [--global] user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中</p>\n<h1 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h1><p><code>git status</code>：显示有变更的文件</p>\n<p><code>git restore XXX</code> : 将工作区的XXX文件的修改（该修改未添加到暂存区）恢复</p>\n<p><code>git add XX</code>：将XX文件的 <strong>修改信息</strong> 添加到<strong>暂存区</strong></p>\n<p><code>git add .</code>：将当前工作区的所有文件的修改信息加入<strong>暂存区</strong></p>\n<p><code>git rm [file1] [file2] ...</code> : 删除工作区文件，并把这次删除加入到暂存区</p>\n<p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p>\n<p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</p>\n<blockquote>\n<p>更多撤销操作见下文 【撤销回退】</p>\n</blockquote>\n<h1 id=\"暂存区\"><a href=\"#暂存区\" class=\"headerlink\" title=\"暂存区\"></a>暂存区</h1><p><code>git rm --cached XX</code>：将文件XX从暂存区中删掉，停止追踪指定文件，但该文件会保留在工作区</p>\n<p><code>git restore --staged XXX</code> ： 将<strong>暂存区</strong>的XXX清空，工作区<strong>不变</strong></p>\n<p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将<strong>暂存区</strong>的内容提交到当前分支（可持久化）</p>\n<p><code>git checkout [file]</code>: 恢复暂存区的指定文件到工作区（工作区文件发生改变）</p>\n<p><code>git reset [file]</code> : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<blockquote>\n<p>更多撤销操作见下文 【撤销回退】</p>\n</blockquote>\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><h2 id=\"本地分支\"><a href=\"#本地分支\" class=\"headerlink\" title=\"本地分支\"></a>本地分支</h2><p><code>git branch</code>: 列出所有本地分支</p>\n<p><code>git branch branch_name</code>：创建新分支，但依然停留在当前分支</p>\n<p><code>git checkout branch_name</code>：切换到branch_name这个分支，并更新工作区</p>\n<p><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</p>\n<p><code>git branch -m oldBranchName newBranchName</code> ： 修改本地分支名字</p>\n<p><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</p>\n<p><code>git checkout -</code>： 切换到上一个分支</p>\n<p><code>git cherry-pick [commit]</code> ： 选择一个commit，合并进当前分支</p>\n<p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p>\n<h2 id=\"远程分支\"><a href=\"#远程分支\" class=\"headerlink\" title=\"远程分支\"></a>远程分支</h2><p><code>git branch -r</code> : 列出所有远程分支</p>\n<p><code>git branch [branch] [commit]</code>： 新建一个分支，指向指定commit</p>\n<p><code>git push origin --delete [branch-name]</code> ： 删除远程分支</p>\n<p><code>git branch -dr [remote/branch]</code> ： 删除远程分支</p>\n<h2 id=\"本地和远程\"><a href=\"#本地和远程\" class=\"headerlink\" title=\"本地和远程\"></a>本地和远程</h2><p><code>git branch -a</code> ： 列出所有本地分支和远程分支</p>\n<p><code>git branch --track [branch] [remote-branch]</code> ： 新建一个分支，与指定的远程分支建立追踪关系</p>\n<p><code>git branch --set-upstream [branch] [remote-branch]</code> ： 建立追踪关系，在现有分支与指定的远程分支之间 （现在已经不支持）</p>\n<p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p>\n<h1 id=\"信息查看\"><a href=\"#信息查看\" class=\"headerlink\" title=\"信息查看\"></a>信息查看</h1><p><code>git log</code>：查看当前分支的所有版本</p>\n<p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p>\n<p><code>git status</code> : 显示有变更的文件</p>\n<p><code>git log --stat</code> : 显示commit历史，以及每次commit发生变更的文件</p>\n<p><code>git log -S [keyword]</code>: 搜索提交历史，根据关键词</p>\n<p><code>git log [tag] HEAD --pretty=format:%s</code> : 显示某个commit之后的所有变动，每个commit占据一行</p>\n<p><code>git log [tag] HEAD --grep feature</code> : 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>\n<p><code>git log --follow [file]</code>: 显示某个文件的版本历史，包括文件改名</p>\n<p><code>git whatchanged [file]</code> : 显示某个文件的版本历史，包括文件改名</p>\n<p><code>git log -p [file]</code> : 显示指定文件相关的每一次diff</p>\n<p><code>git log -5 --pretty --oneline</code>: 显示过去5次提交</p>\n<p><code>git shortlog -sn</code> : 显示所有提交过的用户，按提交次数排序</p>\n<p><code>git blame [file]</code> : 显示指定文件是什么人在什么时间修改过</p>\n<p><code>git diff</code> : 显示暂存区和工作区的差异</p>\n<p><code>git diff --cached [file]</code> : 显示暂存区和上一个commit的差异</p>\n<p><code>git diff HEAD</code>: 显示工作区与当前分支最新commit之间的差异</p>\n<p><code>git diff [first-branch]...[second-branch]</code>: 显示两次提交之间的差异</p>\n<p><code>git diff --shortstat &quot;@{0 day ago}&quot;</code> : 显示今天你写了多少行代码</p>\n<p><code>git show [commit]</code> : 显示某次提交的元数据和内容变化</p>\n<p><code>git show --name-only [commit]</code>: 显示某次提交发生变化的文件</p>\n<p><code>git show [commit]:[filename]</code> : 显示某次提交时，某个文件的内容</p>\n<h1 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h1><p><code>git remote add origin git@github.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p>\n<p><code>git push -u</code> （第一次需要-u以后不需要）：将当前分支推送到远程仓库</p>\n<p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p>\n<p><code>git clone git@github.com:anda522/XXX.git</code>：将远程仓库XXX下载到当前目录下</p>\n<p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p>\n<p><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</p>\n<p><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</p>\n<p><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</p>\n<p><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地</p>\n<h1 id=\"撤销回退\"><a href=\"#撤销回退\" class=\"headerlink\" title=\"撤销回退\"></a>撤销回退</h1><p><code>git reset --hard</code>: 重置暂存区与工作区，与上一次commit保持一致</p>\n<p><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p>\n<p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p>\n<p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p>\n<p><code>git reset --hard 版本号</code>：回滚到某一特定版本</p>\n<p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p>\n<p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p>\n<p><code>git stash drop</code>：删除栈顶存储的修改</p>\n<p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p>\n<p><code>git stash list</code>：查看栈中所有元素</p>\n<p><code>git checkout [file]</code>: 恢复暂存区的指定文件到工作区</p>\n<p><code>git checkout [commit] [file]</code> : 恢复某个commit的指定文件到暂存区和工作区</p>\n<p><code>git checkout .</code> : 恢复暂存区的所有文件到工作区</p>\n<p><code>git reset [file]</code> : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<p><code>git reset [commit]</code>: 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>\n<p><code>git reset --hard [commit]</code> : 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>\n<p><code>git reset --keep [commit]</code> : 重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>\n<p><code>git revert [commit]</code> : 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"Git-详解-命令\"><a href=\"#Git-详解-命令\" class=\"headerlink\" title=\"Git | 详解 | 命令\"></a>Git | 详解 | 命令</h1><h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>Git是基于树进行维护的，每一个节点都是一个历史版本，可以进行代码管理。</p>\n<p><img src=\"1843856130/webp.webp\" alt=\"Git图示\"></p>\n<blockquote>\n<p>工作区（Workspace） </p>\n<p>暂存区（Index / Stage）  </p>\n<p>本地仓库（Repository）  </p>\n<p>远程仓库（Remote）</p>\n</blockquote>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p><code>git config [--global] user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git config [--global] user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中</p>\n<p><code>git status</code>：显示有变更的文件</p>\n<p><code>git add .</code>：将当前工作区的所有文件的修改信息加入<strong>暂存区</strong></p>\n<p><code>git log</code>：查看当前分支的所有版本</p>\n<p><code>git remote add origin git@github.com:XXX/XXX.git</code>：将本地仓库关联到远程仓库</p>\n<p><code>git clone git@github.com:XXX/XXX.git</code>：将远程仓库XXX下载到当前目录下</p>\n<p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p>\n<p><code>git push -u</code> （第一次需要-u以后不需要）：将当前分支推送到远程仓库</p>\n<p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<p><code>git config --list</code> : 显示当前的Git配置</p>\n<p><code>git config -e [--global]</code> : 编辑Git配置文件</p>\n<p><code>git config [--global] user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git config [--global] user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p>\n<p><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的<code>.git</code>文件夹中</p>\n<h1 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h1><p><code>git status</code>：显示有变更的文件</p>\n<p><code>git restore XXX</code> : 将工作区的XXX文件的修改（该修改未添加到暂存区）恢复</p>\n<p><code>git add XX</code>：将XX文件的 <strong>修改信息</strong> 添加到<strong>暂存区</strong></p>\n<p><code>git add .</code>：将当前工作区的所有文件的修改信息加入<strong>暂存区</strong></p>\n<p><code>git rm [file1] [file2] ...</code> : 删除工作区文件，并把这次删除加入到暂存区</p>\n<p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p>\n<p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</p>\n<blockquote>\n<p>更多撤销操作见下文 【撤销回退】</p>\n</blockquote>\n<h1 id=\"暂存区\"><a href=\"#暂存区\" class=\"headerlink\" title=\"暂存区\"></a>暂存区</h1><p><code>git rm --cached XX</code>：将文件XX从暂存区中删掉，停止追踪指定文件，但该文件会保留在工作区</p>\n<p><code>git restore --staged XXX</code> ： 将<strong>暂存区</strong>的XXX清空，工作区<strong>不变</strong></p>\n<p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将<strong>暂存区</strong>的内容提交到当前分支（可持久化）</p>\n<p><code>git checkout [file]</code>: 恢复暂存区的指定文件到工作区（工作区文件发生改变）</p>\n<p><code>git reset [file]</code> : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<blockquote>\n<p>更多撤销操作见下文 【撤销回退】</p>\n</blockquote>\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><h2 id=\"本地分支\"><a href=\"#本地分支\" class=\"headerlink\" title=\"本地分支\"></a>本地分支</h2><p><code>git branch</code>: 列出所有本地分支</p>\n<p><code>git branch branch_name</code>：创建新分支，但依然停留在当前分支</p>\n<p><code>git checkout branch_name</code>：切换到branch_name这个分支，并更新工作区</p>\n<p><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</p>\n<p><code>git branch -m oldBranchName newBranchName</code> ： 修改本地分支名字</p>\n<p><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</p>\n<p><code>git checkout -</code>： 切换到上一个分支</p>\n<p><code>git cherry-pick [commit]</code> ： 选择一个commit，合并进当前分支</p>\n<p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p>\n<h2 id=\"远程分支\"><a href=\"#远程分支\" class=\"headerlink\" title=\"远程分支\"></a>远程分支</h2><p><code>git branch -r</code> : 列出所有远程分支</p>\n<p><code>git branch [branch] [commit]</code>： 新建一个分支，指向指定commit</p>\n<p><code>git push origin --delete [branch-name]</code> ： 删除远程分支</p>\n<p><code>git branch -dr [remote/branch]</code> ： 删除远程分支</p>\n<h2 id=\"本地和远程\"><a href=\"#本地和远程\" class=\"headerlink\" title=\"本地和远程\"></a>本地和远程</h2><p><code>git branch -a</code> ： 列出所有本地分支和远程分支</p>\n<p><code>git branch --track [branch] [remote-branch]</code> ： 新建一个分支，与指定的远程分支建立追踪关系</p>\n<p><code>git branch --set-upstream [branch] [remote-branch]</code> ： 建立追踪关系，在现有分支与指定的远程分支之间 （现在已经不支持）</p>\n<p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p>\n<h1 id=\"信息查看\"><a href=\"#信息查看\" class=\"headerlink\" title=\"信息查看\"></a>信息查看</h1><p><code>git log</code>：查看当前分支的所有版本</p>\n<p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p>\n<p><code>git status</code> : 显示有变更的文件</p>\n<p><code>git log --stat</code> : 显示commit历史，以及每次commit发生变更的文件</p>\n<p><code>git log -S [keyword]</code>: 搜索提交历史，根据关键词</p>\n<p><code>git log [tag] HEAD --pretty=format:%s</code> : 显示某个commit之后的所有变动，每个commit占据一行</p>\n<p><code>git log [tag] HEAD --grep feature</code> : 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>\n<p><code>git log --follow [file]</code>: 显示某个文件的版本历史，包括文件改名</p>\n<p><code>git whatchanged [file]</code> : 显示某个文件的版本历史，包括文件改名</p>\n<p><code>git log -p [file]</code> : 显示指定文件相关的每一次diff</p>\n<p><code>git log -5 --pretty --oneline</code>: 显示过去5次提交</p>\n<p><code>git shortlog -sn</code> : 显示所有提交过的用户，按提交次数排序</p>\n<p><code>git blame [file]</code> : 显示指定文件是什么人在什么时间修改过</p>\n<p><code>git diff</code> : 显示暂存区和工作区的差异</p>\n<p><code>git diff --cached [file]</code> : 显示暂存区和上一个commit的差异</p>\n<p><code>git diff HEAD</code>: 显示工作区与当前分支最新commit之间的差异</p>\n<p><code>git diff [first-branch]...[second-branch]</code>: 显示两次提交之间的差异</p>\n<p><code>git diff --shortstat &quot;@{0 day ago}&quot;</code> : 显示今天你写了多少行代码</p>\n<p><code>git show [commit]</code> : 显示某次提交的元数据和内容变化</p>\n<p><code>git show --name-only [commit]</code>: 显示某次提交发生变化的文件</p>\n<p><code>git show [commit]:[filename]</code> : 显示某次提交时，某个文件的内容</p>\n<h1 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h1><p><code>git remote add origin git@github.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p>\n<p><code>git push -u</code> （第一次需要-u以后不需要）：将当前分支推送到远程仓库</p>\n<p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p>\n<p><code>git clone git@github.com:anda522/XXX.git</code>：将远程仓库XXX下载到当前目录下</p>\n<p><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p>\n<p><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</p>\n<p><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</p>\n<p><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</p>\n<p><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地</p>\n<h1 id=\"撤销回退\"><a href=\"#撤销回退\" class=\"headerlink\" title=\"撤销回退\"></a>撤销回退</h1><p><code>git reset --hard</code>: 重置暂存区与工作区，与上一次commit保持一致</p>\n<p><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p>\n<p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p>\n<p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p>\n<p><code>git reset --hard 版本号</code>：回滚到某一特定版本</p>\n<p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p>\n<p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p>\n<p><code>git stash drop</code>：删除栈顶存储的修改</p>\n<p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p>\n<p><code>git stash list</code>：查看栈中所有元素</p>\n<p><code>git checkout [file]</code>: 恢复暂存区的指定文件到工作区</p>\n<p><code>git checkout [commit] [file]</code> : 恢复某个commit的指定文件到暂存区和工作区</p>\n<p><code>git checkout .</code> : 恢复暂存区的所有文件到工作区</p>\n<p><code>git reset [file]</code> : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>\n<p><code>git reset [commit]</code>: 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>\n<p><code>git reset --hard [commit]</code> : 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>\n<p><code>git reset --keep [commit]</code> : 重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>\n<p><code>git revert [commit]</code> : 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n"},{"title":"Pytorch入门知识总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1888017128,"date":"2022-12-14T13:53:28.000Z","password":null,"summary":null,"_content":"\n# Pytorch深度学习入门知识总结\n\n# GPU相关\n\n检查GPU是否工作\n\n```python\nimport torch\ntorch.cuda.is_available()\n```\n\n# Dataset\n\n可以继承Dataset来制作自己的数据类\n\n```python\nfrom torch.utils.data import Dataset\nfrom PIL import Image\nimport os\n\n\nclass MyData(Dataset):\n    \"\"\"\n    For example:\n    root_dir: D:/code/data\n    label_dir: ants\n    \"\"\"\n    def __init__(self, root_dir, label_dir):\n        # 图片根路径\n        self.root_dir = root_dir\n        # 图片标签名称\n        self.label_dir = label_dir\n        # 数据根路径 + 标签名（标签下存有对应的图片）\n        self.path = os.path.join(root_dir,label_dir)\n        # 获取文件夹下的所有文件名，生成列表\n        self.img_path = os.listdir(self.path)\n\n    def __getitem__(self, idx):\n        img_name = self.img_path[idx]\n        img_item_path = os.path.join(self.path,img_name)\n        img = Image.open(img_item_path)\n        label = self.label_dir\n        return img, label\n\n    def __len__(self):\n        return len(self.img_path)\n```\n\n可以使用使用数组中的索引操作等\n\n```python\n# flower_photos下有多个目录，每个目录的名称都是数据的标签,然后每个目录下都有该标签的对应数据\nroot_dir = \"D:\\\\code\\\\data\\\\flower_photos\"\n\n# daisy数据集\ndaisy_label_dir = \"daisy\"\ndaisy_dataset = MyData(root_dir, daisy_label_dir)\n# roses数据集\nroses_label_dir = \"roses\"\nroses_dataset = MyData(root_dir, roses_label_dir)\n\n# 可以进行数据集合并操作\ndataset = daisy_dataset + roses_dataset\n\n# 可以进行索引索引操作，取最后一个数据\nroses_img , label = dataset[-1]\n\n# 返回的数据roses_img是PIL类型\n```\n\n# Tensorboard\n\n初始化\n\n```python\nfrom torch.utils.tensorboard import SummaryWriter\nimport numpy as np\nfrom PIL import Image\nwriter = SummaryWriter(\"logs\")  # 在当前目录logs目录下生成文件\n```\n\n最后需要对writter进行关闭\n\n```python\nwriter.close()\n```\n\n可视化查看文件，在当前CMD工作目录下（必须具有对应的python环境）输入以下命令打开\n\n```\ntensorboard --logdir=logs\n```\n\n或者添加参数指定打开端口\n\n```\ntensorboard --logdir=logs --port=6006\n```\n\n## 1 添加单张图片\n\n添加`ndarray`型图片\n\n```python\nimage_path = \"./flower_photos/daisy/5673728_71b8cb57eb.jpg\" #  用户需要自己设置成电脑上图片的路径\n# 打开图片，转化为PIL类型\nimg_PIL = Image.open(image_path)\n# 将PIL类型图片转化为numpy型图片\nimg_array = np.array(img_PIL)\n# shape为HWC(高 宽 颜色)\nprint(img_array.shape)  # (332, 500, 3)\n# title 传入图片  步长  shape形式\nwriter.add_image(\"ndarray\", img_array, global_step=1, dataformats=\"HWC\")\n```\n\n添加`tensor`类型图片\n\n```python\nimage_path = \"./flower_photos/daisy/5673728_71b8cb57eb.jpg\" #  用户需要自己设置成电脑上图片的路径\nimg_PIL = Image.open(image_path)\ntrans_totensor = transforms.ToTensor()\ntensor_img = trans_totensor(img_PIL)\nwriter.add_image(\"tensor\", tensor_img)\n```\n\n## 2 添加公式图像\n\n```python\n# 添加函数图像,显示函数图像\nfor i in range(100):\n    # 标题 y轴 x轴\n\twriter.add_scalar(\"y = x\", i, i)  # value, step\n```\n\n## 3 添加多个图片\n\n```python\n# 图片已经通过transform转变为tensor类型，transform可见下文\ntest_data = torchvision.datasets.CIFAR10(\"./dataset\", train=False, transform=torchvision.transforms.ToTensor())\ntest_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=False)\nwriter = SummaryWriter(\"logs\")\nstep = 0\nfor data in test_loader:\n    imgs, targets = data\n    writer.add_images(\"epoch\", imgs, step)  # 将64张图片添加进去\n    step = step + 1\nwriter.close()\n```\n\n# Transforms\n\n```python\nwriter = SummaryWriter(\"logs\")\nimg = Image.open(\"./flower_photos/daisy/5673728_71b8cb57eb.jpg\")\n```\n\n## 1 ToTensor\n\n```python\ntrans_totensor = transforms.ToTensor()\ntensor_img = trans_totensor(img)\nwriter.add_image(\"tensor\", tensor_img)\n```\n\n## 2 Normalize归一化\n\n```python\n# output[channel] = (input[channel] - mean[channel]) / std[channel] （输入 - 平均值） / 标准差\n# 下例：(input - 0.5) / 0.5 = 2 * input - 1\ntrans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\nimg_norm = trans_norm(tensor_img)\nprint(img_norm[0][0][0])\nwriter.add_image(\"Normalize\", img_norm, 0)\n```\n\n\n\n## 3 Resize\n\n```python\n# print(img.size)  PIL图片类型具有size属性\n# 改变图片的大小\ntrans_resize = transforms.Resize((512, 512))\nimg_resize = trans_resize(img)\nimg_resize = trans_totensor(img_resize)\nwriter.add_image(\"resize\", img_resize, 0)\n```\n\n## 4 Compose\n\n```python\n# 将transform操作组合起来\ntrans_resize_2 = transforms.Resize(512)\n# PIL -> PIL -> Tensor\ntrans_compose = transforms.Compose([trans_resize_2, trans_totensor])\nimg_resize_2 = trans_compose(img)\nwriter.add_image(\"resize\", img_resize_2, 1)\n```\n\n## 5 RandomCrop\n\n```python\n# 随机裁剪\ntrans_random = transforms.RandomCrop((100, 100))  # 随机裁剪成100×100大小的图片\ntrans_compose_2 = transforms.Compose([trans_random, trans_totensor])\nfor i in range(10):\n    img_crop = trans_compose_2(img)\n    writer.add_image(\"RandomCrop\", img_crop, i)\n```\n\n# Torchvision\n\n```python\n# 在datasets中获取官方数据集\ntrain_data = torchvision.datasets.CIFAR10(\"./dataset\", train=True, transform=torchvision.transforms.ToTensor(),\n                                          download=True)\ntest_data = torchvision.datasets.CIFAR10(\"./dataset\", train=False, transform=torchvision.transforms.ToTensor(),\n                                         download=True)\n```\n\n# DataLoader\n\n加载对应的数据集，可以对数据集进行打包，`batch_size` 指一次打包多少张图片。\n\n```python\n# 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式\ntrain_dataloader = DataLoader(train_data, batch_size=64, shuffle=True)\ntest_dataloader = DataLoader(test_data, batch_size=64)\n```\n\n可以对加载后的数据集进行`len`操作，数据集可迭代，迭代时的单个元素返回的是**数据**和**label**（都是以CIFAR10数据集为例）。\n\n```python\nfor imgs, targets in train_dataloader:\n    # imgs 为64张tensor类型的图片（进行上述操作之后）\n    # targets 为64张图片对应的标签label值\n```\n\n\n\n# 损失函数和反向传播\n\n```python\nloss_fn = torch.nn.CrossEntropyLoss()\noutputs = model(imgs)\n# 计算loss误差\nloss = loss_fn(outputs, targets)\n# 反向传播\nloss.backward()\n```\n\n# GPU训练\n\n网络模型，损失函数，输入数据都要`to(device)`，见下面`CIFAR10`图片分类代码\n\n```python\n# 获取训练设备\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n# 例\nmodel = MyModel()\nmodel.to(device)\n```\n\n\n\n# CIFAR10图片分类练习\n\nmodel.py\n\n```python\nfrom torch import nn\nimport torch\nfrom torch.utils.tensorboard import SummaryWriter\n\n\nclass MyModel(nn.Module):\n    def __init__(self):\n        super(MyModel, self).__init__()\n        self.model = nn.Sequential(\n            nn.Conv2d(3, 32, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 32, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 64, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Flatten(),\n            nn.Linear(64 * 4 * 4, 64),\n            nn.Linear(64, 10)\n        )\n\n    def forward(self, x):\n        x = self.model(x)\n        return x\n```\n\ntrain.py\n\n```python\nimport torch\nimport torchvision\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\nfrom model import MyModel\n\n# 使用对应设备进行训练\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# 获取每一个 img数据 和 label\n# 训练数据集\ntrain_data = torchvision.datasets.CIFAR10(\"./dataset/CIFAR\", train=True, transform=torchvision.transforms.ToTensor(),\n                                          download=True)\ntest_data = torchvision.datasets.CIFAR10(\"./dataset/CIFAR\", train=False, transform=torchvision.transforms.ToTensor(),\n                                         download=True)\n\nprint(\"训练数据集长度为:{}\".format(len(train_data)))\nprint(\"测试数据集长度为:{}\".format(len(test_data)))\n\n# 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式\ntrain_dataloader = DataLoader(train_data, batch_size=64, shuffle=True)\ntest_dataloader = DataLoader(test_data, batch_size=64)\n\nmodel = MyModel()\nmodel.to(device)\n\n# 损失函数\nloss_fn = torch.nn.CrossEntropyLoss()\nloss_fn.to(device)\n\n# 设置优化器\nlearning_rate = 0.01\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)\n\n# 设置网络训练参数\ntotal_train_step = 0\ntotal_test_step = 0\nepoch = 5\n\nwriter = SummaryWriter(\"./logs/scalar\")\n\nfor i in range(epoch):\n    print(\"----开始第{}轮训练----\".format(i + 1))\n    # 训练开始 对指定的层才有作用\n    model.train()\n\n    for data in train_dataloader:\n        # 获取数据\n        imgs, targets = data\n        # 转换训练设备\n        imgs, targets = imgs.to(device), targets.to(device)\n\n        outputs = model(imgs)\n\n        # 计算loss误差\n        loss = loss_fn(outputs, targets)\n        # 清空梯度\n        optimizer.zero_grad()\n        # 反向传播\n        loss.backward()\n        optimizer.step()\n\n        total_train_step = total_train_step + 1\n\n        if total_train_step % 100 == 0:\n            print(\"训练次数：{},loss值：{}\".format(total_train_step, loss.item()))  # 添加item是直接输出tensor对应的数字，不加输出tenso类型的数字\n            writer.add_scalar(\"train_loss\", loss.item(), total_train_step)\n\n    # 每次训练一轮后跑一边测试\n    # 验证测试\n    model.eval()\n\n    total_test_loss = 0\n    total_accuracy = 0\n    # 网络模型中的梯度都没有， 不发生变化\n    with torch.no_grad():\n        for img, target in test_data:\n            img = torch.reshape(img, (1, 3, 32, 32))\n            target = torch.tensor([target])\n\n            img, target = img.to(device), target.to(device)\n            # 计算输出\n            output = model(img)\n            loss = loss_fn(output, target)\n            total_test_loss = total_test_loss + loss.item()\n\n            \"\"\"\n            outputs:[0.1, 0.2] 两个类别的概率\n                    [0.3, 0.4]\n            targets:[0, 1] 目标类别\n            predict:[1, 1] 预测类别\n            result :[False, True]\n            \"\"\"\n            # argmax求横向最大值所在的位置\n            accuracy = (output.argmax(1) == target).sum()\n            total_accuracy = total_accuracy + accuracy\n\n    print(\"整体测试集的loss：{}\".format(total_test_loss))\n    print(\"整体正确率：{}\".format(total_accuracy / len(test_data)))\n\n    writer.add_scalar(\"test_loss\", total_test_loss, total_test_step)\n    writer.add_scalar(\"test_accuracy\", total_accuracy / len(test_data), total_test_step)\n\n    total_test_step = total_test_step + 1\n\n    # 保存每一轮的模型\n    torch.save(model, \"./weights/model{}.pth\".format(i + 1))\n    # 也可以方式二\n    print(\"模型已保存\")\n\nwriter.close()\n```\n\nread_data.py\n\n```python\nimport os\nfrom PIL import Image\nfrom torch.utils.data import Dataset\n\n\nclass MyData(Dataset):\n    def __init__(self, root_dir, label):\n        self.root_dir = root_dir\n        self.label = label\n        self.path = os.path.join(root_dir, label)\n        self.img_names = os.listdir(self.path)\n\n    def __getitem__(self, index):\n        img_name = self.img_names[index]\n        img_path = os.path.join(self.path, img_name)\n        img = Image.open(img_path)\n        label = self.label\n        return img, label\n\n    def __len__(self):\n        return len(self.img_names)\n\n```\n\n\n\ntest.py\n\n```python\nimport torch\nimport torchvision\nfrom PIL import Image\nfrom model import MyModel\nfrom read_data import MyData\nimport os\n\nans = [\"airplane\", \"automobile\", \"bird\", \"cat\", \"deer\", \"dog\", \"frog\", \"horse\", \"ship\", \"truck\"]\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\nroot_dir = \"D:\\\\code\\\\pytorch_learning\\\\CIFAR10\\\\dataset\\\\val\"\nlabels_dir = os.listdir(root_dir)\n\ntrans = torchvision.transforms.Compose([torchvision.transforms.Resize((32, 32)),\n                                        torchvision.transforms.ToTensor()])\n\nmodel = torch.load(\"./weights/model67.8.pth\")\n\ntot_num = 0\ntot_accuracy = 0\nfor label in labels_dir:\n    cur_accuracy = 0\n    myData = MyData(root_dir, label)\n    tot_num += len(myData)\n    print(\"----------当前的图片类型为: {} ----------\".format(label))\n\n    for img, t_label in myData:\n        # 将图片转换为为torch.Size([3, 32, 32])\n        img = trans(img)\n        # img = img.convert(\"RGB\")\n        img = torch.reshape(img, (1, 3, 32, 32))\n        img = img.to(device)\n\n        model.eval()\n        with torch.no_grad():\n            output = model(img)\n\n        predict_result = ans[output.argmax(1).item()]\n        cur_accuracy += (predict_result == label)\n        print(\"预测结果: {}  \".format(predict_result), \"正确\" if predict_result == label else \"错误\")\n\n    tot_accuracy += cur_accuracy\n    print(\"当前种类预测准确率为: {}\".format(cur_accuracy / len(myData)))\nprint(\"总预测准确率为: {}\".format(tot_accuracy / tot_num))\n\n```\n\n\n\n> 所有代码： https://github.com/anda522/CIFAR10\n>\n> 参考视频：https://www.bilibili.com/video/BV1hE411t7RN/\n>\n> 参考Pytorch文档：https://pytorch.org/docs/stable/nn.html\n\n![](https://wyqz.top/medias/gzh.jpg)\n\n","source":"_posts/Pytorch深度学习入门知识总结.md","raw":"---\ntitle: Pytorch入门知识总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 学习总结\ncategories:\n  - 知识总结\nabbrlink: 1888017128\ndate: 2022-12-14 21:53:28\npassword:\nsummary:\n---\n\n# Pytorch深度学习入门知识总结\n\n# GPU相关\n\n检查GPU是否工作\n\n```python\nimport torch\ntorch.cuda.is_available()\n```\n\n# Dataset\n\n可以继承Dataset来制作自己的数据类\n\n```python\nfrom torch.utils.data import Dataset\nfrom PIL import Image\nimport os\n\n\nclass MyData(Dataset):\n    \"\"\"\n    For example:\n    root_dir: D:/code/data\n    label_dir: ants\n    \"\"\"\n    def __init__(self, root_dir, label_dir):\n        # 图片根路径\n        self.root_dir = root_dir\n        # 图片标签名称\n        self.label_dir = label_dir\n        # 数据根路径 + 标签名（标签下存有对应的图片）\n        self.path = os.path.join(root_dir,label_dir)\n        # 获取文件夹下的所有文件名，生成列表\n        self.img_path = os.listdir(self.path)\n\n    def __getitem__(self, idx):\n        img_name = self.img_path[idx]\n        img_item_path = os.path.join(self.path,img_name)\n        img = Image.open(img_item_path)\n        label = self.label_dir\n        return img, label\n\n    def __len__(self):\n        return len(self.img_path)\n```\n\n可以使用使用数组中的索引操作等\n\n```python\n# flower_photos下有多个目录，每个目录的名称都是数据的标签,然后每个目录下都有该标签的对应数据\nroot_dir = \"D:\\\\code\\\\data\\\\flower_photos\"\n\n# daisy数据集\ndaisy_label_dir = \"daisy\"\ndaisy_dataset = MyData(root_dir, daisy_label_dir)\n# roses数据集\nroses_label_dir = \"roses\"\nroses_dataset = MyData(root_dir, roses_label_dir)\n\n# 可以进行数据集合并操作\ndataset = daisy_dataset + roses_dataset\n\n# 可以进行索引索引操作，取最后一个数据\nroses_img , label = dataset[-1]\n\n# 返回的数据roses_img是PIL类型\n```\n\n# Tensorboard\n\n初始化\n\n```python\nfrom torch.utils.tensorboard import SummaryWriter\nimport numpy as np\nfrom PIL import Image\nwriter = SummaryWriter(\"logs\")  # 在当前目录logs目录下生成文件\n```\n\n最后需要对writter进行关闭\n\n```python\nwriter.close()\n```\n\n可视化查看文件，在当前CMD工作目录下（必须具有对应的python环境）输入以下命令打开\n\n```\ntensorboard --logdir=logs\n```\n\n或者添加参数指定打开端口\n\n```\ntensorboard --logdir=logs --port=6006\n```\n\n## 1 添加单张图片\n\n添加`ndarray`型图片\n\n```python\nimage_path = \"./flower_photos/daisy/5673728_71b8cb57eb.jpg\" #  用户需要自己设置成电脑上图片的路径\n# 打开图片，转化为PIL类型\nimg_PIL = Image.open(image_path)\n# 将PIL类型图片转化为numpy型图片\nimg_array = np.array(img_PIL)\n# shape为HWC(高 宽 颜色)\nprint(img_array.shape)  # (332, 500, 3)\n# title 传入图片  步长  shape形式\nwriter.add_image(\"ndarray\", img_array, global_step=1, dataformats=\"HWC\")\n```\n\n添加`tensor`类型图片\n\n```python\nimage_path = \"./flower_photos/daisy/5673728_71b8cb57eb.jpg\" #  用户需要自己设置成电脑上图片的路径\nimg_PIL = Image.open(image_path)\ntrans_totensor = transforms.ToTensor()\ntensor_img = trans_totensor(img_PIL)\nwriter.add_image(\"tensor\", tensor_img)\n```\n\n## 2 添加公式图像\n\n```python\n# 添加函数图像,显示函数图像\nfor i in range(100):\n    # 标题 y轴 x轴\n\twriter.add_scalar(\"y = x\", i, i)  # value, step\n```\n\n## 3 添加多个图片\n\n```python\n# 图片已经通过transform转变为tensor类型，transform可见下文\ntest_data = torchvision.datasets.CIFAR10(\"./dataset\", train=False, transform=torchvision.transforms.ToTensor())\ntest_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=False)\nwriter = SummaryWriter(\"logs\")\nstep = 0\nfor data in test_loader:\n    imgs, targets = data\n    writer.add_images(\"epoch\", imgs, step)  # 将64张图片添加进去\n    step = step + 1\nwriter.close()\n```\n\n# Transforms\n\n```python\nwriter = SummaryWriter(\"logs\")\nimg = Image.open(\"./flower_photos/daisy/5673728_71b8cb57eb.jpg\")\n```\n\n## 1 ToTensor\n\n```python\ntrans_totensor = transforms.ToTensor()\ntensor_img = trans_totensor(img)\nwriter.add_image(\"tensor\", tensor_img)\n```\n\n## 2 Normalize归一化\n\n```python\n# output[channel] = (input[channel] - mean[channel]) / std[channel] （输入 - 平均值） / 标准差\n# 下例：(input - 0.5) / 0.5 = 2 * input - 1\ntrans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\nimg_norm = trans_norm(tensor_img)\nprint(img_norm[0][0][0])\nwriter.add_image(\"Normalize\", img_norm, 0)\n```\n\n\n\n## 3 Resize\n\n```python\n# print(img.size)  PIL图片类型具有size属性\n# 改变图片的大小\ntrans_resize = transforms.Resize((512, 512))\nimg_resize = trans_resize(img)\nimg_resize = trans_totensor(img_resize)\nwriter.add_image(\"resize\", img_resize, 0)\n```\n\n## 4 Compose\n\n```python\n# 将transform操作组合起来\ntrans_resize_2 = transforms.Resize(512)\n# PIL -> PIL -> Tensor\ntrans_compose = transforms.Compose([trans_resize_2, trans_totensor])\nimg_resize_2 = trans_compose(img)\nwriter.add_image(\"resize\", img_resize_2, 1)\n```\n\n## 5 RandomCrop\n\n```python\n# 随机裁剪\ntrans_random = transforms.RandomCrop((100, 100))  # 随机裁剪成100×100大小的图片\ntrans_compose_2 = transforms.Compose([trans_random, trans_totensor])\nfor i in range(10):\n    img_crop = trans_compose_2(img)\n    writer.add_image(\"RandomCrop\", img_crop, i)\n```\n\n# Torchvision\n\n```python\n# 在datasets中获取官方数据集\ntrain_data = torchvision.datasets.CIFAR10(\"./dataset\", train=True, transform=torchvision.transforms.ToTensor(),\n                                          download=True)\ntest_data = torchvision.datasets.CIFAR10(\"./dataset\", train=False, transform=torchvision.transforms.ToTensor(),\n                                         download=True)\n```\n\n# DataLoader\n\n加载对应的数据集，可以对数据集进行打包，`batch_size` 指一次打包多少张图片。\n\n```python\n# 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式\ntrain_dataloader = DataLoader(train_data, batch_size=64, shuffle=True)\ntest_dataloader = DataLoader(test_data, batch_size=64)\n```\n\n可以对加载后的数据集进行`len`操作，数据集可迭代，迭代时的单个元素返回的是**数据**和**label**（都是以CIFAR10数据集为例）。\n\n```python\nfor imgs, targets in train_dataloader:\n    # imgs 为64张tensor类型的图片（进行上述操作之后）\n    # targets 为64张图片对应的标签label值\n```\n\n\n\n# 损失函数和反向传播\n\n```python\nloss_fn = torch.nn.CrossEntropyLoss()\noutputs = model(imgs)\n# 计算loss误差\nloss = loss_fn(outputs, targets)\n# 反向传播\nloss.backward()\n```\n\n# GPU训练\n\n网络模型，损失函数，输入数据都要`to(device)`，见下面`CIFAR10`图片分类代码\n\n```python\n# 获取训练设备\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n# 例\nmodel = MyModel()\nmodel.to(device)\n```\n\n\n\n# CIFAR10图片分类练习\n\nmodel.py\n\n```python\nfrom torch import nn\nimport torch\nfrom torch.utils.tensorboard import SummaryWriter\n\n\nclass MyModel(nn.Module):\n    def __init__(self):\n        super(MyModel, self).__init__()\n        self.model = nn.Sequential(\n            nn.Conv2d(3, 32, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 32, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 64, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Flatten(),\n            nn.Linear(64 * 4 * 4, 64),\n            nn.Linear(64, 10)\n        )\n\n    def forward(self, x):\n        x = self.model(x)\n        return x\n```\n\ntrain.py\n\n```python\nimport torch\nimport torchvision\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\nfrom model import MyModel\n\n# 使用对应设备进行训练\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# 获取每一个 img数据 和 label\n# 训练数据集\ntrain_data = torchvision.datasets.CIFAR10(\"./dataset/CIFAR\", train=True, transform=torchvision.transforms.ToTensor(),\n                                          download=True)\ntest_data = torchvision.datasets.CIFAR10(\"./dataset/CIFAR\", train=False, transform=torchvision.transforms.ToTensor(),\n                                         download=True)\n\nprint(\"训练数据集长度为:{}\".format(len(train_data)))\nprint(\"测试数据集长度为:{}\".format(len(test_data)))\n\n# 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式\ntrain_dataloader = DataLoader(train_data, batch_size=64, shuffle=True)\ntest_dataloader = DataLoader(test_data, batch_size=64)\n\nmodel = MyModel()\nmodel.to(device)\n\n# 损失函数\nloss_fn = torch.nn.CrossEntropyLoss()\nloss_fn.to(device)\n\n# 设置优化器\nlearning_rate = 0.01\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)\n\n# 设置网络训练参数\ntotal_train_step = 0\ntotal_test_step = 0\nepoch = 5\n\nwriter = SummaryWriter(\"./logs/scalar\")\n\nfor i in range(epoch):\n    print(\"----开始第{}轮训练----\".format(i + 1))\n    # 训练开始 对指定的层才有作用\n    model.train()\n\n    for data in train_dataloader:\n        # 获取数据\n        imgs, targets = data\n        # 转换训练设备\n        imgs, targets = imgs.to(device), targets.to(device)\n\n        outputs = model(imgs)\n\n        # 计算loss误差\n        loss = loss_fn(outputs, targets)\n        # 清空梯度\n        optimizer.zero_grad()\n        # 反向传播\n        loss.backward()\n        optimizer.step()\n\n        total_train_step = total_train_step + 1\n\n        if total_train_step % 100 == 0:\n            print(\"训练次数：{},loss值：{}\".format(total_train_step, loss.item()))  # 添加item是直接输出tensor对应的数字，不加输出tenso类型的数字\n            writer.add_scalar(\"train_loss\", loss.item(), total_train_step)\n\n    # 每次训练一轮后跑一边测试\n    # 验证测试\n    model.eval()\n\n    total_test_loss = 0\n    total_accuracy = 0\n    # 网络模型中的梯度都没有， 不发生变化\n    with torch.no_grad():\n        for img, target in test_data:\n            img = torch.reshape(img, (1, 3, 32, 32))\n            target = torch.tensor([target])\n\n            img, target = img.to(device), target.to(device)\n            # 计算输出\n            output = model(img)\n            loss = loss_fn(output, target)\n            total_test_loss = total_test_loss + loss.item()\n\n            \"\"\"\n            outputs:[0.1, 0.2] 两个类别的概率\n                    [0.3, 0.4]\n            targets:[0, 1] 目标类别\n            predict:[1, 1] 预测类别\n            result :[False, True]\n            \"\"\"\n            # argmax求横向最大值所在的位置\n            accuracy = (output.argmax(1) == target).sum()\n            total_accuracy = total_accuracy + accuracy\n\n    print(\"整体测试集的loss：{}\".format(total_test_loss))\n    print(\"整体正确率：{}\".format(total_accuracy / len(test_data)))\n\n    writer.add_scalar(\"test_loss\", total_test_loss, total_test_step)\n    writer.add_scalar(\"test_accuracy\", total_accuracy / len(test_data), total_test_step)\n\n    total_test_step = total_test_step + 1\n\n    # 保存每一轮的模型\n    torch.save(model, \"./weights/model{}.pth\".format(i + 1))\n    # 也可以方式二\n    print(\"模型已保存\")\n\nwriter.close()\n```\n\nread_data.py\n\n```python\nimport os\nfrom PIL import Image\nfrom torch.utils.data import Dataset\n\n\nclass MyData(Dataset):\n    def __init__(self, root_dir, label):\n        self.root_dir = root_dir\n        self.label = label\n        self.path = os.path.join(root_dir, label)\n        self.img_names = os.listdir(self.path)\n\n    def __getitem__(self, index):\n        img_name = self.img_names[index]\n        img_path = os.path.join(self.path, img_name)\n        img = Image.open(img_path)\n        label = self.label\n        return img, label\n\n    def __len__(self):\n        return len(self.img_names)\n\n```\n\n\n\ntest.py\n\n```python\nimport torch\nimport torchvision\nfrom PIL import Image\nfrom model import MyModel\nfrom read_data import MyData\nimport os\n\nans = [\"airplane\", \"automobile\", \"bird\", \"cat\", \"deer\", \"dog\", \"frog\", \"horse\", \"ship\", \"truck\"]\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\nroot_dir = \"D:\\\\code\\\\pytorch_learning\\\\CIFAR10\\\\dataset\\\\val\"\nlabels_dir = os.listdir(root_dir)\n\ntrans = torchvision.transforms.Compose([torchvision.transforms.Resize((32, 32)),\n                                        torchvision.transforms.ToTensor()])\n\nmodel = torch.load(\"./weights/model67.8.pth\")\n\ntot_num = 0\ntot_accuracy = 0\nfor label in labels_dir:\n    cur_accuracy = 0\n    myData = MyData(root_dir, label)\n    tot_num += len(myData)\n    print(\"----------当前的图片类型为: {} ----------\".format(label))\n\n    for img, t_label in myData:\n        # 将图片转换为为torch.Size([3, 32, 32])\n        img = trans(img)\n        # img = img.convert(\"RGB\")\n        img = torch.reshape(img, (1, 3, 32, 32))\n        img = img.to(device)\n\n        model.eval()\n        with torch.no_grad():\n            output = model(img)\n\n        predict_result = ans[output.argmax(1).item()]\n        cur_accuracy += (predict_result == label)\n        print(\"预测结果: {}  \".format(predict_result), \"正确\" if predict_result == label else \"错误\")\n\n    tot_accuracy += cur_accuracy\n    print(\"当前种类预测准确率为: {}\".format(cur_accuracy / len(myData)))\nprint(\"总预测准确率为: {}\".format(tot_accuracy / tot_num))\n\n```\n\n\n\n> 所有代码： https://github.com/anda522/CIFAR10\n>\n> 参考视频：https://www.bilibili.com/video/BV1hE411t7RN/\n>\n> 参考Pytorch文档：https://pytorch.org/docs/stable/nn.html\n\n![](https://wyqz.top/medias/gzh.jpg)\n\n","slug":"Pytorch深度学习入门知识总结","published":1,"updated":"2022-12-14T14:01:57.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhf00146kuhufrikt56","content":"<h1 id=\"Pytorch深度学习入门知识总结\"><a href=\"#Pytorch深度学习入门知识总结\" class=\"headerlink\" title=\"Pytorch深度学习入门知识总结\"></a>Pytorch深度学习入门知识总结</h1><h1 id=\"GPU相关\"><a href=\"#GPU相关\" class=\"headerlink\" title=\"GPU相关\"></a>GPU相关</h1><p>检查GPU是否工作</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> torch\ntorch<span class=\"token punctuation\">.</span>cuda<span class=\"token punctuation\">.</span>is_available<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h1 id=\"Dataset\"><a href=\"#Dataset\" class=\"headerlink\" title=\"Dataset\"></a>Dataset</h1><p>可以继承Dataset来制作自己的数据类</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>data <span class=\"token keyword\">import</span> Dataset\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> Image\n<span class=\"token keyword\">import</span> os\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyData</span><span class=\"token punctuation\">(</span>Dataset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    For example:\n    root_dir: D:/code/data\n    label_dir: ants\n    \"\"\"</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root_dir<span class=\"token punctuation\">,</span> label_dir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 图片根路径</span>\n        self<span class=\"token punctuation\">.</span>root_dir <span class=\"token operator\">=</span> root_dir\n        <span class=\"token comment\" spellcheck=\"true\"># 图片标签名称</span>\n        self<span class=\"token punctuation\">.</span>label_dir <span class=\"token operator\">=</span> label_dir\n        <span class=\"token comment\" spellcheck=\"true\"># 数据根路径 + 标签名（标签下存有对应的图片）</span>\n        self<span class=\"token punctuation\">.</span>path <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>root_dir<span class=\"token punctuation\">,</span>label_dir<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 获取文件夹下的所有文件名，生成列表</span>\n        self<span class=\"token punctuation\">.</span>img_path <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>listdir<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__getitem__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        img_name <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>img_path<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span>\n        img_item_path <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">,</span>img_name<span class=\"token punctuation\">)</span>\n        img <span class=\"token operator\">=</span> Image<span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span>img_item_path<span class=\"token punctuation\">)</span>\n        label <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>label_dir\n        <span class=\"token keyword\">return</span> img<span class=\"token punctuation\">,</span> label\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__len__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> len<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>img_path<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以使用使用数组中的索引操作等</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># flower_photos下有多个目录，每个目录的名称都是数据的标签,然后每个目录下都有该标签的对应数据</span>\nroot_dir <span class=\"token operator\">=</span> <span class=\"token string\">\"D:\\\\code\\\\data\\\\flower_photos\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># daisy数据集</span>\ndaisy_label_dir <span class=\"token operator\">=</span> <span class=\"token string\">\"daisy\"</span>\ndaisy_dataset <span class=\"token operator\">=</span> MyData<span class=\"token punctuation\">(</span>root_dir<span class=\"token punctuation\">,</span> daisy_label_dir<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># roses数据集</span>\nroses_label_dir <span class=\"token operator\">=</span> <span class=\"token string\">\"roses\"</span>\nroses_dataset <span class=\"token operator\">=</span> MyData<span class=\"token punctuation\">(</span>root_dir<span class=\"token punctuation\">,</span> roses_label_dir<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 可以进行数据集合并操作</span>\ndataset <span class=\"token operator\">=</span> daisy_dataset <span class=\"token operator\">+</span> roses_dataset\n\n<span class=\"token comment\" spellcheck=\"true\"># 可以进行索引索引操作，取最后一个数据</span>\nroses_img <span class=\"token punctuation\">,</span> label <span class=\"token operator\">=</span> dataset<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 返回的数据roses_img是PIL类型</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"Tensorboard\"><a href=\"#Tensorboard\" class=\"headerlink\" title=\"Tensorboard\"></a>Tensorboard</h1><p>初始化</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>tensorboard <span class=\"token keyword\">import</span> SummaryWriter\n<span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> Image\nwriter <span class=\"token operator\">=</span> SummaryWriter<span class=\"token punctuation\">(</span><span class=\"token string\">\"logs\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 在当前目录logs目录下生成文件</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>最后需要对writter进行关闭</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\">writer<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可视化查看文件，在当前CMD工作目录下（必须具有对应的python环境）输入以下命令打开</p>\n<pre><code>tensorboard --logdir=logs</code></pre><p>或者添加参数指定打开端口</p>\n<pre><code>tensorboard --logdir=logs --port=6006</code></pre><h2 id=\"1-添加单张图片\"><a href=\"#1-添加单张图片\" class=\"headerlink\" title=\"1 添加单张图片\"></a>1 添加单张图片</h2><p>添加<code>ndarray</code>型图片</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\">image_path <span class=\"token operator\">=</span> <span class=\"token string\">\"./flower_photos/daisy/5673728_71b8cb57eb.jpg\"</span> <span class=\"token comment\" spellcheck=\"true\">#  用户需要自己设置成电脑上图片的路径</span>\n<span class=\"token comment\" spellcheck=\"true\"># 打开图片，转化为PIL类型</span>\nimg_PIL <span class=\"token operator\">=</span> Image<span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span>image_path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 将PIL类型图片转化为numpy型图片</span>\nimg_array <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span>img_PIL<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># shape为HWC(高 宽 颜色)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>img_array<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># (332, 500, 3)</span>\n<span class=\"token comment\" spellcheck=\"true\"># title 传入图片  步长  shape形式</span>\nwriter<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"ndarray\"</span><span class=\"token punctuation\">,</span> img_array<span class=\"token punctuation\">,</span> global_step<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dataformats<span class=\"token operator\">=</span><span class=\"token string\">\"HWC\"</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>添加<code>tensor</code>类型图片</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\">image_path <span class=\"token operator\">=</span> <span class=\"token string\">\"./flower_photos/daisy/5673728_71b8cb57eb.jpg\"</span> <span class=\"token comment\" spellcheck=\"true\">#  用户需要自己设置成电脑上图片的路径</span>\nimg_PIL <span class=\"token operator\">=</span> Image<span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span>image_path<span class=\"token punctuation\">)</span>\ntrans_totensor <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ntensor_img <span class=\"token operator\">=</span> trans_totensor<span class=\"token punctuation\">(</span>img_PIL<span class=\"token punctuation\">)</span>\nwriter<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"tensor\"</span><span class=\"token punctuation\">,</span> tensor_img<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-添加公式图像\"><a href=\"#2-添加公式图像\" class=\"headerlink\" title=\"2 添加公式图像\"></a>2 添加公式图像</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 添加函数图像,显示函数图像</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 标题 y轴 x轴</span>\n    writer<span class=\"token punctuation\">.</span>add_scalar<span class=\"token punctuation\">(</span><span class=\"token string\">\"y = x\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># value, step</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-添加多个图片\"><a href=\"#3-添加多个图片\" class=\"headerlink\" title=\"3 添加多个图片\"></a>3 添加多个图片</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 图片已经通过transform转变为tensor类型，transform可见下文</span>\ntest_data <span class=\"token operator\">=</span> torchvision<span class=\"token punctuation\">.</span>datasets<span class=\"token punctuation\">.</span>CIFAR10<span class=\"token punctuation\">(</span><span class=\"token string\">\"./dataset\"</span><span class=\"token punctuation\">,</span> train<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> transform<span class=\"token operator\">=</span>torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ntest_loader <span class=\"token operator\">=</span> DataLoader<span class=\"token punctuation\">(</span>dataset<span class=\"token operator\">=</span>test_data<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">64</span><span class=\"token punctuation\">,</span> shuffle<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> num_workers<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> drop_last<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span>\nwriter <span class=\"token operator\">=</span> SummaryWriter<span class=\"token punctuation\">(</span><span class=\"token string\">\"logs\"</span><span class=\"token punctuation\">)</span>\nstep <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">for</span> data <span class=\"token keyword\">in</span> test_loader<span class=\"token punctuation\">:</span>\n    imgs<span class=\"token punctuation\">,</span> targets <span class=\"token operator\">=</span> data\n    writer<span class=\"token punctuation\">.</span>add_images<span class=\"token punctuation\">(</span><span class=\"token string\">\"epoch\"</span><span class=\"token punctuation\">,</span> imgs<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 将64张图片添加进去</span>\n    step <span class=\"token operator\">=</span> step <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\nwriter<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"Transforms\"><a href=\"#Transforms\" class=\"headerlink\" title=\"Transforms\"></a>Transforms</h1><pre class=\"line-numbers language-python\"><code class=\"language-python\">writer <span class=\"token operator\">=</span> SummaryWriter<span class=\"token punctuation\">(</span><span class=\"token string\">\"logs\"</span><span class=\"token punctuation\">)</span>\nimg <span class=\"token operator\">=</span> Image<span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span><span class=\"token string\">\"./flower_photos/daisy/5673728_71b8cb57eb.jpg\"</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"1-ToTensor\"><a href=\"#1-ToTensor\" class=\"headerlink\" title=\"1 ToTensor\"></a>1 ToTensor</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\">trans_totensor <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ntensor_img <span class=\"token operator\">=</span> trans_totensor<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\nwriter<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"tensor\"</span><span class=\"token punctuation\">,</span> tensor_img<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-Normalize归一化\"><a href=\"#2-Normalize归一化\" class=\"headerlink\" title=\"2 Normalize归一化\"></a>2 Normalize归一化</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># output[channel] = (input[channel] - mean[channel]) / std[channel] （输入 - 平均值） / 标准差</span>\n<span class=\"token comment\" spellcheck=\"true\"># 下例：(input - 0.5) / 0.5 = 2 * input - 1</span>\ntrans_norm <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>Normalize<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\nimg_norm <span class=\"token operator\">=</span> trans_norm<span class=\"token punctuation\">(</span>tensor_img<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>img_norm<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\nwriter<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"Normalize\"</span><span class=\"token punctuation\">,</span> img_norm<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-Resize\"><a href=\"#3-Resize\" class=\"headerlink\" title=\"3 Resize\"></a>3 Resize</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># print(img.size)  PIL图片类型具有size属性</span>\n<span class=\"token comment\" spellcheck=\"true\"># 改变图片的大小</span>\ntrans_resize <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>Resize<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">512</span><span class=\"token punctuation\">,</span> <span class=\"token number\">512</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nimg_resize <span class=\"token operator\">=</span> trans_resize<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\nimg_resize <span class=\"token operator\">=</span> trans_totensor<span class=\"token punctuation\">(</span>img_resize<span class=\"token punctuation\">)</span>\nwriter<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"resize\"</span><span class=\"token punctuation\">,</span> img_resize<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"4-Compose\"><a href=\"#4-Compose\" class=\"headerlink\" title=\"4 Compose\"></a>4 Compose</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 将transform操作组合起来</span>\ntrans_resize_2 <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>Resize<span class=\"token punctuation\">(</span><span class=\"token number\">512</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># PIL -> PIL -> Tensor</span>\ntrans_compose <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>Compose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>trans_resize_2<span class=\"token punctuation\">,</span> trans_totensor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\nimg_resize_2 <span class=\"token operator\">=</span> trans_compose<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\nwriter<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"resize\"</span><span class=\"token punctuation\">,</span> img_resize_2<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"5-RandomCrop\"><a href=\"#5-RandomCrop\" class=\"headerlink\" title=\"5 RandomCrop\"></a>5 RandomCrop</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 随机裁剪</span>\ntrans_random <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>RandomCrop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 随机裁剪成100×100大小的图片</span>\ntrans_compose_2 <span class=\"token operator\">=</span> transforms<span class=\"token punctuation\">.</span>Compose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>trans_random<span class=\"token punctuation\">,</span> trans_totensor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    img_crop <span class=\"token operator\">=</span> trans_compose_2<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\n    writer<span class=\"token punctuation\">.</span>add_image<span class=\"token punctuation\">(</span><span class=\"token string\">\"RandomCrop\"</span><span class=\"token punctuation\">,</span> img_crop<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"Torchvision\"><a href=\"#Torchvision\" class=\"headerlink\" title=\"Torchvision\"></a>Torchvision</h1><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 在datasets中获取官方数据集</span>\ntrain_data <span class=\"token operator\">=</span> torchvision<span class=\"token punctuation\">.</span>datasets<span class=\"token punctuation\">.</span>CIFAR10<span class=\"token punctuation\">(</span><span class=\"token string\">\"./dataset\"</span><span class=\"token punctuation\">,</span> train<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> transform<span class=\"token operator\">=</span>torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                          download<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\ntest_data <span class=\"token operator\">=</span> torchvision<span class=\"token punctuation\">.</span>datasets<span class=\"token punctuation\">.</span>CIFAR10<span class=\"token punctuation\">(</span><span class=\"token string\">\"./dataset\"</span><span class=\"token punctuation\">,</span> train<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> transform<span class=\"token operator\">=</span>torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                         download<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"DataLoader\"><a href=\"#DataLoader\" class=\"headerlink\" title=\"DataLoader\"></a>DataLoader</h1><p>加载对应的数据集，可以对数据集进行打包，<code>batch_size</code> 指一次打包多少张图片。</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式</span>\ntrain_dataloader <span class=\"token operator\">=</span> DataLoader<span class=\"token punctuation\">(</span>train_data<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">64</span><span class=\"token punctuation\">,</span> shuffle<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\ntest_dataloader <span class=\"token operator\">=</span> DataLoader<span class=\"token punctuation\">(</span>test_data<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>可以对加载后的数据集进行<code>len</code>操作，数据集可迭代，迭代时的单个元素返回的是<strong>数据</strong>和<strong>label</strong>（都是以CIFAR10数据集为例）。</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">for</span> imgs<span class=\"token punctuation\">,</span> targets <span class=\"token keyword\">in</span> train_dataloader<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># imgs 为64张tensor类型的图片（进行上述操作之后）</span>\n    <span class=\"token comment\" spellcheck=\"true\"># targets 为64张图片对应的标签label值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"损失函数和反向传播\"><a href=\"#损失函数和反向传播\" class=\"headerlink\" title=\"损失函数和反向传播\"></a>损失函数和反向传播</h1><pre class=\"line-numbers language-python\"><code class=\"language-python\">loss_fn <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>CrossEntropyLoss<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\noutputs <span class=\"token operator\">=</span> model<span class=\"token punctuation\">(</span>imgs<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 计算loss误差</span>\nloss <span class=\"token operator\">=</span> loss_fn<span class=\"token punctuation\">(</span>outputs<span class=\"token punctuation\">,</span> targets<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 反向传播</span>\nloss<span class=\"token punctuation\">.</span>backward<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"GPU训练\"><a href=\"#GPU训练\" class=\"headerlink\" title=\"GPU训练\"></a>GPU训练</h1><p>网络模型，损失函数，输入数据都要<code>to(device)</code>，见下面<code>CIFAR10</code>图片分类代码</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 获取训练设备</span>\ndevice <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>device<span class=\"token punctuation\">(</span><span class=\"token string\">\"cuda\"</span> <span class=\"token keyword\">if</span> torch<span class=\"token punctuation\">.</span>cuda<span class=\"token punctuation\">.</span>is_available<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"cpu\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 例</span>\nmodel <span class=\"token operator\">=</span> MyModel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"CIFAR10图片分类练习\"><a href=\"#CIFAR10图片分类练习\" class=\"headerlink\" title=\"CIFAR10图片分类练习\"></a>CIFAR10图片分类练习</h1><p>model.py</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> torch <span class=\"token keyword\">import</span> nn\n<span class=\"token keyword\">import</span> torch\n<span class=\"token keyword\">from</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>tensorboard <span class=\"token keyword\">import</span> SummaryWriter\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyModel</span><span class=\"token punctuation\">(</span>nn<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        super<span class=\"token punctuation\">(</span>MyModel<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>model <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Sequential<span class=\"token punctuation\">(</span>\n            nn<span class=\"token punctuation\">.</span>Conv2d<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>MaxPool2d<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>Conv2d<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>MaxPool2d<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>Conv2d<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>MaxPool2d<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>Flatten<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span><span class=\"token number\">64</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>train.py</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> torch\n<span class=\"token keyword\">import</span> torchvision\n<span class=\"token keyword\">from</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>data <span class=\"token keyword\">import</span> DataLoader\n<span class=\"token keyword\">from</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>tensorboard <span class=\"token keyword\">import</span> SummaryWriter\n<span class=\"token keyword\">from</span> model <span class=\"token keyword\">import</span> MyModel\n\n<span class=\"token comment\" spellcheck=\"true\"># 使用对应设备进行训练</span>\ndevice <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>device<span class=\"token punctuation\">(</span><span class=\"token string\">\"cuda\"</span> <span class=\"token keyword\">if</span> torch<span class=\"token punctuation\">.</span>cuda<span class=\"token punctuation\">.</span>is_available<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"cpu\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取每一个 img数据 和 label</span>\n<span class=\"token comment\" spellcheck=\"true\"># 训练数据集</span>\ntrain_data <span class=\"token operator\">=</span> torchvision<span class=\"token punctuation\">.</span>datasets<span class=\"token punctuation\">.</span>CIFAR10<span class=\"token punctuation\">(</span><span class=\"token string\">\"./dataset/CIFAR\"</span><span class=\"token punctuation\">,</span> train<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> transform<span class=\"token operator\">=</span>torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                          download<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\ntest_data <span class=\"token operator\">=</span> torchvision<span class=\"token punctuation\">.</span>datasets<span class=\"token punctuation\">.</span>CIFAR10<span class=\"token punctuation\">(</span><span class=\"token string\">\"./dataset/CIFAR\"</span><span class=\"token punctuation\">,</span> train<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> transform<span class=\"token operator\">=</span>torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                         download<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"训练数据集长度为:{}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">(</span>train_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"测试数据集长度为:{}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">(</span>test_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式</span>\ntrain_dataloader <span class=\"token operator\">=</span> DataLoader<span class=\"token punctuation\">(</span>train_data<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">64</span><span class=\"token punctuation\">,</span> shuffle<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\ntest_dataloader <span class=\"token operator\">=</span> DataLoader<span class=\"token punctuation\">(</span>test_data<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">64</span><span class=\"token punctuation\">)</span>\n\nmodel <span class=\"token operator\">=</span> MyModel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 损失函数</span>\nloss_fn <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>CrossEntropyLoss<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nloss_fn<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 设置优化器</span>\nlearning_rate <span class=\"token operator\">=</span> <span class=\"token number\">0.01</span>\noptimizer <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>optim<span class=\"token punctuation\">.</span>SGD<span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">.</span>parameters<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> lr<span class=\"token operator\">=</span>learning_rate<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 设置网络训练参数</span>\ntotal_train_step <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\ntotal_test_step <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nepoch <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n\nwriter <span class=\"token operator\">=</span> SummaryWriter<span class=\"token punctuation\">(</span><span class=\"token string\">\"./logs/scalar\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>epoch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"----开始第{}轮训练----\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 训练开始 对指定的层才有作用</span>\n    model<span class=\"token punctuation\">.</span>train<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> data <span class=\"token keyword\">in</span> train_dataloader<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 获取数据</span>\n        imgs<span class=\"token punctuation\">,</span> targets <span class=\"token operator\">=</span> data\n        <span class=\"token comment\" spellcheck=\"true\"># 转换训练设备</span>\n        imgs<span class=\"token punctuation\">,</span> targets <span class=\"token operator\">=</span> imgs<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> targets<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span>\n\n        outputs <span class=\"token operator\">=</span> model<span class=\"token punctuation\">(</span>imgs<span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\"># 计算loss误差</span>\n        loss <span class=\"token operator\">=</span> loss_fn<span class=\"token punctuation\">(</span>outputs<span class=\"token punctuation\">,</span> targets<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 清空梯度</span>\n        optimizer<span class=\"token punctuation\">.</span>zero_grad<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 反向传播</span>\n        loss<span class=\"token punctuation\">.</span>backward<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        optimizer<span class=\"token punctuation\">.</span>step<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        total_train_step <span class=\"token operator\">=</span> total_train_step <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\n        <span class=\"token keyword\">if</span> total_train_step <span class=\"token operator\">%</span> <span class=\"token number\">100</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"训练次数：{},loss值：{}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>total_train_step<span class=\"token punctuation\">,</span> loss<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 添加item是直接输出tensor对应的数字，不加输出tenso类型的数字</span>\n            writer<span class=\"token punctuation\">.</span>add_scalar<span class=\"token punctuation\">(</span><span class=\"token string\">\"train_loss\"</span><span class=\"token punctuation\">,</span> loss<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> total_train_step<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># 每次训练一轮后跑一边测试</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 验证测试</span>\n    model<span class=\"token punctuation\">.</span>eval<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    total_test_loss <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    total_accuracy <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 网络模型中的梯度都没有， 不发生变化</span>\n    <span class=\"token keyword\">with</span> torch<span class=\"token punctuation\">.</span>no_grad<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> img<span class=\"token punctuation\">,</span> target <span class=\"token keyword\">in</span> test_data<span class=\"token punctuation\">:</span>\n            img <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            target <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>tensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>target<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n            img<span class=\"token punctuation\">,</span> target <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span>\n            <span class=\"token comment\" spellcheck=\"true\"># 计算输出</span>\n            output <span class=\"token operator\">=</span> model<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\n            loss <span class=\"token operator\">=</span> loss_fn<span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span>\n            total_test_loss <span class=\"token operator\">=</span> total_test_loss <span class=\"token operator\">+</span> loss<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token triple-quoted-string string\">\"\"\"\n            outputs:[0.1, 0.2] 两个类别的概率\n                    [0.3, 0.4]\n            targets:[0, 1] 目标类别\n            predict:[1, 1] 预测类别\n            result :[False, True]\n            \"\"\"</span>\n            <span class=\"token comment\" spellcheck=\"true\"># argmax求横向最大值所在的位置</span>\n            accuracy <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">.</span>argmax<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sum<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            total_accuracy <span class=\"token operator\">=</span> total_accuracy <span class=\"token operator\">+</span> accuracy\n\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"整体测试集的loss：{}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>total_test_loss<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"整体正确率：{}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>total_accuracy <span class=\"token operator\">/</span> len<span class=\"token punctuation\">(</span>test_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    writer<span class=\"token punctuation\">.</span>add_scalar<span class=\"token punctuation\">(</span><span class=\"token string\">\"test_loss\"</span><span class=\"token punctuation\">,</span> total_test_loss<span class=\"token punctuation\">,</span> total_test_step<span class=\"token punctuation\">)</span>\n    writer<span class=\"token punctuation\">.</span>add_scalar<span class=\"token punctuation\">(</span><span class=\"token string\">\"test_accuracy\"</span><span class=\"token punctuation\">,</span> total_accuracy <span class=\"token operator\">/</span> len<span class=\"token punctuation\">(</span>test_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> total_test_step<span class=\"token punctuation\">)</span>\n\n    total_test_step <span class=\"token operator\">=</span> total_test_step <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># 保存每一轮的模型</span>\n    torch<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> <span class=\"token string\">\"./weights/model{}.pth\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 也可以方式二</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"模型已保存\"</span><span class=\"token punctuation\">)</span>\n\nwriter<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>read_data.py</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> Image\n<span class=\"token keyword\">from</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>data <span class=\"token keyword\">import</span> Dataset\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyData</span><span class=\"token punctuation\">(</span>Dataset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> root_dir<span class=\"token punctuation\">,</span> label<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>root_dir <span class=\"token operator\">=</span> root_dir\n        self<span class=\"token punctuation\">.</span>label <span class=\"token operator\">=</span> label\n        self<span class=\"token punctuation\">.</span>path <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>root_dir<span class=\"token punctuation\">,</span> label<span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>img_names <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>listdir<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__getitem__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        img_name <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>img_names<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span>\n        img_path <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">,</span> img_name<span class=\"token punctuation\">)</span>\n        img <span class=\"token operator\">=</span> Image<span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span>img_path<span class=\"token punctuation\">)</span>\n        label <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>label\n        <span class=\"token keyword\">return</span> img<span class=\"token punctuation\">,</span> label\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__len__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> len<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>img_names<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>test.py</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> torch\n<span class=\"token keyword\">import</span> torchvision\n<span class=\"token keyword\">from</span> PIL <span class=\"token keyword\">import</span> Image\n<span class=\"token keyword\">from</span> model <span class=\"token keyword\">import</span> MyModel\n<span class=\"token keyword\">from</span> read_data <span class=\"token keyword\">import</span> MyData\n<span class=\"token keyword\">import</span> os\n\nans <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"airplane\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"automobile\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bird\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cat\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"deer\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"dog\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"frog\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"horse\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ship\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"truck\"</span><span class=\"token punctuation\">]</span>\n\ndevice <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>device<span class=\"token punctuation\">(</span><span class=\"token string\">\"cuda\"</span> <span class=\"token keyword\">if</span> torch<span class=\"token punctuation\">.</span>cuda<span class=\"token punctuation\">.</span>is_available<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"cpu\"</span><span class=\"token punctuation\">)</span>\n\nroot_dir <span class=\"token operator\">=</span> <span class=\"token string\">\"D:\\\\code\\\\pytorch_learning\\\\CIFAR10\\\\dataset\\\\val\"</span>\nlabels_dir <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>listdir<span class=\"token punctuation\">(</span>root_dir<span class=\"token punctuation\">)</span>\n\ntrans <span class=\"token operator\">=</span> torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>Compose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>Resize<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                        torchvision<span class=\"token punctuation\">.</span>transforms<span class=\"token punctuation\">.</span>ToTensor<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\nmodel <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>load<span class=\"token punctuation\">(</span><span class=\"token string\">\"./weights/model67.8.pth\"</span><span class=\"token punctuation\">)</span>\n\ntot_num <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\ntot_accuracy <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">for</span> label <span class=\"token keyword\">in</span> labels_dir<span class=\"token punctuation\">:</span>\n    cur_accuracy <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    myData <span class=\"token operator\">=</span> MyData<span class=\"token punctuation\">(</span>root_dir<span class=\"token punctuation\">,</span> label<span class=\"token punctuation\">)</span>\n    tot_num <span class=\"token operator\">+=</span> len<span class=\"token punctuation\">(</span>myData<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"----------当前的图片类型为: {} ----------\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>label<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> img<span class=\"token punctuation\">,</span> t_label <span class=\"token keyword\">in</span> myData<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 将图片转换为为torch.Size([3, 32, 32])</span>\n        img <span class=\"token operator\">=</span> trans<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\"># img = img.convert(\"RGB\")</span>\n        img <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        img <span class=\"token operator\">=</span> img<span class=\"token punctuation\">.</span>to<span class=\"token punctuation\">(</span>device<span class=\"token punctuation\">)</span>\n\n        model<span class=\"token punctuation\">.</span>eval<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">with</span> torch<span class=\"token punctuation\">.</span>no_grad<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            output <span class=\"token operator\">=</span> model<span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">)</span>\n\n        predict_result <span class=\"token operator\">=</span> ans<span class=\"token punctuation\">[</span>output<span class=\"token punctuation\">.</span>argmax<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n        cur_accuracy <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span>predict_result <span class=\"token operator\">==</span> label<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"预测结果: {}  \"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>predict_result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"正确\"</span> <span class=\"token keyword\">if</span> predict_result <span class=\"token operator\">==</span> label <span class=\"token keyword\">else</span> <span class=\"token string\">\"错误\"</span><span class=\"token punctuation\">)</span>\n\n    tot_accuracy <span class=\"token operator\">+=</span> cur_accuracy\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"当前种类预测准确率为: {}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>cur_accuracy <span class=\"token operator\">/</span> len<span class=\"token punctuation\">(</span>myData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"总预测准确率为: {}\"</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>tot_accuracy <span class=\"token operator\">/</span> tot_num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>所有代码： <a href=\"https://github.com/anda522/CIFAR10\" target=\"_blank\" rel=\"noopener\">https://github.com/anda522/CIFAR10</a></p>\n<p>参考视频：<a href=\"https://www.bilibili.com/video/BV1hE411t7RN/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1hE411t7RN/</a></p>\n<p>参考Pytorch文档：<a href=\"https://pytorch.org/docs/stable/nn.html\" target=\"_blank\" rel=\"noopener\">https://pytorch.org/docs/stable/nn.html</a></p>\n</blockquote>\n<p><img src=\"https://wyqz.top/medias/gzh.jpg\" alt></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"Pytorch深度学习入门知识总结\"><a href=\"#Pytorch深度学习入门知识总结\" class=\"headerlink\" title=\"Pytorch深度学习入门知识总结\"></a>Pytorch深度学习入门知识总结</h1><h1 id=\"GPU相关\"><a href=\"#GPU相关\" class=\"headerlink\" title=\"GPU相关\"></a>GPU相关</h1><p>检查GPU是否工作</p>\n<pre><code class=\"python\">import torch\ntorch.cuda.is_available()</code></pre>\n<h1 id=\"Dataset\"><a href=\"#Dataset\" class=\"headerlink\" title=\"Dataset\"></a>Dataset</h1><p>可以继承Dataset来制作自己的数据类</p>\n<pre><code class=\"python\">from torch.utils.data import Dataset\nfrom PIL import Image\nimport os\n\n\nclass MyData(Dataset):\n    &quot;&quot;&quot;\n    For example:\n    root_dir: D:/code/data\n    label_dir: ants\n    &quot;&quot;&quot;\n    def __init__(self, root_dir, label_dir):\n        # 图片根路径\n        self.root_dir = root_dir\n        # 图片标签名称\n        self.label_dir = label_dir\n        # 数据根路径 + 标签名（标签下存有对应的图片）\n        self.path = os.path.join(root_dir,label_dir)\n        # 获取文件夹下的所有文件名，生成列表\n        self.img_path = os.listdir(self.path)\n\n    def __getitem__(self, idx):\n        img_name = self.img_path[idx]\n        img_item_path = os.path.join(self.path,img_name)\n        img = Image.open(img_item_path)\n        label = self.label_dir\n        return img, label\n\n    def __len__(self):\n        return len(self.img_path)</code></pre>\n<p>可以使用使用数组中的索引操作等</p>\n<pre><code class=\"python\"># flower_photos下有多个目录，每个目录的名称都是数据的标签,然后每个目录下都有该标签的对应数据\nroot_dir = &quot;D:\\\\code\\\\data\\\\flower_photos&quot;\n\n# daisy数据集\ndaisy_label_dir = &quot;daisy&quot;\ndaisy_dataset = MyData(root_dir, daisy_label_dir)\n# roses数据集\nroses_label_dir = &quot;roses&quot;\nroses_dataset = MyData(root_dir, roses_label_dir)\n\n# 可以进行数据集合并操作\ndataset = daisy_dataset + roses_dataset\n\n# 可以进行索引索引操作，取最后一个数据\nroses_img , label = dataset[-1]\n\n# 返回的数据roses_img是PIL类型</code></pre>\n<h1 id=\"Tensorboard\"><a href=\"#Tensorboard\" class=\"headerlink\" title=\"Tensorboard\"></a>Tensorboard</h1><p>初始化</p>\n<pre><code class=\"python\">from torch.utils.tensorboard import SummaryWriter\nimport numpy as np\nfrom PIL import Image\nwriter = SummaryWriter(&quot;logs&quot;)  # 在当前目录logs目录下生成文件</code></pre>\n<p>最后需要对writter进行关闭</p>\n<pre><code class=\"python\">writer.close()</code></pre>\n<p>可视化查看文件，在当前CMD工作目录下（必须具有对应的python环境）输入以下命令打开</p>\n<pre><code>tensorboard --logdir=logs</code></pre><p>或者添加参数指定打开端口</p>\n<pre><code>tensorboard --logdir=logs --port=6006</code></pre><h2 id=\"1-添加单张图片\"><a href=\"#1-添加单张图片\" class=\"headerlink\" title=\"1 添加单张图片\"></a>1 添加单张图片</h2><p>添加<code>ndarray</code>型图片</p>\n<pre><code class=\"python\">image_path = &quot;./flower_photos/daisy/5673728_71b8cb57eb.jpg&quot; #  用户需要自己设置成电脑上图片的路径\n# 打开图片，转化为PIL类型\nimg_PIL = Image.open(image_path)\n# 将PIL类型图片转化为numpy型图片\nimg_array = np.array(img_PIL)\n# shape为HWC(高 宽 颜色)\nprint(img_array.shape)  # (332, 500, 3)\n# title 传入图片  步长  shape形式\nwriter.add_image(&quot;ndarray&quot;, img_array, global_step=1, dataformats=&quot;HWC&quot;)</code></pre>\n<p>添加<code>tensor</code>类型图片</p>\n<pre><code class=\"python\">image_path = &quot;./flower_photos/daisy/5673728_71b8cb57eb.jpg&quot; #  用户需要自己设置成电脑上图片的路径\nimg_PIL = Image.open(image_path)\ntrans_totensor = transforms.ToTensor()\ntensor_img = trans_totensor(img_PIL)\nwriter.add_image(&quot;tensor&quot;, tensor_img)</code></pre>\n<h2 id=\"2-添加公式图像\"><a href=\"#2-添加公式图像\" class=\"headerlink\" title=\"2 添加公式图像\"></a>2 添加公式图像</h2><pre><code class=\"python\"># 添加函数图像,显示函数图像\nfor i in range(100):\n    # 标题 y轴 x轴\n    writer.add_scalar(&quot;y = x&quot;, i, i)  # value, step</code></pre>\n<h2 id=\"3-添加多个图片\"><a href=\"#3-添加多个图片\" class=\"headerlink\" title=\"3 添加多个图片\"></a>3 添加多个图片</h2><pre><code class=\"python\"># 图片已经通过transform转变为tensor类型，transform可见下文\ntest_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor())\ntest_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=False)\nwriter = SummaryWriter(&quot;logs&quot;)\nstep = 0\nfor data in test_loader:\n    imgs, targets = data\n    writer.add_images(&quot;epoch&quot;, imgs, step)  # 将64张图片添加进去\n    step = step + 1\nwriter.close()</code></pre>\n<h1 id=\"Transforms\"><a href=\"#Transforms\" class=\"headerlink\" title=\"Transforms\"></a>Transforms</h1><pre><code class=\"python\">writer = SummaryWriter(&quot;logs&quot;)\nimg = Image.open(&quot;./flower_photos/daisy/5673728_71b8cb57eb.jpg&quot;)</code></pre>\n<h2 id=\"1-ToTensor\"><a href=\"#1-ToTensor\" class=\"headerlink\" title=\"1 ToTensor\"></a>1 ToTensor</h2><pre><code class=\"python\">trans_totensor = transforms.ToTensor()\ntensor_img = trans_totensor(img)\nwriter.add_image(&quot;tensor&quot;, tensor_img)</code></pre>\n<h2 id=\"2-Normalize归一化\"><a href=\"#2-Normalize归一化\" class=\"headerlink\" title=\"2 Normalize归一化\"></a>2 Normalize归一化</h2><pre><code class=\"python\"># output[channel] = (input[channel] - mean[channel]) / std[channel] （输入 - 平均值） / 标准差\n# 下例：(input - 0.5) / 0.5 = 2 * input - 1\ntrans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\nimg_norm = trans_norm(tensor_img)\nprint(img_norm[0][0][0])\nwriter.add_image(&quot;Normalize&quot;, img_norm, 0)</code></pre>\n<h2 id=\"3-Resize\"><a href=\"#3-Resize\" class=\"headerlink\" title=\"3 Resize\"></a>3 Resize</h2><pre><code class=\"python\"># print(img.size)  PIL图片类型具有size属性\n# 改变图片的大小\ntrans_resize = transforms.Resize((512, 512))\nimg_resize = trans_resize(img)\nimg_resize = trans_totensor(img_resize)\nwriter.add_image(&quot;resize&quot;, img_resize, 0)</code></pre>\n<h2 id=\"4-Compose\"><a href=\"#4-Compose\" class=\"headerlink\" title=\"4 Compose\"></a>4 Compose</h2><pre><code class=\"python\"># 将transform操作组合起来\ntrans_resize_2 = transforms.Resize(512)\n# PIL -&gt; PIL -&gt; Tensor\ntrans_compose = transforms.Compose([trans_resize_2, trans_totensor])\nimg_resize_2 = trans_compose(img)\nwriter.add_image(&quot;resize&quot;, img_resize_2, 1)</code></pre>\n<h2 id=\"5-RandomCrop\"><a href=\"#5-RandomCrop\" class=\"headerlink\" title=\"5 RandomCrop\"></a>5 RandomCrop</h2><pre><code class=\"python\"># 随机裁剪\ntrans_random = transforms.RandomCrop((100, 100))  # 随机裁剪成100×100大小的图片\ntrans_compose_2 = transforms.Compose([trans_random, trans_totensor])\nfor i in range(10):\n    img_crop = trans_compose_2(img)\n    writer.add_image(&quot;RandomCrop&quot;, img_crop, i)</code></pre>\n<h1 id=\"Torchvision\"><a href=\"#Torchvision\" class=\"headerlink\" title=\"Torchvision\"></a>Torchvision</h1><pre><code class=\"python\"># 在datasets中获取官方数据集\ntrain_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(),\n                                          download=True)\ntest_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(),\n                                         download=True)</code></pre>\n<h1 id=\"DataLoader\"><a href=\"#DataLoader\" class=\"headerlink\" title=\"DataLoader\"></a>DataLoader</h1><p>加载对应的数据集，可以对数据集进行打包，<code>batch_size</code> 指一次打包多少张图片。</p>\n<pre><code class=\"python\"># 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式\ntrain_dataloader = DataLoader(train_data, batch_size=64, shuffle=True)\ntest_dataloader = DataLoader(test_data, batch_size=64)</code></pre>\n<p>可以对加载后的数据集进行<code>len</code>操作，数据集可迭代，迭代时的单个元素返回的是<strong>数据</strong>和<strong>label</strong>（都是以CIFAR10数据集为例）。</p>\n<pre><code class=\"python\">for imgs, targets in train_dataloader:\n    # imgs 为64张tensor类型的图片（进行上述操作之后）\n    # targets 为64张图片对应的标签label值</code></pre>\n<h1 id=\"损失函数和反向传播\"><a href=\"#损失函数和反向传播\" class=\"headerlink\" title=\"损失函数和反向传播\"></a>损失函数和反向传播</h1><pre><code class=\"python\">loss_fn = torch.nn.CrossEntropyLoss()\noutputs = model(imgs)\n# 计算loss误差\nloss = loss_fn(outputs, targets)\n# 反向传播\nloss.backward()</code></pre>\n<h1 id=\"GPU训练\"><a href=\"#GPU训练\" class=\"headerlink\" title=\"GPU训练\"></a>GPU训练</h1><p>网络模型，损失函数，输入数据都要<code>to(device)</code>，见下面<code>CIFAR10</code>图片分类代码</p>\n<pre><code class=\"python\"># 获取训练设备\ndevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)\n# 例\nmodel = MyModel()\nmodel.to(device)</code></pre>\n<h1 id=\"CIFAR10图片分类练习\"><a href=\"#CIFAR10图片分类练习\" class=\"headerlink\" title=\"CIFAR10图片分类练习\"></a>CIFAR10图片分类练习</h1><p>model.py</p>\n<pre><code class=\"python\">from torch import nn\nimport torch\nfrom torch.utils.tensorboard import SummaryWriter\n\n\nclass MyModel(nn.Module):\n    def __init__(self):\n        super(MyModel, self).__init__()\n        self.model = nn.Sequential(\n            nn.Conv2d(3, 32, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 32, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Conv2d(32, 64, 5, 1, 2),\n            nn.MaxPool2d(2),\n            nn.Flatten(),\n            nn.Linear(64 * 4 * 4, 64),\n            nn.Linear(64, 10)\n        )\n\n    def forward(self, x):\n        x = self.model(x)\n        return x</code></pre>\n<p>train.py</p>\n<pre><code class=\"python\">import torch\nimport torchvision\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\nfrom model import MyModel\n\n# 使用对应设备进行训练\ndevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)\n\n# 获取每一个 img数据 和 label\n# 训练数据集\ntrain_data = torchvision.datasets.CIFAR10(&quot;./dataset/CIFAR&quot;, train=True, transform=torchvision.transforms.ToTensor(),\n                                          download=True)\ntest_data = torchvision.datasets.CIFAR10(&quot;./dataset/CIFAR&quot;, train=False, transform=torchvision.transforms.ToTensor(),\n                                         download=True)\n\nprint(&quot;训练数据集长度为:{}&quot;.format(len(train_data)))\nprint(&quot;测试数据集长度为:{}&quot;.format(len(test_data)))\n\n# 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式\ntrain_dataloader = DataLoader(train_data, batch_size=64, shuffle=True)\ntest_dataloader = DataLoader(test_data, batch_size=64)\n\nmodel = MyModel()\nmodel.to(device)\n\n# 损失函数\nloss_fn = torch.nn.CrossEntropyLoss()\nloss_fn.to(device)\n\n# 设置优化器\nlearning_rate = 0.01\noptimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)\n\n# 设置网络训练参数\ntotal_train_step = 0\ntotal_test_step = 0\nepoch = 5\n\nwriter = SummaryWriter(&quot;./logs/scalar&quot;)\n\nfor i in range(epoch):\n    print(&quot;----开始第{}轮训练----&quot;.format(i + 1))\n    # 训练开始 对指定的层才有作用\n    model.train()\n\n    for data in train_dataloader:\n        # 获取数据\n        imgs, targets = data\n        # 转换训练设备\n        imgs, targets = imgs.to(device), targets.to(device)\n\n        outputs = model(imgs)\n\n        # 计算loss误差\n        loss = loss_fn(outputs, targets)\n        # 清空梯度\n        optimizer.zero_grad()\n        # 反向传播\n        loss.backward()\n        optimizer.step()\n\n        total_train_step = total_train_step + 1\n\n        if total_train_step % 100 == 0:\n            print(&quot;训练次数：{},loss值：{}&quot;.format(total_train_step, loss.item()))  # 添加item是直接输出tensor对应的数字，不加输出tenso类型的数字\n            writer.add_scalar(&quot;train_loss&quot;, loss.item(), total_train_step)\n\n    # 每次训练一轮后跑一边测试\n    # 验证测试\n    model.eval()\n\n    total_test_loss = 0\n    total_accuracy = 0\n    # 网络模型中的梯度都没有， 不发生变化\n    with torch.no_grad():\n        for img, target in test_data:\n            img = torch.reshape(img, (1, 3, 32, 32))\n            target = torch.tensor([target])\n\n            img, target = img.to(device), target.to(device)\n            # 计算输出\n            output = model(img)\n            loss = loss_fn(output, target)\n            total_test_loss = total_test_loss + loss.item()\n\n            &quot;&quot;&quot;\n            outputs:[0.1, 0.2] 两个类别的概率\n                    [0.3, 0.4]\n            targets:[0, 1] 目标类别\n            predict:[1, 1] 预测类别\n            result :[False, True]\n            &quot;&quot;&quot;\n            # argmax求横向最大值所在的位置\n            accuracy = (output.argmax(1) == target).sum()\n            total_accuracy = total_accuracy + accuracy\n\n    print(&quot;整体测试集的loss：{}&quot;.format(total_test_loss))\n    print(&quot;整体正确率：{}&quot;.format(total_accuracy / len(test_data)))\n\n    writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step)\n    writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / len(test_data), total_test_step)\n\n    total_test_step = total_test_step + 1\n\n    # 保存每一轮的模型\n    torch.save(model, &quot;./weights/model{}.pth&quot;.format(i + 1))\n    # 也可以方式二\n    print(&quot;模型已保存&quot;)\n\nwriter.close()</code></pre>\n<p>read_data.py</p>\n<pre><code class=\"python\">import os\nfrom PIL import Image\nfrom torch.utils.data import Dataset\n\n\nclass MyData(Dataset):\n    def __init__(self, root_dir, label):\n        self.root_dir = root_dir\n        self.label = label\n        self.path = os.path.join(root_dir, label)\n        self.img_names = os.listdir(self.path)\n\n    def __getitem__(self, index):\n        img_name = self.img_names[index]\n        img_path = os.path.join(self.path, img_name)\n        img = Image.open(img_path)\n        label = self.label\n        return img, label\n\n    def __len__(self):\n        return len(self.img_names)\n</code></pre>\n<p>test.py</p>\n<pre><code class=\"python\">import torch\nimport torchvision\nfrom PIL import Image\nfrom model import MyModel\nfrom read_data import MyData\nimport os\n\nans = [&quot;airplane&quot;, &quot;automobile&quot;, &quot;bird&quot;, &quot;cat&quot;, &quot;deer&quot;, &quot;dog&quot;, &quot;frog&quot;, &quot;horse&quot;, &quot;ship&quot;, &quot;truck&quot;]\n\ndevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)\n\nroot_dir = &quot;D:\\\\code\\\\pytorch_learning\\\\CIFAR10\\\\dataset\\\\val&quot;\nlabels_dir = os.listdir(root_dir)\n\ntrans = torchvision.transforms.Compose([torchvision.transforms.Resize((32, 32)),\n                                        torchvision.transforms.ToTensor()])\n\nmodel = torch.load(&quot;./weights/model67.8.pth&quot;)\n\ntot_num = 0\ntot_accuracy = 0\nfor label in labels_dir:\n    cur_accuracy = 0\n    myData = MyData(root_dir, label)\n    tot_num += len(myData)\n    print(&quot;----------当前的图片类型为: {} ----------&quot;.format(label))\n\n    for img, t_label in myData:\n        # 将图片转换为为torch.Size([3, 32, 32])\n        img = trans(img)\n        # img = img.convert(&quot;RGB&quot;)\n        img = torch.reshape(img, (1, 3, 32, 32))\n        img = img.to(device)\n\n        model.eval()\n        with torch.no_grad():\n            output = model(img)\n\n        predict_result = ans[output.argmax(1).item()]\n        cur_accuracy += (predict_result == label)\n        print(&quot;预测结果: {}  &quot;.format(predict_result), &quot;正确&quot; if predict_result == label else &quot;错误&quot;)\n\n    tot_accuracy += cur_accuracy\n    print(&quot;当前种类预测准确率为: {}&quot;.format(cur_accuracy / len(myData)))\nprint(&quot;总预测准确率为: {}&quot;.format(tot_accuracy / tot_num))\n</code></pre>\n<blockquote>\n<p>所有代码： <a href=\"https://github.com/anda522/CIFAR10\" target=\"_blank\" rel=\"noopener\">https://github.com/anda522/CIFAR10</a></p>\n<p>参考视频：<a href=\"https://www.bilibili.com/video/BV1hE411t7RN/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1hE411t7RN/</a></p>\n<p>参考Pytorch文档：<a href=\"https://pytorch.org/docs/stable/nn.html\" target=\"_blank\" rel=\"noopener\">https://pytorch.org/docs/stable/nn.html</a></p>\n</blockquote>\n<p><img src=\"https://wyqz.top/medias/gzh.jpg\" alt></p>\n"},{"title":"nginx知识总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":386249329,"date":"2022-08-06T07:55:55.000Z","password":null,"summary":null,"_content":"\n\n\n# 开关nginx\n\n`Ubuntu`下：\n\n打开`nginx`服务，需要在root权限下（docker容器下也可以用）\n\n```bash\n/etc/init.d/nginx start\n```\n\n重启nginx\n\n```bash\n/sbin/nginx -s reload\n```\n\n\n\n\n\n\n\n# nginx配置\n\n## http块\n\n### server区\n\n进行端口监听，转发流量\n\n- 访问80端口，即浏览器直接输入地址，访问网页，内容位于`/home/hexo/blog`处\n\n```bash\nhttp{\n    server{\n        listen 80; # 监听80端口\n        server_name 101.35.203.216; #访问输的地址，可以填域名\n        root /home/hexo/blog; # 访问文件的目录\n        location / {\n\n        }\n    }\n}\n```\n\n- 域名转发，即访问`game.wyqz.top`域名，转发到本地`10000`端口。\n\n`game.wyqz.top`域名解析到的是服务器IP地址，等于说访问的还是80端口，我们通过域名匹配，将其转发到域名对应的端口处。\n\n```bash\nhttp{\n    server\n    {\n        listen 80;\n        server_name game.wyqz.top;\n\n        location / {\n        proxy_pass  http://127.0.0.1:10000; # 转发规则\n        proxy_set_header Host $proxy_host; # 修改转发请求头，让10000端口的应用可以受到真实的请求\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n        access_log  /www/wwwlogs/access.log;\n    }\n}\n```\n\n- 重定向，即通过80端口访问`vj.wyqz.top`域名（80端口是http访问），直接return一个地址，即对应的**https**地址，实现**https**访问。\n\n```bash\nhttp{\n    server{\n        listen 80;\n        server_name vj.wyqz.top;\n        return  301 https://$host$request_uri; #重定向至https访问。\n        location / {\n        }\n    }\n}\n```\n\n\n\n- https配置\n\n```bash\nserver {\n    # 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块\n    listen       443 ssl;\n    root /home/hexo/blog;\n    # 域名，多个以空格分开\n    server_name  wyqz.top www.wyqz.top;\n    \n    # ssl证书地址\n    ssl_certificate     /etc/nginx/ssl.pem;  # pem文件的路径\n    ssl_certificate_key  /etc/nginx/ssl.key; # key文件的路径\n    \n    # ssl验证相关配置\n    ssl_session_timeout  5m;    #缓存有效期\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议\n    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法\n\n    location / {\n    }\n}\n```\n\n\n\n\n\n# 注意\n\n- server_name 值为`_`时，匹配任何域名。\n","source":"_posts/nginx命令汇总.md","raw":"---\ntitle: nginx知识总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - nginx\ncategories:\n  - nginx\nabbrlink: 386249329\ndate: 2022-08-06 15:55:55\npassword:\nsummary:\n---\n\n\n\n# 开关nginx\n\n`Ubuntu`下：\n\n打开`nginx`服务，需要在root权限下（docker容器下也可以用）\n\n```bash\n/etc/init.d/nginx start\n```\n\n重启nginx\n\n```bash\n/sbin/nginx -s reload\n```\n\n\n\n\n\n\n\n# nginx配置\n\n## http块\n\n### server区\n\n进行端口监听，转发流量\n\n- 访问80端口，即浏览器直接输入地址，访问网页，内容位于`/home/hexo/blog`处\n\n```bash\nhttp{\n    server{\n        listen 80; # 监听80端口\n        server_name 101.35.203.216; #访问输的地址，可以填域名\n        root /home/hexo/blog; # 访问文件的目录\n        location / {\n\n        }\n    }\n}\n```\n\n- 域名转发，即访问`game.wyqz.top`域名，转发到本地`10000`端口。\n\n`game.wyqz.top`域名解析到的是服务器IP地址，等于说访问的还是80端口，我们通过域名匹配，将其转发到域名对应的端口处。\n\n```bash\nhttp{\n    server\n    {\n        listen 80;\n        server_name game.wyqz.top;\n\n        location / {\n        proxy_pass  http://127.0.0.1:10000; # 转发规则\n        proxy_set_header Host $proxy_host; # 修改转发请求头，让10000端口的应用可以受到真实的请求\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n        access_log  /www/wwwlogs/access.log;\n    }\n}\n```\n\n- 重定向，即通过80端口访问`vj.wyqz.top`域名（80端口是http访问），直接return一个地址，即对应的**https**地址，实现**https**访问。\n\n```bash\nhttp{\n    server{\n        listen 80;\n        server_name vj.wyqz.top;\n        return  301 https://$host$request_uri; #重定向至https访问。\n        location / {\n        }\n    }\n}\n```\n\n\n\n- https配置\n\n```bash\nserver {\n    # 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块\n    listen       443 ssl;\n    root /home/hexo/blog;\n    # 域名，多个以空格分开\n    server_name  wyqz.top www.wyqz.top;\n    \n    # ssl证书地址\n    ssl_certificate     /etc/nginx/ssl.pem;  # pem文件的路径\n    ssl_certificate_key  /etc/nginx/ssl.key; # key文件的路径\n    \n    # ssl验证相关配置\n    ssl_session_timeout  5m;    #缓存有效期\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议\n    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法\n\n    location / {\n    }\n}\n```\n\n\n\n\n\n# 注意\n\n- server_name 值为`_`时，匹配任何域名。\n","slug":"nginx命令汇总","published":1,"updated":"2022-09-22T15:58:26.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhg00176kuhmja4ax2i","content":"<h1 id=\"开关nginx\"><a href=\"#开关nginx\" class=\"headerlink\" title=\"开关nginx\"></a>开关nginx</h1><p><code>Ubuntu</code>下：</p>\n<p>打开<code>nginx</code>服务，需要在root权限下（docker容器下也可以用）</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">/etc/init.d/nginx start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>重启nginx</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">/sbin/nginx -s reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h1 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h1><h2 id=\"http块\"><a href=\"#http块\" class=\"headerlink\" title=\"http块\"></a>http块</h2><h3 id=\"server区\"><a href=\"#server区\" class=\"headerlink\" title=\"server区\"></a>server区</h3><p>进行端口监听，转发流量</p>\n<ul>\n<li>访问80端口，即浏览器直接输入地址，访问网页，内容位于<code>/home/hexo/blog</code>处</li>\n</ul>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">http<span class=\"token punctuation\">{</span>\n    server<span class=\"token punctuation\">{</span>\n        listen 80<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\"># 监听80端口</span>\n        server_name 101.35.203.216<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">#访问输的地址，可以填域名</span>\n        root /home/hexo/blog<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\"># 访问文件的目录</span>\n        location / <span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>域名转发，即访问<code>game.wyqz.top</code>域名，转发到本地<code>10000</code>端口。</li>\n</ul>\n<p><code>game.wyqz.top</code>域名解析到的是服务器IP地址，等于说访问的还是80端口，我们通过域名匹配，将其转发到域名对应的端口处。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">http<span class=\"token punctuation\">{</span>\n    server\n    <span class=\"token punctuation\">{</span>\n        listen 80<span class=\"token punctuation\">;</span>\n        server_name game.wyqz.top<span class=\"token punctuation\">;</span>\n\n        location / <span class=\"token punctuation\">{</span>\n        proxy_pass  http://127.0.0.1:10000<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\"># 转发规则</span>\n        proxy_set_header Host <span class=\"token variable\">$proxy_host</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\"># 修改转发请求头，让10000端口的应用可以受到真实的请求</span>\n        proxy_set_header X-Real-IP <span class=\"token variable\">$remote_addr</span><span class=\"token punctuation\">;</span>\n        proxy_set_header X-Forwarded-For <span class=\"token variable\">$proxy_add_x_forwarded_for</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        access_log  /www/wwwlogs/access.log<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>重定向，即通过80端口访问<code>vj.wyqz.top</code>域名（80端口是http访问），直接return一个地址，即对应的<strong>https</strong>地址，实现<strong>https</strong>访问。</li>\n</ul>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">http<span class=\"token punctuation\">{</span>\n    server<span class=\"token punctuation\">{</span>\n        listen 80<span class=\"token punctuation\">;</span>\n        server_name vj.wyqz.top<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span>  301 https://<span class=\"token variable\">$host</span><span class=\"token variable\">$request_uri</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">#重定向至https访问。</span>\n        location / <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>https配置</li>\n</ul>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">server <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块</span>\n    listen       443 ssl<span class=\"token punctuation\">;</span>\n    root /home/hexo/blog<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 域名，多个以空格分开</span>\n    server_name  wyqz.top www.wyqz.top<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># ssl证书地址</span>\n    ssl_certificate     /etc/nginx/ssl.pem<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\"># pem文件的路径</span>\n    ssl_certificate_key  /etc/nginx/ssl.key<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\"># key文件的路径</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># ssl验证相关配置</span>\n    ssl_session_timeout  5m<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">#缓存有效期</span>\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:<span class=\"token operator\">!</span>NULL:<span class=\"token operator\">!</span>aNULL:<span class=\"token operator\">!</span>MD5:<span class=\"token operator\">!</span>ADH:<span class=\"token operator\">!</span>RC4<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">#加密算法</span>\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">#安全链接可选的加密协议</span>\n    ssl_prefer_server_ciphers on<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">#使用服务器端的首选算法</span>\n\n    location / <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><ul>\n<li>server_name 值为<code>_</code>时，匹配任何域名。</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"开关nginx\"><a href=\"#开关nginx\" class=\"headerlink\" title=\"开关nginx\"></a>开关nginx</h1><p><code>Ubuntu</code>下：</p>\n<p>打开<code>nginx</code>服务，需要在root权限下（docker容器下也可以用）</p>\n<pre><code class=\"bash\">/etc/init.d/nginx start</code></pre>\n<p>重启nginx</p>\n<pre><code class=\"bash\">/sbin/nginx -s reload</code></pre>\n<h1 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a>nginx配置</h1><h2 id=\"http块\"><a href=\"#http块\" class=\"headerlink\" title=\"http块\"></a>http块</h2><h3 id=\"server区\"><a href=\"#server区\" class=\"headerlink\" title=\"server区\"></a>server区</h3><p>进行端口监听，转发流量</p>\n<ul>\n<li>访问80端口，即浏览器直接输入地址，访问网页，内容位于<code>/home/hexo/blog</code>处</li>\n</ul>\n<pre><code class=\"bash\">http{\n    server{\n        listen 80; # 监听80端口\n        server_name 101.35.203.216; #访问输的地址，可以填域名\n        root /home/hexo/blog; # 访问文件的目录\n        location / {\n\n        }\n    }\n}</code></pre>\n<ul>\n<li>域名转发，即访问<code>game.wyqz.top</code>域名，转发到本地<code>10000</code>端口。</li>\n</ul>\n<p><code>game.wyqz.top</code>域名解析到的是服务器IP地址，等于说访问的还是80端口，我们通过域名匹配，将其转发到域名对应的端口处。</p>\n<pre><code class=\"bash\">http{\n    server\n    {\n        listen 80;\n        server_name game.wyqz.top;\n\n        location / {\n        proxy_pass  http://127.0.0.1:10000; # 转发规则\n        proxy_set_header Host $proxy_host; # 修改转发请求头，让10000端口的应用可以受到真实的请求\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n        access_log  /www/wwwlogs/access.log;\n    }\n}</code></pre>\n<ul>\n<li>重定向，即通过80端口访问<code>vj.wyqz.top</code>域名（80端口是http访问），直接return一个地址，即对应的<strong>https</strong>地址，实现<strong>https</strong>访问。</li>\n</ul>\n<pre><code class=\"bash\">http{\n    server{\n        listen 80;\n        server_name vj.wyqz.top;\n        return  301 https://$host$request_uri; #重定向至https访问。\n        location / {\n        }\n    }\n}</code></pre>\n<ul>\n<li>https配置</li>\n</ul>\n<pre><code class=\"bash\">server {\n    # 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块\n    listen       443 ssl;\n    root /home/hexo/blog;\n    # 域名，多个以空格分开\n    server_name  wyqz.top www.wyqz.top;\n\n    # ssl证书地址\n    ssl_certificate     /etc/nginx/ssl.pem;  # pem文件的路径\n    ssl_certificate_key  /etc/nginx/ssl.key; # key文件的路径\n\n    # ssl验证相关配置\n    ssl_session_timeout  5m;    #缓存有效期\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议\n    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法\n\n    location / {\n    }\n}</code></pre>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><ul>\n<li>server_name 值为<code>_</code>时，匹配任何域名。</li>\n</ul>\n"},{"title":"《动手学深度学习》笔记","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1060509989,"date":"2023-01-15T11:36:00.000Z","password":null,"summary":null,"_content":"\n>  本笔记主要参考[《动手学深度学习》](https://zh-v2.d2l.ai/index.html) 进行学习记录，不做无意义的书本内容摘抄。\n>\n> 课程网址：https://courses.d2l.ai/zh-v2/\n>\n> 使用深度学习框架为：Pytorch\n\n内容不断更新中$\\cdots \\cdots$\n\n# 1 预备知识\n\n## 1.1 数据处理\n\n## 1.2 线性代数\n\n矩阵运算：矩阵点积、向量积、矩阵乘法\n\n> 向量积非叉积，是矩阵与向量的积。下例可以看做$A$的行向量和向量的点积。\n> $$\n> A = \n> \\begin{pmatrix}\n> a_{11} & \\cdots & a_{1m} \\\\\\\n> a_{21} & \\cdots & a_{2m} \\\\\\\n> \\vdots & \\ddots & \\vdots \\\\\\\n> a_{n1} & \\cdots & a_{nm}\n> \\end{pmatrix} ,\n> \\overrightarrow x = \n> \\begin{pmatrix}\n> x_1 \\\\\\\n> \\vdots \\\\\\\n> x_m\n> \\end{pmatrix}\n> \\\\\\\n> A\\overrightarrow x = \n> \\begin{pmatrix}\n> a_{11}x_1 + \\cdots + a_{1m}x_m \\\\\\\n> \\vdots \\\\\\\n> a_{n1}x_1 + \\cdots + a_{nm}x_m\n> \\end{pmatrix}\n> $$\n> \n\n范数：\n\n$L_1$范数是向量绝对值之和。\n$$\n\\|\\mathbf{x}\\|_1 = \\sum_{i=1}^n \\left|x_i \\right|.\n$$\n$L_2$范数是向量元素根的平方和。\n$$\n\\|\\mathbf{x}\\|_2 = \\sqrt{\\sum_{i=1}^n x_i^2},\n$$\n$L_p$范数是更一般的范数，公式如下：\n$$\n\\|\\mathbf{x}\\|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.\n$$\n\n## 1.3 微积分\n\n# 2 线性神经网络\n\n## 2.1 线性回归\n\n## 2.2 Softmax回归\n\n输出的匹配概率（非负，和为1）\n$$\n\\hat{\\mathbf{y}} = \\mathrm{softmax}(\\mathbf{o})\\quad \\text{其中}\\quad \\hat{y}_j = \\frac{\\exp(o_j)}{\\sum_k \\exp(o_k)}\n$$\n我们选择最优可能的类别\n$$\n\\mathop {argmax}_j \\hat y_j = \\mathop {argmax}_j o_j.\n$$\n损失函数，下式通常称为**交叉熵损失**。（真实概率中只有一个$y_i$为1，其余全部为0）\n$$\nl(\\mathbf{y}, \\hat{\\mathbf{y}}) = - \\sum_{j=1}^q y_j \\log \\hat{y}_j.\n$$\n\n> 交叉熵通常来衡量两个概率的区别：\n> $$\n> H(p, q) = \\sum \\limits_i - p_i log(q_i)\n> $$\n\n损失函数的导数\n$$\n\\partial_{o_j} l(\\mathbf{y}, \\hat{\\mathbf{y}}) = \\frac{\\exp(o_j)}{\\sum_{k=1}^q \\exp(o_k)} - y_j = \\mathrm{softmax}(\\mathbf{o})_j - y_j.\n$$\n\n## 2.3 损失函数\n\n- 均方损失（L2 Loss）\n\n$$\nl(y, y{'}) =\\frac{1}{2}(y - y{'})^2\n$$\n\n- 绝对值损失（L1 Loss）\n\n$$\nl(y,y{'}) = |y - y{'}|\n$$\n\n- Huber's Robust Loss 鲁棒损失\n\n$$\nl(y, y{'}) = \n\\begin{cases}\n|y - y{'}| & if |y - y{'}| \\gt 1 \\\\\\\n\\frac{1}{2}(y - y{'})^2 & otherwise\n\\end{cases}\n$$\n\n\n\n","source":"_posts/《动手学深度学习》笔记.md","raw":"---\ntitle: 《动手学深度学习》笔记\ntop: false\ncover: false\ntoc: true\nmathjax: true\nabbrlink: 1060509989\ndate: 2023-01-15 19:36:00\npassword:\nsummary:\ntags:\n  - 学习总结\n  - DeepLearning\ncategories:\n  - 知识总结\n---\n\n>  本笔记主要参考[《动手学深度学习》](https://zh-v2.d2l.ai/index.html) 进行学习记录，不做无意义的书本内容摘抄。\n>\n> 课程网址：https://courses.d2l.ai/zh-v2/\n>\n> 使用深度学习框架为：Pytorch\n\n内容不断更新中$\\cdots \\cdots$\n\n# 1 预备知识\n\n## 1.1 数据处理\n\n## 1.2 线性代数\n\n矩阵运算：矩阵点积、向量积、矩阵乘法\n\n> 向量积非叉积，是矩阵与向量的积。下例可以看做$A$的行向量和向量的点积。\n> $$\n> A = \n> \\begin{pmatrix}\n> a_{11} & \\cdots & a_{1m} \\\\\\\n> a_{21} & \\cdots & a_{2m} \\\\\\\n> \\vdots & \\ddots & \\vdots \\\\\\\n> a_{n1} & \\cdots & a_{nm}\n> \\end{pmatrix} ,\n> \\overrightarrow x = \n> \\begin{pmatrix}\n> x_1 \\\\\\\n> \\vdots \\\\\\\n> x_m\n> \\end{pmatrix}\n> \\\\\\\n> A\\overrightarrow x = \n> \\begin{pmatrix}\n> a_{11}x_1 + \\cdots + a_{1m}x_m \\\\\\\n> \\vdots \\\\\\\n> a_{n1}x_1 + \\cdots + a_{nm}x_m\n> \\end{pmatrix}\n> $$\n> \n\n范数：\n\n$L_1$范数是向量绝对值之和。\n$$\n\\|\\mathbf{x}\\|_1 = \\sum_{i=1}^n \\left|x_i \\right|.\n$$\n$L_2$范数是向量元素根的平方和。\n$$\n\\|\\mathbf{x}\\|_2 = \\sqrt{\\sum_{i=1}^n x_i^2},\n$$\n$L_p$范数是更一般的范数，公式如下：\n$$\n\\|\\mathbf{x}\\|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.\n$$\n\n## 1.3 微积分\n\n# 2 线性神经网络\n\n## 2.1 线性回归\n\n## 2.2 Softmax回归\n\n输出的匹配概率（非负，和为1）\n$$\n\\hat{\\mathbf{y}} = \\mathrm{softmax}(\\mathbf{o})\\quad \\text{其中}\\quad \\hat{y}_j = \\frac{\\exp(o_j)}{\\sum_k \\exp(o_k)}\n$$\n我们选择最优可能的类别\n$$\n\\mathop {argmax}_j \\hat y_j = \\mathop {argmax}_j o_j.\n$$\n损失函数，下式通常称为**交叉熵损失**。（真实概率中只有一个$y_i$为1，其余全部为0）\n$$\nl(\\mathbf{y}, \\hat{\\mathbf{y}}) = - \\sum_{j=1}^q y_j \\log \\hat{y}_j.\n$$\n\n> 交叉熵通常来衡量两个概率的区别：\n> $$\n> H(p, q) = \\sum \\limits_i - p_i log(q_i)\n> $$\n\n损失函数的导数\n$$\n\\partial_{o_j} l(\\mathbf{y}, \\hat{\\mathbf{y}}) = \\frac{\\exp(o_j)}{\\sum_{k=1}^q \\exp(o_k)} - y_j = \\mathrm{softmax}(\\mathbf{o})_j - y_j.\n$$\n\n## 2.3 损失函数\n\n- 均方损失（L2 Loss）\n\n$$\nl(y, y{'}) =\\frac{1}{2}(y - y{'})^2\n$$\n\n- 绝对值损失（L1 Loss）\n\n$$\nl(y,y{'}) = |y - y{'}|\n$$\n\n- Huber's Robust Loss 鲁棒损失\n\n$$\nl(y, y{'}) = \n\\begin{cases}\n|y - y{'}| & if |y - y{'}| \\gt 1 \\\\\\\n\\frac{1}{2}(y - y{'})^2 & otherwise\n\\end{cases}\n$$\n\n\n\n","slug":"《动手学深度学习》笔记","published":1,"updated":"2023-01-18T04:36:13.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhm001b6kuhj64wlu4g","content":"<blockquote>\n<p> 本笔记主要参考<a href=\"https://zh-v2.d2l.ai/index.html\" target=\"_blank\" rel=\"noopener\">《动手学深度学习》</a> 进行学习记录，不做无意义的书本内容摘抄。</p>\n<p>课程网址：<a href=\"https://courses.d2l.ai/zh-v2/\" target=\"_blank\" rel=\"noopener\">https://courses.d2l.ai/zh-v2/</a></p>\n<p>使用深度学习框架为：Pytorch</p>\n</blockquote>\n<p>内容不断更新中$\\cdots \\cdots$</p>\n<h1 id=\"1-预备知识\"><a href=\"#1-预备知识\" class=\"headerlink\" title=\"1 预备知识\"></a>1 预备知识</h1><h2 id=\"1-1-数据处理\"><a href=\"#1-1-数据处理\" class=\"headerlink\" title=\"1.1 数据处理\"></a>1.1 数据处理</h2><h2 id=\"1-2-线性代数\"><a href=\"#1-2-线性代数\" class=\"headerlink\" title=\"1.2 线性代数\"></a>1.2 线性代数</h2><p>矩阵运算：矩阵点积、向量积、矩阵乘法</p>\n<blockquote>\n<p>向量积非叉积，是矩阵与向量的积。下例可以看做$A$的行向量和向量的点积。<br>$$<br>A =<br>\\begin{pmatrix}<br>a_{11} &amp; \\cdots &amp; a_{1m} \\\\<br>a_{21} &amp; \\cdots &amp; a_{2m} \\\\<br>\\vdots &amp; \\ddots &amp; \\vdots \\\\<br>a_{n1} &amp; \\cdots &amp; a_{nm}<br>\\end{pmatrix} ,<br>\\overrightarrow x =<br>\\begin{pmatrix}<br>x_1 \\\\<br>\\vdots \\\\<br>x_m<br>\\end{pmatrix}<br>\\\\<br>A\\overrightarrow x =<br>\\begin{pmatrix}<br>a_{11}x_1 + \\cdots + a_{1m}x_m \\\\<br>\\vdots \\\\<br>a_{n1}x_1 + \\cdots + a_{nm}x_m<br>\\end{pmatrix}<br>$$</p>\n</blockquote>\n<p>范数：</p>\n<p>$L_1$范数是向量绝对值之和。<br>$$<br>|\\mathbf{x}|_1 = \\sum_{i=1}^n \\left|x_i \\right|.<br>$$<br>$L_2$范数是向量元素根的平方和。<br>$$<br>|\\mathbf{x}|_2 = \\sqrt{\\sum_{i=1}^n x_i^2},<br>$$<br>$L_p$范数是更一般的范数，公式如下：<br>$$<br>|\\mathbf{x}|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.<br>$$</p>\n<h2 id=\"1-3-微积分\"><a href=\"#1-3-微积分\" class=\"headerlink\" title=\"1.3 微积分\"></a>1.3 微积分</h2><h1 id=\"2-线性神经网络\"><a href=\"#2-线性神经网络\" class=\"headerlink\" title=\"2 线性神经网络\"></a>2 线性神经网络</h1><h2 id=\"2-1-线性回归\"><a href=\"#2-1-线性回归\" class=\"headerlink\" title=\"2.1 线性回归\"></a>2.1 线性回归</h2><h2 id=\"2-2-Softmax回归\"><a href=\"#2-2-Softmax回归\" class=\"headerlink\" title=\"2.2 Softmax回归\"></a>2.2 Softmax回归</h2><p>输出的匹配概率（非负，和为1）<br>$$<br>\\hat{\\mathbf{y}} = \\mathrm{softmax}(\\mathbf{o})\\quad \\text{其中}\\quad \\hat{y}_j = \\frac{\\exp(o_j)}{\\sum_k \\exp(o_k)}<br>$$<br>我们选择最优可能的类别<br>$$<br>\\mathop {argmax}_j \\hat y_j = \\mathop {argmax}_j o_j.<br>$$<br>损失函数，下式通常称为<strong>交叉熵损失</strong>。（真实概率中只有一个$y_i$为1，其余全部为0）<br>$$<br>l(\\mathbf{y}, \\hat{\\mathbf{y}}) = - \\sum_{j=1}^q y_j \\log \\hat{y}_j.<br>$$</p>\n<blockquote>\n<p>交叉熵通常来衡量两个概率的区别：<br>$$<br>H(p, q) = \\sum \\limits_i - p_i log(q_i)<br>$$</p>\n</blockquote>\n<p>损失函数的导数<br>$$<br>\\partial_{o_j} l(\\mathbf{y}, \\hat{\\mathbf{y}}) = \\frac{\\exp(o_j)}{\\sum_{k=1}^q \\exp(o_k)} - y_j = \\mathrm{softmax}(\\mathbf{o})_j - y_j.<br>$$</p>\n<h2 id=\"2-3-损失函数\"><a href=\"#2-3-损失函数\" class=\"headerlink\" title=\"2.3 损失函数\"></a>2.3 损失函数</h2><ul>\n<li>均方损失（L2 Loss）</li>\n</ul>\n<p>$$<br>l(y, y{‘}) =\\frac{1}{2}(y - y{‘})^2<br>$$</p>\n<ul>\n<li>绝对值损失（L1 Loss）</li>\n</ul>\n<p>$$<br>l(y,y{‘}) = |y - y{‘}|<br>$$</p>\n<ul>\n<li>Huber’s Robust Loss 鲁棒损失</li>\n</ul>\n<p>$$<br>l(y, y{‘}) =<br>\\begin{cases}<br>|y - y{‘}| &amp; if |y - y{‘}| \\gt 1 \\\\<br>\\frac{1}{2}(y - y{‘})^2 &amp; otherwise<br>\\end{cases}<br>$$</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<blockquote>\n<p> 本笔记主要参考<a href=\"https://zh-v2.d2l.ai/index.html\" target=\"_blank\" rel=\"noopener\">《动手学深度学习》</a> 进行学习记录，不做无意义的书本内容摘抄。</p>\n<p>课程网址：<a href=\"https://courses.d2l.ai/zh-v2/\" target=\"_blank\" rel=\"noopener\">https://courses.d2l.ai/zh-v2/</a></p>\n<p>使用深度学习框架为：Pytorch</p>\n</blockquote>\n<p>内容不断更新中$\\cdots \\cdots$</p>\n<h1 id=\"1-预备知识\"><a href=\"#1-预备知识\" class=\"headerlink\" title=\"1 预备知识\"></a>1 预备知识</h1><h2 id=\"1-1-数据处理\"><a href=\"#1-1-数据处理\" class=\"headerlink\" title=\"1.1 数据处理\"></a>1.1 数据处理</h2><h2 id=\"1-2-线性代数\"><a href=\"#1-2-线性代数\" class=\"headerlink\" title=\"1.2 线性代数\"></a>1.2 线性代数</h2><p>矩阵运算：矩阵点积、向量积、矩阵乘法</p>\n<blockquote>\n<p>向量积非叉积，是矩阵与向量的积。下例可以看做$A$的行向量和向量的点积。<br>$$<br>A =<br>\\begin{pmatrix}<br>a_{11} &amp; \\cdots &amp; a_{1m} \\\\<br>a_{21} &amp; \\cdots &amp; a_{2m} \\\\<br>\\vdots &amp; \\ddots &amp; \\vdots \\\\<br>a_{n1} &amp; \\cdots &amp; a_{nm}<br>\\end{pmatrix} ,<br>\\overrightarrow x =<br>\\begin{pmatrix}<br>x_1 \\\\<br>\\vdots \\\\<br>x_m<br>\\end{pmatrix}<br>\\\\<br>A\\overrightarrow x =<br>\\begin{pmatrix}<br>a_{11}x_1 + \\cdots + a_{1m}x_m \\\\<br>\\vdots \\\\<br>a_{n1}x_1 + \\cdots + a_{nm}x_m<br>\\end{pmatrix}<br>$$</p>\n</blockquote>\n<p>范数：</p>\n<p>$L_1$范数是向量绝对值之和。<br>$$<br>|\\mathbf{x}|_1 = \\sum_{i=1}^n \\left|x_i \\right|.<br>$$<br>$L_2$范数是向量元素根的平方和。<br>$$<br>|\\mathbf{x}|_2 = \\sqrt{\\sum_{i=1}^n x_i^2},<br>$$<br>$L_p$范数是更一般的范数，公式如下：<br>$$<br>|\\mathbf{x}|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.<br>$$</p>\n<h2 id=\"1-3-微积分\"><a href=\"#1-3-微积分\" class=\"headerlink\" title=\"1.3 微积分\"></a>1.3 微积分</h2><h1 id=\"2-线性神经网络\"><a href=\"#2-线性神经网络\" class=\"headerlink\" title=\"2 线性神经网络\"></a>2 线性神经网络</h1><h2 id=\"2-1-线性回归\"><a href=\"#2-1-线性回归\" class=\"headerlink\" title=\"2.1 线性回归\"></a>2.1 线性回归</h2><h2 id=\"2-2-Softmax回归\"><a href=\"#2-2-Softmax回归\" class=\"headerlink\" title=\"2.2 Softmax回归\"></a>2.2 Softmax回归</h2><p>输出的匹配概率（非负，和为1）<br>$$<br>\\hat{\\mathbf{y}} = \\mathrm{softmax}(\\mathbf{o})\\quad \\text{其中}\\quad \\hat{y}_j = \\frac{\\exp(o_j)}{\\sum_k \\exp(o_k)}<br>$$<br>我们选择最优可能的类别<br>$$<br>\\mathop {argmax}_j \\hat y_j = \\mathop {argmax}_j o_j.<br>$$<br>损失函数，下式通常称为<strong>交叉熵损失</strong>。（真实概率中只有一个$y_i$为1，其余全部为0）<br>$$<br>l(\\mathbf{y}, \\hat{\\mathbf{y}}) = - \\sum_{j=1}^q y_j \\log \\hat{y}_j.<br>$$</p>\n<blockquote>\n<p>交叉熵通常来衡量两个概率的区别：<br>$$<br>H(p, q) = \\sum \\limits_i - p_i log(q_i)<br>$$</p>\n</blockquote>\n<p>损失函数的导数<br>$$<br>\\partial_{o_j} l(\\mathbf{y}, \\hat{\\mathbf{y}}) = \\frac{\\exp(o_j)}{\\sum_{k=1}^q \\exp(o_k)} - y_j = \\mathrm{softmax}(\\mathbf{o})_j - y_j.<br>$$</p>\n<h2 id=\"2-3-损失函数\"><a href=\"#2-3-损失函数\" class=\"headerlink\" title=\"2.3 损失函数\"></a>2.3 损失函数</h2><ul>\n<li>均方损失（L2 Loss）</li>\n</ul>\n<p>$$<br>l(y, y{‘}) =\\frac{1}{2}(y - y{‘})^2<br>$$</p>\n<ul>\n<li>绝对值损失（L1 Loss）</li>\n</ul>\n<p>$$<br>l(y,y{‘}) = |y - y{‘}|<br>$$</p>\n<ul>\n<li>Huber’s Robust Loss 鲁棒损失</li>\n</ul>\n<p>$$<br>l(y, y{‘}) =<br>\\begin{cases}<br>|y - y{‘}| &amp; if |y - y{‘}| \\gt 1 \\\\<br>\\frac{1}{2}(y - y{‘})^2 &amp; otherwise<br>\\end{cases}<br>$$</p>\n"},{"title":"树上拓扑序计数|树形DP","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":2852940489,"date":"2022-08-20T02:12:01.000Z","password":null,"summary":null,"_content":"\n# 树上拓扑序计数|树形DP\n\n[https://ac.nowcoder.com/acm/contest/38630/F](https://ac.nowcoder.com/acm/contest/38630/F)\n\n## 思路\n\n每个公司是一棵树，然后每个公司可以看做连在一个虚拟的根上。每个公司的计算方案实际上就是计算这棵树的拓扑序的个数。用树形DP求解。\n\n$f[u]$ : 以`u`为根的子树的拓扑序数\n\n$sz[u]$ ： 以`u`为根的子树的大小（节点的数量）\n\n当树为二叉树时，将两个子树`v1,v2`进行合并：即先把各子树的方案数乘起来算出总方案，然后考虑各子树元素的相对排列顺序，即在总的节点个数中选`sz[v1]`排在前面的`sz[v1]`个位置，剩下的排在后面，保证每颗子树的相对拓扑序不变。\n\n$$\nf[u] = f[v1] \\cdot f[v2] \\cdot C(sz[v1] + sz[v2], sz[v1])\n$$\n\n> 例子：`u`节点有四颗子树，子树大小分别为`a, b, c, d`，则方案数为：\n>\n> $f[u] = f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot C(a+b+c+d, a)\\cdot C(b+c+d, b)\\cdot C(c+d,c)$\n>\n> $=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!(b+c+d)!}\\cdot \\frac{(b+c+d)!}{b!(c+d)!}\\cdot \\frac{(c+d)!}{c!d!}$\n>\n> $=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!b!c!d!}$\n\n推广到一般树：\n$$\nf[u] = (\\prod \\limits_{v \\in son(u)} f[v] ) \\cdot \\frac{(sz[u] - 1)!}{\\prod \\limits_{v \\in son(u)}sz[v]!}\n$$\n换一下形式：\n$$\nf[u] = (sz[u] - 1)! \\cdot \\prod \\limits_{v \\in son(u)} \\frac{f[v]}{sz[v]!}\n$$\n\n\n拓扑序数量还可以这样计算：\n$$\nn! \\cdot \\prod \\limits_{i = 1} ^ n \\frac{1}{sz[i]}\n$$\n\n\n## 代码1\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nll fac[N], inv[N];\nll ksm(ll a, ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = res * a % mod;\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res % mod;\n}\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\n\tll ans = 1, tot = 1;\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\t\tcnt += c;\n\t\tvector<vi> g(c);\n\n\t\tfor(int j = 1; j < c; j++)\n\t\t{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tu--;\n\t\t\tg[u].push_back(j);\n\t\t}\n\n\t\tvi sz(c, 1);\n\t\tvl f(c, 1);\n\t\tfunction<void(int)> dfs = [&](int u)\n\t\t{\n\t\t\tfor(auto v : g[u])\n\t\t\t{\n\t\t\t\tdfs(v);\n\t\t\t\tsz[u] += sz[v];\n\t\t\t\t(f[u] *= f[v] * inv[sz[v]] % mod) %= mod;\n\t\t\t}\n\t\t\t(f[u] *= fac[sz[u] - 1]) %= mod;\n\t\t};\n\t\tdfs(0);\n\t\t(tot *= f[0] * inv[c] % mod) %= mod;\n\t}\n\tans = ans * tot % mod * fac[cnt] % mod;\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tfac[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tinv[N - 1] = ksm(fac[N - 1], mod - 2);\n\tfor(int i = N - 2; i >= 1; i--)\n\t\tinv[i] = (i + 1) * inv[i + 1] % mod;\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n## 代码2\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += mod;\n    }\n    if (x >= mod) {\n        x -= mod;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, ll b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(ll x) : x(norm(x % mod)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(mod - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, mod - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = ll(x) * rhs.x % mod;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        ll v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\n\tZ ans = 1;\n\tint tot = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\n\t\tfor(int j = 0; j < c; j++)\n\t\t\tans *= ++tot;\n\n\t\tvector<vi> g(c);\n\t\tfor(int j = 1; j < c; j++)\n\t\t{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tu--;\n\t\t\tg[u].push_back(j);\n\t\t}\n\n\t\tvi sz(c, 1);\n\n\t\tfunction<void(int)> dfs = [&](int u)\n\t\t{\n\t\t\tfor(auto v : g[u])\n\t\t\t{\n\t\t\t\tdfs(v);\n\t\t\t\tsz[u] += sz[v];\n\t\t\t}\n\t\t\tans /= sz[u];\n\t\t};\n\t\tdfs(0);\n\t}\n\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n拓扑序计数相关题目：\n\nHDU4661 ： [http://acm.hdu.edu.cn/showproblem.php?pid=4661](http://acm.hdu.edu.cn/showproblem.php?pid=4661)\n","source":"_posts/树上拓扑序计数.md","raw":"---\ntitle: 树上拓扑序计数|树形DP\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 树形DP\n  - 组合数学\ncategories:\n  - 树形DP\nabbrlink: 2852940489\ndate: 2022-08-20 10:12:01\npassword:\nsummary:\n---\n\n# 树上拓扑序计数|树形DP\n\n[https://ac.nowcoder.com/acm/contest/38630/F](https://ac.nowcoder.com/acm/contest/38630/F)\n\n## 思路\n\n每个公司是一棵树，然后每个公司可以看做连在一个虚拟的根上。每个公司的计算方案实际上就是计算这棵树的拓扑序的个数。用树形DP求解。\n\n$f[u]$ : 以`u`为根的子树的拓扑序数\n\n$sz[u]$ ： 以`u`为根的子树的大小（节点的数量）\n\n当树为二叉树时，将两个子树`v1,v2`进行合并：即先把各子树的方案数乘起来算出总方案，然后考虑各子树元素的相对排列顺序，即在总的节点个数中选`sz[v1]`排在前面的`sz[v1]`个位置，剩下的排在后面，保证每颗子树的相对拓扑序不变。\n\n$$\nf[u] = f[v1] \\cdot f[v2] \\cdot C(sz[v1] + sz[v2], sz[v1])\n$$\n\n> 例子：`u`节点有四颗子树，子树大小分别为`a, b, c, d`，则方案数为：\n>\n> $f[u] = f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot C(a+b+c+d, a)\\cdot C(b+c+d, b)\\cdot C(c+d,c)$\n>\n> $=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!(b+c+d)!}\\cdot \\frac{(b+c+d)!}{b!(c+d)!}\\cdot \\frac{(c+d)!}{c!d!}$\n>\n> $=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!b!c!d!}$\n\n推广到一般树：\n$$\nf[u] = (\\prod \\limits_{v \\in son(u)} f[v] ) \\cdot \\frac{(sz[u] - 1)!}{\\prod \\limits_{v \\in son(u)}sz[v]!}\n$$\n换一下形式：\n$$\nf[u] = (sz[u] - 1)! \\cdot \\prod \\limits_{v \\in son(u)} \\frac{f[v]}{sz[v]!}\n$$\n\n\n拓扑序数量还可以这样计算：\n$$\nn! \\cdot \\prod \\limits_{i = 1} ^ n \\frac{1}{sz[i]}\n$$\n\n\n## 代码1\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nll fac[N], inv[N];\nll ksm(ll a, ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = res * a % mod;\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res % mod;\n}\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\n\tll ans = 1, tot = 1;\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\t\tcnt += c;\n\t\tvector<vi> g(c);\n\n\t\tfor(int j = 1; j < c; j++)\n\t\t{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tu--;\n\t\t\tg[u].push_back(j);\n\t\t}\n\n\t\tvi sz(c, 1);\n\t\tvl f(c, 1);\n\t\tfunction<void(int)> dfs = [&](int u)\n\t\t{\n\t\t\tfor(auto v : g[u])\n\t\t\t{\n\t\t\t\tdfs(v);\n\t\t\t\tsz[u] += sz[v];\n\t\t\t\t(f[u] *= f[v] * inv[sz[v]] % mod) %= mod;\n\t\t\t}\n\t\t\t(f[u] *= fac[sz[u] - 1]) %= mod;\n\t\t};\n\t\tdfs(0);\n\t\t(tot *= f[0] * inv[c] % mod) %= mod;\n\t}\n\tans = ans * tot % mod * fac[cnt] % mod;\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tfac[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tinv[N - 1] = ksm(fac[N - 1], mod - 2);\n\tfor(int i = N - 2; i >= 1; i--)\n\t\tinv[i] = (i + 1) * inv[i + 1] % mod;\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n## 代码2\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing arr = array<int, 3>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += mod;\n    }\n    if (x >= mod) {\n        x -= mod;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, ll b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(ll x) : x(norm(x % mod)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(mod - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, mod - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = ll(x) * rhs.x % mod;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        ll v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\n\tZ ans = 1;\n\tint tot = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint c;\n\t\tcin >> c;\n\n\t\tfor(int j = 0; j < c; j++)\n\t\t\tans *= ++tot;\n\n\t\tvector<vi> g(c);\n\t\tfor(int j = 1; j < c; j++)\n\t\t{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tu--;\n\t\t\tg[u].push_back(j);\n\t\t}\n\n\t\tvi sz(c, 1);\n\n\t\tfunction<void(int)> dfs = [&](int u)\n\t\t{\n\t\t\tfor(auto v : g[u])\n\t\t\t{\n\t\t\t\tdfs(v);\n\t\t\t\tsz[u] += sz[v];\n\t\t\t}\n\t\t\tans /= sz[u];\n\t\t};\n\t\tdfs(0);\n\t}\n\n\tcout << ans << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tt = 1;\n\t// cin >> t;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n```\n\n\n\n拓扑序计数相关题目：\n\nHDU4661 ： [http://acm.hdu.edu.cn/showproblem.php?pid=4661](http://acm.hdu.edu.cn/showproblem.php?pid=4661)\n","slug":"树上拓扑序计数","published":1,"updated":"2022-08-20T02:27:58.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhn001e6kuhodav1uw2","content":"<h1 id=\"树上拓扑序计数-树形DP\"><a href=\"#树上拓扑序计数-树形DP\" class=\"headerlink\" title=\"树上拓扑序计数|树形DP\"></a>树上拓扑序计数|树形DP</h1><p><a href=\"https://ac.nowcoder.com/acm/contest/38630/F\" target=\"_blank\" rel=\"noopener\">https://ac.nowcoder.com/acm/contest/38630/F</a></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>每个公司是一棵树，然后每个公司可以看做连在一个虚拟的根上。每个公司的计算方案实际上就是计算这棵树的拓扑序的个数。用树形DP求解。</p>\n<p>$f[u]$ : 以<code>u</code>为根的子树的拓扑序数</p>\n<p>$sz[u]$ ： 以<code>u</code>为根的子树的大小（节点的数量）</p>\n<p>当树为二叉树时，将两个子树<code>v1,v2</code>进行合并：即先把各子树的方案数乘起来算出总方案，然后考虑各子树元素的相对排列顺序，即在总的节点个数中选<code>sz[v1]</code>排在前面的<code>sz[v1]</code>个位置，剩下的排在后面，保证每颗子树的相对拓扑序不变。</p>\n<p>$$<br>f[u] = f[v1] \\cdot f[v2] \\cdot C(sz[v1] + sz[v2], sz[v1])<br>$$</p>\n<blockquote>\n<p>例子：<code>u</code>节点有四颗子树，子树大小分别为<code>a, b, c, d</code>，则方案数为：</p>\n<p>$f[u] = f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot C(a+b+c+d, a)\\cdot C(b+c+d, b)\\cdot C(c+d,c)$</p>\n<p>$=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!(b+c+d)!}\\cdot \\frac{(b+c+d)!}{b!(c+d)!}\\cdot \\frac{(c+d)!}{c!d!}$</p>\n<p>$=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!b!c!d!}$</p>\n</blockquote>\n<p>推广到一般树：<br>$$<br>f[u] = (\\prod \\limits_{v \\in son(u)} f[v] ) \\cdot \\frac{(sz[u] - 1)!}{\\prod \\limits_{v \\in son(u)}sz[v]!}<br>$$<br>换一下形式：<br>$$<br>f[u] = (sz[u] - 1)! \\cdot \\prod \\limits_{v \\in son(u)} \\frac{f[v]}{sz[v]!}<br>$$</p>\n<p>拓扑序数量还可以这样计算：<br>$$<br>n! \\cdot \\prod \\limits_{i = 1} ^ n \\frac{1}{sz[i]}<br>$$</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\nll fac<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> inv<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nll <span class=\"token function\">ksm</span><span class=\"token punctuation\">(</span>ll a<span class=\"token punctuation\">,</span> ll b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> res <span class=\"token operator\">=</span> res <span class=\"token operator\">*</span> a <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> a <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> res <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> tot <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> c<span class=\"token punctuation\">;</span>\n        cnt <span class=\"token operator\">+</span><span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span>vi<span class=\"token operator\">></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">;</span>\n            cin <span class=\"token operator\">>></span> u<span class=\"token punctuation\">;</span>\n            u<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        vi <span class=\"token function\">sz</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vl <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> dfs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                sz<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span><span class=\"token operator\">=</span> f<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>sz<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span><span class=\"token operator\">=</span> fac<span class=\"token punctuation\">[</span>sz<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">(</span>tot <span class=\"token operator\">*</span><span class=\"token operator\">=</span> f<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ans <span class=\"token operator\">=</span> ans <span class=\"token operator\">*</span> tot <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> fac<span class=\"token punctuation\">[</span>cnt<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    fac<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        fac<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fac<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    inv<span class=\"token punctuation\">[</span>N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">ksm</span><span class=\"token punctuation\">(</span>fac<span class=\"token punctuation\">[</span>N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> N <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"代码2\"><a href=\"#代码2\" class=\"headerlink\" title=\"代码2\"></a>代码2</h2><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pii <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> pll <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>ll<span class=\"token punctuation\">,</span> ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> arr <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vi <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> vl <span class=\"token operator\">=</span> vector<span class=\"token operator\">&lt;</span>ll<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span> <span class=\"token operator\">+</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// assume -P &lt;= x &lt; 2P</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">norm</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">+</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">>=</span> mod<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">-</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\nT <span class=\"token function\">power</span><span class=\"token punctuation\">(</span>T a<span class=\"token punctuation\">,</span> ll b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    T res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> b<span class=\"token punctuation\">;</span> b <span class=\"token operator\">/</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">*</span><span class=\"token operator\">=</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">%</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            res <span class=\"token operator\">*</span><span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">struct</span> Z <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span>ll x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token keyword\">operator</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span><span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>mod <span class=\"token operator\">-</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token function\">inv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">power</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">ll</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> rhs<span class=\"token punctuation\">.</span>x <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> rhs<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">-</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">norm</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> rhs<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Z <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">/</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span> <span class=\"token operator\">*</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">.</span><span class=\"token function\">inv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">*</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">+</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">-</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> Z <span class=\"token keyword\">operator</span><span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>lhs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Z res <span class=\"token operator\">=</span> lhs<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">/</span><span class=\"token operator\">=</span> rhs<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> std<span class=\"token operator\">::</span>istream <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>istream <span class=\"token operator\">&amp;</span>is<span class=\"token punctuation\">,</span> Z <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ll v<span class=\"token punctuation\">;</span>\n        is <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> <span class=\"token function\">Z</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> is<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> std<span class=\"token operator\">::</span>ostream <span class=\"token operator\">&amp;</span><span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>ostream <span class=\"token operator\">&amp;</span>os<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Z <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> os <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n\n    Z ans <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> tot <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> c<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            ans <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token operator\">++</span>tot<span class=\"token punctuation\">;</span>\n\n        vector<span class=\"token operator\">&lt;</span>vi<span class=\"token operator\">></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">;</span>\n            cin <span class=\"token operator\">>></span> u<span class=\"token punctuation\">;</span>\n            u<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        vi <span class=\"token function\">sz</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> dfs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> v <span class=\"token operator\">:</span> g<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                sz<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            ans <span class=\"token operator\">/</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    cout <span class=\"token operator\">&lt;&lt;</span> ans <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>拓扑序计数相关题目：</p>\n<p>HDU4661 ： <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4661\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=4661</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"树上拓扑序计数-树形DP\"><a href=\"#树上拓扑序计数-树形DP\" class=\"headerlink\" title=\"树上拓扑序计数|树形DP\"></a>树上拓扑序计数|树形DP</h1><p><a href=\"https://ac.nowcoder.com/acm/contest/38630/F\" target=\"_blank\" rel=\"noopener\">https://ac.nowcoder.com/acm/contest/38630/F</a></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>每个公司是一棵树，然后每个公司可以看做连在一个虚拟的根上。每个公司的计算方案实际上就是计算这棵树的拓扑序的个数。用树形DP求解。</p>\n<p>$f[u]$ : 以<code>u</code>为根的子树的拓扑序数</p>\n<p>$sz[u]$ ： 以<code>u</code>为根的子树的大小（节点的数量）</p>\n<p>当树为二叉树时，将两个子树<code>v1,v2</code>进行合并：即先把各子树的方案数乘起来算出总方案，然后考虑各子树元素的相对排列顺序，即在总的节点个数中选<code>sz[v1]</code>排在前面的<code>sz[v1]</code>个位置，剩下的排在后面，保证每颗子树的相对拓扑序不变。</p>\n<p>$$<br>f[u] = f[v1] \\cdot f[v2] \\cdot C(sz[v1] + sz[v2], sz[v1])<br>$$</p>\n<blockquote>\n<p>例子：<code>u</code>节点有四颗子树，子树大小分别为<code>a, b, c, d</code>，则方案数为：</p>\n<p>$f[u] = f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot C(a+b+c+d, a)\\cdot C(b+c+d, b)\\cdot C(c+d,c)$</p>\n<p>$=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!(b+c+d)!}\\cdot \\frac{(b+c+d)!}{b!(c+d)!}\\cdot \\frac{(c+d)!}{c!d!}$</p>\n<p>$=f[a]\\cdot f[b]\\cdot f[c]\\cdot f[d]\\cdot \\frac{(a+b+c+d)!}{a!b!c!d!}$</p>\n</blockquote>\n<p>推广到一般树：<br>$$<br>f[u] = (\\prod \\limits_{v \\in son(u)} f[v] ) \\cdot \\frac{(sz[u] - 1)!}{\\prod \\limits_{v \\in son(u)}sz[v]!}<br>$$<br>换一下形式：<br>$$<br>f[u] = (sz[u] - 1)! \\cdot \\prod \\limits_{v \\in son(u)} \\frac{f[v]}{sz[v]!}<br>$$</p>\n<p>拓扑序数量还可以这样计算：<br>$$<br>n! \\cdot \\prod \\limits_{i = 1} ^ n \\frac{1}{sz[i]}<br>$$</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\nll fac[N], inv[N];\nll ksm(ll a, ll b)\n{\n    ll res = 1;\n    while(b)\n    {\n        if(b &amp; 1) res = res * a % mod;\n        b &gt;&gt;= 1;\n        a = a * a % mod;\n    }\n    return res % mod;\n}\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n\n    ll ans = 1, tot = 1;\n    int cnt = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        int c;\n        cin &gt;&gt; c;\n        cnt += c;\n        vector&lt;vi&gt; g(c);\n\n        for(int j = 1; j &lt; c; j++)\n        {\n            int u;\n            cin &gt;&gt; u;\n            u--;\n            g[u].push_back(j);\n        }\n\n        vi sz(c, 1);\n        vl f(c, 1);\n        function&lt;void(int)&gt; dfs = [&amp;](int u)\n        {\n            for(auto v : g[u])\n            {\n                dfs(v);\n                sz[u] += sz[v];\n                (f[u] *= f[v] * inv[sz[v]] % mod) %= mod;\n            }\n            (f[u] *= fac[sz[u] - 1]) %= mod;\n        };\n        dfs(0);\n        (tot *= f[0] * inv[c] % mod) %= mod;\n    }\n    ans = ans * tot % mod * fac[cnt] % mod;\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    fac[0] = 1;\n    for(int i = 1; i &lt; N; i++)\n        fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = ksm(fac[N - 1], mod - 2);\n    for(int i = N - 2; i &gt;= 1; i--)\n        inv[i] = (i + 1) * inv[i + 1] % mod;\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<h2 id=\"代码2\"><a href=\"#代码2\" class=\"headerlink\" title=\"代码2\"></a>代码2</h2><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing pll = pair&lt;ll, ll&gt;;\nusing arr = array&lt;int, 3&gt;;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\nconst int N = 1e5 + 5, M = N;\nconst int mod = 1e9 + 7;\n\n// assume -P &lt;= x &lt; 2P\nint norm(int x) {\n    if (x &lt; 0) {\n        x += mod;\n    }\n    if (x &gt;= mod) {\n        x -= mod;\n    }\n    return x;\n}\ntemplate&lt;class T&gt;\nT power(T a, ll b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(ll x) : x(norm(x % mod)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(mod - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, mod - 2);\n    }\n    Z &amp;operator*=(const Z &amp;rhs) {\n        x = ll(x) * rhs.x % mod;\n        return *this;\n    }\n    Z &amp;operator+=(const Z &amp;rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &amp;operator-=(const Z &amp;rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &amp;operator/=(const Z &amp;rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Z &amp;a) {\n        ll v;\n        is &gt;&gt; v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;a) {\n        return os &lt;&lt; a.val();\n    }\n};\n\nvoid solve()\n{\n    int n;\n    cin &gt;&gt; n;\n\n    Z ans = 1;\n    int tot = 0;\n    for(int i = 0; i &lt; n; i++)\n    {\n        int c;\n        cin &gt;&gt; c;\n\n        for(int j = 0; j &lt; c; j++)\n            ans *= ++tot;\n\n        vector&lt;vi&gt; g(c);\n        for(int j = 1; j &lt; c; j++)\n        {\n            int u;\n            cin &gt;&gt; u;\n            u--;\n            g[u].push_back(j);\n        }\n\n        vi sz(c, 1);\n\n        function&lt;void(int)&gt; dfs = [&amp;](int u)\n        {\n            for(auto v : g[u])\n            {\n                dfs(v);\n                sz[u] += sz[v];\n            }\n            ans /= sz[u];\n        };\n        dfs(0);\n    }\n\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    t = 1;\n    // cin &gt;&gt; t;\n    while(t--)\n        solve();\n    return 0;\n}</code></pre>\n<p>拓扑序计数相关题目：</p>\n<p>HDU4661 ： <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4661\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=4661</a></p>\n"},{"title":"树链剖分|模板题","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1046407529,"date":"2022-07-22T10:27:24.000Z","password":null,"summary":null,"_content":"\n\n\n# 树链剖分模板题\n\n题目链接：\n\n[https://www.luogu.com.cn/problem/P3384](https://www.luogu.com.cn/problem/P3384)\n\n![问题描述](1046407529/f09feafcf66f44c0b0e215ff94c1ca40.png)\n\n\n\n\n\n# 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 5, M = 2 * N;\n\nint n, m, r, p;\n\nint w[N];\n\nstruct Segment\n{\n\tll add, sum;\n}tr[N * 4];\n\nint dep[N], fa[N], son[N], sz[N];\nint cnt, nw[N], top[N], id[N];\n\nint e[M], h[N], ne[M], idx;\nvoid add(int a, int b)\n{\n\te[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid pushup(int u)\n{\n\ttr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;\n}\nvoid pushdown(int u, int l, int r)\n{\n\tint mid = (l + r) >> 1;\n\tif(tr[u].add)\n\t{\n\t\ttr[u << 1].add += tr[u].add;\n\t\ttr[u << 1].sum += 1ll * (mid - l + 1) * tr[u].add;\n\t\ttr[u << 1].sum %= p;\n\t\ttr[u << 1 | 1].add += tr[u].add;\n\t\ttr[u << 1 | 1].sum += 1ll * (r - mid) * tr[u].add;\n\t\ttr[u << 1 | 1].sum %= p;\n\t\ttr[u].add = 0;\n\t}\n}\n\nvoid build(int u, int l, int r)\n{\n\tif(l == r)\n\t{\n\t\ttr[u].sum = nw[l];\n\t\tif(tr[u].sum > p) tr[u].sum %= p;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(u << 1, l, mid);\n\tbuild(u << 1 | 1, mid + 1, r);\n\tpushup(u);\n}\n\nvoid modify(int u, int l, int r, int x, int y, int d)\n{\n\tif(l >= x && r <= y)\n\t{\n\t\ttr[u].sum += 1ll * (r - l + 1) * d;\n\t\ttr[u].sum %= p;\n\t\ttr[u].add += d;\n\t\treturn;\n\t}\n\tpushdown(u, l, r);\n\tint mid = (l + r) >> 1;\n\tif(x <= mid) modify(u << 1, l, mid, x, y, d);\n\tif(y > mid) modify(u << 1 | 1, mid + 1, r, x, y, d);\n\tpushup(u);\n}\n\nll query(int u, int l, int r, int x, int y)\n{\n\tif(l >= x && r <= y)\n\t\treturn tr[u].sum % p;\n\tpushdown(u, l, r);\n\tint mid = (l + r) >> 1;\n\tll ans = 0;\n\tif(x <= mid) ans = query(u << 1, l, mid, x, y) % p;\n\tif(y > mid) ans = (ans + query(u << 1 | 1, mid + 1, r, x, y)) % p;\n\treturn ans;\n}\n\n//预处理dep[],fa[],sz[],son[](重儿子节点)\nvoid dfs1(int x, int f, int depth)//x : 当前节点, f：父亲, depth：深度\n{\n\tdep[x] = depth;\n\tfa[x] = f;\n\tsz[x] = 1;\n\tint mxson = -1;\n\tfor(int i = h[x]; ~i; i = ne[i])\n\t{\n\t\tint y = e[i];\n\t\tif(y == f) continue;\n\t\tdfs1(y, x, depth + 1);\n\t\tsz[x] += sz[y];\n\t\tif(sz[y] > mxson)// 记录重儿子编号\n\t\t{\n\t\t\tson[x] = y;\n\t\t\tmxson = sz[y];\n\t\t}\n\t}\n}\n\n// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端\nvoid dfs2(int x, int topf)\n{\n\tid[x] = ++cnt;\n\tnw[cnt] = w[x];\n\ttop[x] = topf;\n\tif(!son[x]) return;//无儿子返回\n\tdfs2(son[x], topf);\n\tfor(int i = h[x]; ~i; i = ne[i])\n\t{\n\t\tint y = e[i];\n\t\tif(y == fa[x] || y == son[x])\n\t\t\tcontinue;\n\t\tdfs2(y, y);\n\t}\n}\n\nll queryRange(int x, int y)\n{\n\tll ans = 0;\n\twhile(top[x] != top[y])//不在同一条链上\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\n\t\t\tswap(x, y);\n\t\tans += query(1, 1, n, id[top[x]], id[x]);\n\t\tans %= p;\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y])\n\t\tswap(x, y);\n\tans = (ans + query(1, 1, n, id[x], id[y])) % p;\n\treturn ans;\n}\n\nvoid modifyRange(int x, int y, int d)\n{\n\td %= p;\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\n\t\t\tswap(x, y);\n\t\tmodify(1, 1, n, id[top[x]], id[x], d);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y])\n\t\tswap(x, y);\n\tmodify(1, 1, n, id[x], id[y], d);\n}\nll querySon(int x)\n{\n\treturn query(1, 1, n, id[x], id[x] + sz[x] - 1);\t\n}\nvoid modifySon(int x, int d)\n{\n\tmodify(1, 1, n, id[x], id[x] + sz[x] - 1, d);\n}\n\nvoid solve()\n{\n\tcin >> n >> m >> r >> p;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> w[i];\n\tmemset(h, -1, sizeof h);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadd(u, v);\n\t\tadd(v, u);\n\t}\n\tdfs1(r, -1, 1);\n\tdfs2(r, r);\n\tbuild(1, 1, n);\n\n\twhile(m--)\n\t{\n\t\tint op, x, y, z;\n\t\tcin >> op >> x;\n\t\tif(op == 1)\n\t\t{\n\t\t\tcin >> y >> z;\n\t\t\tmodifyRange(x, y, z);\n\t\t}\n\t\telse if(op == 2)\n\t\t{\n\t\t\tcin >> y;\n\t\t\tcout << queryRange(x, y) << \"\\n\";\n\t\t}\n\t\telse if(op == 3)\n\t\t{\n\t\t\tcin >> z;\n\t\t\tmodifySon(x, z);\n\t\t}\n\t\telse \n\t\t\tcout << querySon(x) << \"\\n\";\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t;\n\t// cin >> t;\n\tt = 1;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n\n```\n\n","source":"_posts/树链剖分模板.md","raw":"---\ntitle: 树链剖分|模板题\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 树链剖分\n  - DFS\ncategories:\n  - 图论\nabbrlink: 1046407529\ndate: 2022-07-22 18:27:24\npassword:\nsummary:\n---\n\n\n\n# 树链剖分模板题\n\n题目链接：\n\n[https://www.luogu.com.cn/problem/P3384](https://www.luogu.com.cn/problem/P3384)\n\n![问题描述](1046407529/f09feafcf66f44c0b0e215ff94c1ca40.png)\n\n\n\n\n\n# 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 5, M = 2 * N;\n\nint n, m, r, p;\n\nint w[N];\n\nstruct Segment\n{\n\tll add, sum;\n}tr[N * 4];\n\nint dep[N], fa[N], son[N], sz[N];\nint cnt, nw[N], top[N], id[N];\n\nint e[M], h[N], ne[M], idx;\nvoid add(int a, int b)\n{\n\te[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid pushup(int u)\n{\n\ttr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;\n}\nvoid pushdown(int u, int l, int r)\n{\n\tint mid = (l + r) >> 1;\n\tif(tr[u].add)\n\t{\n\t\ttr[u << 1].add += tr[u].add;\n\t\ttr[u << 1].sum += 1ll * (mid - l + 1) * tr[u].add;\n\t\ttr[u << 1].sum %= p;\n\t\ttr[u << 1 | 1].add += tr[u].add;\n\t\ttr[u << 1 | 1].sum += 1ll * (r - mid) * tr[u].add;\n\t\ttr[u << 1 | 1].sum %= p;\n\t\ttr[u].add = 0;\n\t}\n}\n\nvoid build(int u, int l, int r)\n{\n\tif(l == r)\n\t{\n\t\ttr[u].sum = nw[l];\n\t\tif(tr[u].sum > p) tr[u].sum %= p;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(u << 1, l, mid);\n\tbuild(u << 1 | 1, mid + 1, r);\n\tpushup(u);\n}\n\nvoid modify(int u, int l, int r, int x, int y, int d)\n{\n\tif(l >= x && r <= y)\n\t{\n\t\ttr[u].sum += 1ll * (r - l + 1) * d;\n\t\ttr[u].sum %= p;\n\t\ttr[u].add += d;\n\t\treturn;\n\t}\n\tpushdown(u, l, r);\n\tint mid = (l + r) >> 1;\n\tif(x <= mid) modify(u << 1, l, mid, x, y, d);\n\tif(y > mid) modify(u << 1 | 1, mid + 1, r, x, y, d);\n\tpushup(u);\n}\n\nll query(int u, int l, int r, int x, int y)\n{\n\tif(l >= x && r <= y)\n\t\treturn tr[u].sum % p;\n\tpushdown(u, l, r);\n\tint mid = (l + r) >> 1;\n\tll ans = 0;\n\tif(x <= mid) ans = query(u << 1, l, mid, x, y) % p;\n\tif(y > mid) ans = (ans + query(u << 1 | 1, mid + 1, r, x, y)) % p;\n\treturn ans;\n}\n\n//预处理dep[],fa[],sz[],son[](重儿子节点)\nvoid dfs1(int x, int f, int depth)//x : 当前节点, f：父亲, depth：深度\n{\n\tdep[x] = depth;\n\tfa[x] = f;\n\tsz[x] = 1;\n\tint mxson = -1;\n\tfor(int i = h[x]; ~i; i = ne[i])\n\t{\n\t\tint y = e[i];\n\t\tif(y == f) continue;\n\t\tdfs1(y, x, depth + 1);\n\t\tsz[x] += sz[y];\n\t\tif(sz[y] > mxson)// 记录重儿子编号\n\t\t{\n\t\t\tson[x] = y;\n\t\t\tmxson = sz[y];\n\t\t}\n\t}\n}\n\n// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端\nvoid dfs2(int x, int topf)\n{\n\tid[x] = ++cnt;\n\tnw[cnt] = w[x];\n\ttop[x] = topf;\n\tif(!son[x]) return;//无儿子返回\n\tdfs2(son[x], topf);\n\tfor(int i = h[x]; ~i; i = ne[i])\n\t{\n\t\tint y = e[i];\n\t\tif(y == fa[x] || y == son[x])\n\t\t\tcontinue;\n\t\tdfs2(y, y);\n\t}\n}\n\nll queryRange(int x, int y)\n{\n\tll ans = 0;\n\twhile(top[x] != top[y])//不在同一条链上\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\n\t\t\tswap(x, y);\n\t\tans += query(1, 1, n, id[top[x]], id[x]);\n\t\tans %= p;\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y])\n\t\tswap(x, y);\n\tans = (ans + query(1, 1, n, id[x], id[y])) % p;\n\treturn ans;\n}\n\nvoid modifyRange(int x, int y, int d)\n{\n\td %= p;\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\n\t\t\tswap(x, y);\n\t\tmodify(1, 1, n, id[top[x]], id[x], d);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y])\n\t\tswap(x, y);\n\tmodify(1, 1, n, id[x], id[y], d);\n}\nll querySon(int x)\n{\n\treturn query(1, 1, n, id[x], id[x] + sz[x] - 1);\t\n}\nvoid modifySon(int x, int d)\n{\n\tmodify(1, 1, n, id[x], id[x] + sz[x] - 1, d);\n}\n\nvoid solve()\n{\n\tcin >> n >> m >> r >> p;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> w[i];\n\tmemset(h, -1, sizeof h);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadd(u, v);\n\t\tadd(v, u);\n\t}\n\tdfs1(r, -1, 1);\n\tdfs2(r, r);\n\tbuild(1, 1, n);\n\n\twhile(m--)\n\t{\n\t\tint op, x, y, z;\n\t\tcin >> op >> x;\n\t\tif(op == 1)\n\t\t{\n\t\t\tcin >> y >> z;\n\t\t\tmodifyRange(x, y, z);\n\t\t}\n\t\telse if(op == 2)\n\t\t{\n\t\t\tcin >> y;\n\t\t\tcout << queryRange(x, y) << \"\\n\";\n\t\t}\n\t\telse if(op == 3)\n\t\t{\n\t\t\tcin >> z;\n\t\t\tmodifySon(x, z);\n\t\t}\n\t\telse \n\t\t\tcout << querySon(x) << \"\\n\";\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint t;\n\t// cin >> t;\n\tt = 1;\n\twhile(t--)\n\t\tsolve();\n\treturn 0;\n}\n\n```\n\n","slug":"树链剖分模板","published":1,"updated":"2022-08-04T07:03:44.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhp001j6kuhwmxf08z8","content":"<h1 id=\"树链剖分模板题\"><a href=\"#树链剖分模板题\" class=\"headerlink\" title=\"树链剖分模板题\"></a>树链剖分模板题</h1><p>题目链接：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3384\" target=\"_blank\" rel=\"noopener\">https://www.luogu.com.cn/problem/P3384</a></p>\n<p><img src=\"1046407529/f09feafcf66f44c0b0e215ff94c1ca40.png\" alt=\"问题描述\"></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> M <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> w<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> Segment\n<span class=\"token punctuation\">{</span>\n    ll add<span class=\"token punctuation\">,</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>tr<span class=\"token punctuation\">[</span>N <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> dep<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> fa<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> son<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">,</span> nw<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> e<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ne<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    e<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b<span class=\"token punctuation\">,</span> ne<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> idx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">pushup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">+</span> tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">pushdown</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add <span class=\"token operator\">+</span><span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>mid <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add <span class=\"token operator\">+</span><span class=\"token operator\">=</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> mid<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> r<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">=</span> nw<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">></span> p<span class=\"token punctuation\">)</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pushup</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> x <span class=\"token operator\">&amp;&amp;</span> r <span class=\"token operator\">&lt;=</span> y<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1ll</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> l <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> d<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>add <span class=\"token operator\">+</span><span class=\"token operator\">=</span> d<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">pushdown</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">></span> mid<span class=\"token punctuation\">)</span> <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pushup</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nll <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> x <span class=\"token operator\">&amp;&amp;</span> r <span class=\"token operator\">&lt;=</span> y<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> tr<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sum <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pushdown</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> ans <span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">></span> mid<span class=\"token punctuation\">)</span> ans <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ans <span class=\"token operator\">+</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">|</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//预处理dep[],fa[],sz[],son[](重儿子节点)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dfs1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> f<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> depth<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//x : 当前节点, f：父亲, depth：深度</span>\n<span class=\"token punctuation\">{</span>\n    dep<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> depth<span class=\"token punctuation\">;</span>\n    fa<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> f<span class=\"token punctuation\">;</span>\n    sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mxson <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">~</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> ne<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">==</span> f<span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs1</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> depth <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> mxson<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">// 记录重儿子编号</span>\n        <span class=\"token punctuation\">{</span>\n            son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n            mxson <span class=\"token operator\">=</span> sz<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> topf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>cnt<span class=\"token punctuation\">;</span>\n    nw<span class=\"token punctuation\">[</span>cnt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> topf<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//无儿子返回</span>\n    <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span>son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> topf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> h<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">~</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">=</span> ne<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>y <span class=\"token operator\">==</span> fa<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> y <span class=\"token operator\">==</span> son<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nll <span class=\"token function\">queryRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll ans <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//不在同一条链上</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        x <span class=\"token operator\">=</span> fa<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dep<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ans <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ans <span class=\"token operator\">+</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ans<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifyRange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    d <span class=\"token operator\">%</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dep<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        x <span class=\"token operator\">=</span> fa<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dep<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dep<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nll <span class=\"token function\">querySon</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> d<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">modify</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> sz<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m <span class=\"token operator\">>></span> r <span class=\"token operator\">>></span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cin <span class=\"token operator\">>></span> w<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> u <span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">dfs1</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dfs2</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> op<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">;</span>\n        cin <span class=\"token operator\">>></span> op <span class=\"token operator\">>></span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>op <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cin <span class=\"token operator\">>></span> y <span class=\"token operator\">>></span> z<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">modifyRange</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>op <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cin <span class=\"token operator\">>></span> y<span class=\"token punctuation\">;</span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">queryRange</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>op <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            cin <span class=\"token operator\">>></span> z<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">modifySon</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> \n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">querySon</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// cin >> t;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"树链剖分模板题\"><a href=\"#树链剖分模板题\" class=\"headerlink\" title=\"树链剖分模板题\"></a>树链剖分模板题</h1><p>题目链接：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3384\" target=\"_blank\" rel=\"noopener\">https://www.luogu.com.cn/problem/P3384</a></p>\n<p><img src=\"1046407529/f09feafcf66f44c0b0e215ff94c1ca40.png\" alt=\"问题描述\"></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\nconst int N = 1e5 + 5, M = 2 * N;\n\nint n, m, r, p;\n\nint w[N];\n\nstruct Segment\n{\n    ll add, sum;\n}tr[N * 4];\n\nint dep[N], fa[N], son[N], sz[N];\nint cnt, nw[N], top[N], id[N];\n\nint e[M], h[N], ne[M], idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nvoid pushup(int u)\n{\n    tr[u].sum = (tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum) % p;\n}\nvoid pushdown(int u, int l, int r)\n{\n    int mid = (l + r) &gt;&gt; 1;\n    if(tr[u].add)\n    {\n        tr[u &lt;&lt; 1].add += tr[u].add;\n        tr[u &lt;&lt; 1].sum += 1ll * (mid - l + 1) * tr[u].add;\n        tr[u &lt;&lt; 1].sum %= p;\n        tr[u &lt;&lt; 1 | 1].add += tr[u].add;\n        tr[u &lt;&lt; 1 | 1].sum += 1ll * (r - mid) * tr[u].add;\n        tr[u &lt;&lt; 1 | 1].sum %= p;\n        tr[u].add = 0;\n    }\n}\n\nvoid build(int u, int l, int r)\n{\n    if(l == r)\n    {\n        tr[u].sum = nw[l];\n        if(tr[u].sum &gt; p) tr[u].sum %= p;\n        return;\n    }\n    int mid = (l + r) &gt;&gt; 1;\n    build(u &lt;&lt; 1, l, mid);\n    build(u &lt;&lt; 1 | 1, mid + 1, r);\n    pushup(u);\n}\n\nvoid modify(int u, int l, int r, int x, int y, int d)\n{\n    if(l &gt;= x &amp;&amp; r &lt;= y)\n    {\n        tr[u].sum += 1ll * (r - l + 1) * d;\n        tr[u].sum %= p;\n        tr[u].add += d;\n        return;\n    }\n    pushdown(u, l, r);\n    int mid = (l + r) &gt;&gt; 1;\n    if(x &lt;= mid) modify(u &lt;&lt; 1, l, mid, x, y, d);\n    if(y &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, x, y, d);\n    pushup(u);\n}\n\nll query(int u, int l, int r, int x, int y)\n{\n    if(l &gt;= x &amp;&amp; r &lt;= y)\n        return tr[u].sum % p;\n    pushdown(u, l, r);\n    int mid = (l + r) &gt;&gt; 1;\n    ll ans = 0;\n    if(x &lt;= mid) ans = query(u &lt;&lt; 1, l, mid, x, y) % p;\n    if(y &gt; mid) ans = (ans + query(u &lt;&lt; 1 | 1, mid + 1, r, x, y)) % p;\n    return ans;\n}\n\n//预处理dep[],fa[],sz[],son[](重儿子节点)\nvoid dfs1(int x, int f, int depth)//x : 当前节点, f：父亲, depth：深度\n{\n    dep[x] = depth;\n    fa[x] = f;\n    sz[x] = 1;\n    int mxson = -1;\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == f) continue;\n        dfs1(y, x, depth + 1);\n        sz[x] += sz[y];\n        if(sz[y] &gt; mxson)// 记录重儿子编号\n        {\n            son[x] = y;\n            mxson = sz[y];\n        }\n    }\n}\n\n// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端\nvoid dfs2(int x, int topf)\n{\n    id[x] = ++cnt;\n    nw[cnt] = w[x];\n    top[x] = topf;\n    if(!son[x]) return;//无儿子返回\n    dfs2(son[x], topf);\n    for(int i = h[x]; ~i; i = ne[i])\n    {\n        int y = e[i];\n        if(y == fa[x] || y == son[x])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nll queryRange(int x, int y)\n{\n    ll ans = 0;\n    while(top[x] != top[y])//不在同一条链上\n    {\n        if(dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        ans += query(1, 1, n, id[top[x]], id[x]);\n        ans %= p;\n        x = fa[top[x]];\n    }\n    if(dep[x] &gt; dep[y])\n        swap(x, y);\n    ans = (ans + query(1, 1, n, id[x], id[y])) % p;\n    return ans;\n}\n\nvoid modifyRange(int x, int y, int d)\n{\n    d %= p;\n    while(top[x] != top[y])\n    {\n        if(dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        modify(1, 1, n, id[top[x]], id[x], d);\n        x = fa[top[x]];\n    }\n    if(dep[x] &gt; dep[y])\n        swap(x, y);\n    modify(1, 1, n, id[x], id[y], d);\n}\nll querySon(int x)\n{\n    return query(1, 1, n, id[x], id[x] + sz[x] - 1);    \n}\nvoid modifySon(int x, int d)\n{\n    modify(1, 1, n, id[x], id[x] + sz[x] - 1, d);\n}\n\nvoid solve()\n{\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; p;\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; w[i];\n    memset(h, -1, sizeof h);\n    for(int i = 1; i &lt; n; i++)\n    {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        add(u, v);\n        add(v, u);\n    }\n    dfs1(r, -1, 1);\n    dfs2(r, r);\n    build(1, 1, n);\n\n    while(m--)\n    {\n        int op, x, y, z;\n        cin &gt;&gt; op &gt;&gt; x;\n        if(op == 1)\n        {\n            cin &gt;&gt; y &gt;&gt; z;\n            modifyRange(x, y, z);\n        }\n        else if(op == 2)\n        {\n            cin &gt;&gt; y;\n            cout &lt;&lt; queryRange(x, y) &lt;&lt; &quot;\\n&quot;;\n        }\n        else if(op == 3)\n        {\n            cin &gt;&gt; z;\n            modifySon(x, z);\n        }\n        else \n            cout &lt;&lt; querySon(x) &lt;&lt; &quot;\\n&quot;;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    // cin &gt;&gt; t;\n    t = 1;\n    while(t--)\n        solve();\n    return 0;\n}\n</code></pre>\n"},{"title":"组合数学常用公式","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":3821341893,"date":"2023-02-09T03:58:11.000Z","password":null,"summary":null,"_content":"\n# 组合数学常用公式\n\n## 二项式定理\n\n二项式系数相关性质：\n\n- 对称性：$C_n^m = C_n^{n-m}$\n\n- 增减性与最大值：二项式系数前半部分逐渐增大，后半部分逐渐减小，中间取最大值。\n  $$\n  \\text{最大值} max=\\begin{cases} C_n^{\\frac{n}{2}} \\\\ C_n^{\\frac{n-1}{2}}=C_n^{\\frac{n+1}{2}}\\end{cases}\n  $$\n\n- 二项式系数之和\n  $$\n  C_n^0+C_n^1+C_n^2+C_n^3+...+C_n^{n-1}+C_n^n=2^n\n  $$\n\n- 二项式奇数项系数之和等于偶数项系数之和，即\n  $$\n  C_n^1+C_n^3+C_n^5+...=C_n^0+C_n^2+C_n^4+C_n^6+...=2^{n-1}\n  $$\n  \n\n### 杨辉三角\n\n![杨辉三角](3821341893/image-20230209115625513.png)\n\n## 组合数公式\n\n$C_n^m$计算\n\n- 方式一：公式计算\n  计算都是在逆元或者阶乘基础上计算的\n\n$$\nC_n^m = \\frac{n!}{m!*(n-m)!}\n$$\n\n```cpp\nll C(ll n, ll m)\n{\n\tif(n < m) return 0;\n\treturn fact[n] * invfac[m] % mod * invfac[n - m] % mod;\n}\n```\n\n- 方式二：递推方式\n  需要建表，所以如果计算范围比较大时需要的空间也大\n  递推公式 ： \n\n$$\nC_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}\n$$\n\n\n\n```cpp\nfor(int i = 1; i <= n; i++)\n\tfor(int j = 0; j <= i; j++)\n\t{\n\t\tif(i == j || j == 0) c[i][j] = 1;\n\t\telse c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n\t}\n```\n\n\n\n## 排列组合方法\n\n### 1. 隔板法\n\n> 引入： 10 个**相同**小球放进 3 个**不同**盒子，每个盒子至少放进一个， 求种类数。\n>\n> 在10 个小球中间插入隔板， 共有 $10-1=9$ 个位置， 需要插入 $3-1=2$ 个隔板将其分成 3 部分。 共 $C_9^2 = 36$ 种。\n\n- 一般隔板法：\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 1$ 的可行解个数。\n\n- 添元素隔板法：\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n+k-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 0$ 的可行解个数。\n\n> 此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+...+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。\n\n- 隔板法应用\n\n把10个相同的小球放到3个不同的箱子，第一个箱子至少1个，第二个箱子至少3个，第3个箱子可以为\n\n空，有几种情况？\n\n> 我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8\n>\n> 个小球之外的1个小球（即补充了一个球），则问题转化为把9个相同小球放3不同箱子，每箱至\n>\n> 少1个，几种方法？ \n>\n> $C^2_8=28$\n\n\n\n","source":"_posts/组合数学常用公式.md","raw":"---\ntitle: 组合数学常用公式\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 组合数学\ncategories:\n  - 数论\nabbrlink: 3821341893\ndate: 2023-02-09 11:58:11\npassword:\nsummary:\n---\n\n# 组合数学常用公式\n\n## 二项式定理\n\n二项式系数相关性质：\n\n- 对称性：$C_n^m = C_n^{n-m}$\n\n- 增减性与最大值：二项式系数前半部分逐渐增大，后半部分逐渐减小，中间取最大值。\n  $$\n  \\text{最大值} max=\\begin{cases} C_n^{\\frac{n}{2}} \\\\ C_n^{\\frac{n-1}{2}}=C_n^{\\frac{n+1}{2}}\\end{cases}\n  $$\n\n- 二项式系数之和\n  $$\n  C_n^0+C_n^1+C_n^2+C_n^3+...+C_n^{n-1}+C_n^n=2^n\n  $$\n\n- 二项式奇数项系数之和等于偶数项系数之和，即\n  $$\n  C_n^1+C_n^3+C_n^5+...=C_n^0+C_n^2+C_n^4+C_n^6+...=2^{n-1}\n  $$\n  \n\n### 杨辉三角\n\n![杨辉三角](3821341893/image-20230209115625513.png)\n\n## 组合数公式\n\n$C_n^m$计算\n\n- 方式一：公式计算\n  计算都是在逆元或者阶乘基础上计算的\n\n$$\nC_n^m = \\frac{n!}{m!*(n-m)!}\n$$\n\n```cpp\nll C(ll n, ll m)\n{\n\tif(n < m) return 0;\n\treturn fact[n] * invfac[m] % mod * invfac[n - m] % mod;\n}\n```\n\n- 方式二：递推方式\n  需要建表，所以如果计算范围比较大时需要的空间也大\n  递推公式 ： \n\n$$\nC_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}\n$$\n\n\n\n```cpp\nfor(int i = 1; i <= n; i++)\n\tfor(int j = 0; j <= i; j++)\n\t{\n\t\tif(i == j || j == 0) c[i][j] = 1;\n\t\telse c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n\t}\n```\n\n\n\n## 排列组合方法\n\n### 1. 隔板法\n\n> 引入： 10 个**相同**小球放进 3 个**不同**盒子，每个盒子至少放进一个， 求种类数。\n>\n> 在10 个小球中间插入隔板， 共有 $10-1=9$ 个位置， 需要插入 $3-1=2$ 个隔板将其分成 3 部分。 共 $C_9^2 = 36$ 种。\n\n- 一般隔板法：\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 1$ 的可行解个数。\n\n- 添元素隔板法：\n\n将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为 \n$$\nC_{n+k-1}^{k-1}\n$$\n等价于 $x_1+ x_2+x_3+...+x_k=n, x_i \\geq 0$ 的可行解个数。\n\n> 此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+...+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。\n\n- 隔板法应用\n\n把10个相同的小球放到3个不同的箱子，第一个箱子至少1个，第二个箱子至少3个，第3个箱子可以为\n\n空，有几种情况？\n\n> 我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8\n>\n> 个小球之外的1个小球（即补充了一个球），则问题转化为把9个相同小球放3不同箱子，每箱至\n>\n> 少1个，几种方法？ \n>\n> $C^2_8=28$\n\n\n\n","slug":"组合数学常用公式","published":1,"updated":"2023-02-09T04:01:54.883Z","_id":"cldwkolhr001m6kuhsetta4zm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"组合数学常用公式\"><a href=\"#组合数学常用公式\" class=\"headerlink\" title=\"组合数学常用公式\"></a>组合数学常用公式</h1><h2 id=\"二项式定理\"><a href=\"#二项式定理\" class=\"headerlink\" title=\"二项式定理\"></a>二项式定理</h2><p>二项式系数相关性质：</p>\n<ul>\n<li><p>对称性：$C_n^m = C_n^{n-m}$</p>\n</li>\n<li><p>增减性与最大值：二项式系数前半部分逐渐增大，后半部分逐渐减小，中间取最大值。<br>$$<br>\\text{最大值} max=\\begin{cases} C_n^{\\frac{n}{2}} \\\\ C_n^{\\frac{n-1}{2}}=C_n^{\\frac{n+1}{2}}\\end{cases}<br>$$</p>\n</li>\n<li><p>二项式系数之和<br>$$<br>C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^{n-1}+C_n^n=2^n<br>$$</p>\n</li>\n<li><p>二项式奇数项系数之和等于偶数项系数之和，即<br>$$<br>C_n^1+C_n^3+C_n^5+…=C_n^0+C_n^2+C_n^4+C_n^6+…=2^{n-1}<br>$$</p>\n</li>\n</ul>\n<h3 id=\"杨辉三角\"><a href=\"#杨辉三角\" class=\"headerlink\" title=\"杨辉三角\"></a>杨辉三角</h3><p><img src=\"3821341893/image-20230209115625513.png\" alt=\"杨辉三角\"></p>\n<h2 id=\"组合数公式\"><a href=\"#组合数公式\" class=\"headerlink\" title=\"组合数公式\"></a>组合数公式</h2><p>$C_n^m$计算</p>\n<ul>\n<li>方式一：公式计算<br>计算都是在逆元或者阶乘基础上计算的</li>\n</ul>\n<p>$$<br>C_n^m = \\frac{n!}{m!*(n-m)!}<br>$$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">ll <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>ll n<span class=\"token punctuation\">,</span> ll m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> fact<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> invfac<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> invfac<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> m<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>方式二：递推方式<br>需要建表，所以如果计算范围比较大时需要的空间也大<br>递推公式 ： </li>\n</ul>\n<p>$$<br>C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}<br>$$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> j <span class=\"token operator\">||</span> j <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"排列组合方法\"><a href=\"#排列组合方法\" class=\"headerlink\" title=\"排列组合方法\"></a>排列组合方法</h2><h3 id=\"1-隔板法\"><a href=\"#1-隔板法\" class=\"headerlink\" title=\"1. 隔板法\"></a>1. 隔板法</h3><blockquote>\n<p>引入： 10 个<strong>相同</strong>小球放进 3 个<strong>不同</strong>盒子，每个盒子至少放进一个， 求种类数。</p>\n<p>在10 个小球中间插入隔板， 共有 $10-1=9$ 个位置， 需要插入 $3-1=2$ 个隔板将其分成 3 部分。 共 $C_9^2 = 36$ 种。</p>\n</blockquote>\n<ul>\n<li>一般隔板法：</li>\n</ul>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 1$ 的可行解个数。</p>\n<ul>\n<li>添元素隔板法：</li>\n</ul>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n+k-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 0$ 的可行解个数。</p>\n<blockquote>\n<p>此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+…+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。</p>\n</blockquote>\n<ul>\n<li>隔板法应用</li>\n</ul>\n<p>把10个相同的小球放到3个不同的箱子，第一个箱子至少1个，第二个箱子至少3个，第3个箱子可以为</p>\n<p>空，有几种情况？</p>\n<blockquote>\n<p>我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8</p>\n<p>个小球之外的1个小球（即补充了一个球），则问题转化为把9个相同小球放3不同箱子，每箱至</p>\n<p>少1个，几种方法？ </p>\n<p>$C^2_8=28$</p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"组合数学常用公式\"><a href=\"#组合数学常用公式\" class=\"headerlink\" title=\"组合数学常用公式\"></a>组合数学常用公式</h1><h2 id=\"二项式定理\"><a href=\"#二项式定理\" class=\"headerlink\" title=\"二项式定理\"></a>二项式定理</h2><p>二项式系数相关性质：</p>\n<ul>\n<li><p>对称性：$C_n^m = C_n^{n-m}$</p>\n</li>\n<li><p>增减性与最大值：二项式系数前半部分逐渐增大，后半部分逐渐减小，中间取最大值。<br>$$<br>\\text{最大值} max=\\begin{cases} C_n^{\\frac{n}{2}} \\\\ C_n^{\\frac{n-1}{2}}=C_n^{\\frac{n+1}{2}}\\end{cases}<br>$$</p>\n</li>\n<li><p>二项式系数之和<br>$$<br>C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^{n-1}+C_n^n=2^n<br>$$</p>\n</li>\n<li><p>二项式奇数项系数之和等于偶数项系数之和，即<br>$$<br>C_n^1+C_n^3+C_n^5+…=C_n^0+C_n^2+C_n^4+C_n^6+…=2^{n-1}<br>$$</p>\n</li>\n</ul>\n<h3 id=\"杨辉三角\"><a href=\"#杨辉三角\" class=\"headerlink\" title=\"杨辉三角\"></a>杨辉三角</h3><p><img src=\"3821341893/image-20230209115625513.png\" alt=\"杨辉三角\"></p>\n<h2 id=\"组合数公式\"><a href=\"#组合数公式\" class=\"headerlink\" title=\"组合数公式\"></a>组合数公式</h2><p>$C_n^m$计算</p>\n<ul>\n<li>方式一：公式计算<br>计算都是在逆元或者阶乘基础上计算的</li>\n</ul>\n<p>$$<br>C_n^m = \\frac{n!}{m!*(n-m)!}<br>$$</p>\n<pre><code class=\"cpp\">ll C(ll n, ll m)\n{\n    if(n &lt; m) return 0;\n    return fact[n] * invfac[m] % mod * invfac[n - m] % mod;\n}</code></pre>\n<ul>\n<li>方式二：递推方式<br>需要建表，所以如果计算范围比较大时需要的空间也大<br>递推公式 ： </li>\n</ul>\n<p>$$<br>C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}<br>$$</p>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++)\n    for(int j = 0; j &lt;= i; j++)\n    {\n        if(i == j || j == 0) c[i][j] = 1;\n        else c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n    }</code></pre>\n<h2 id=\"排列组合方法\"><a href=\"#排列组合方法\" class=\"headerlink\" title=\"排列组合方法\"></a>排列组合方法</h2><h3 id=\"1-隔板法\"><a href=\"#1-隔板法\" class=\"headerlink\" title=\"1. 隔板法\"></a>1. 隔板法</h3><blockquote>\n<p>引入： 10 个<strong>相同</strong>小球放进 3 个<strong>不同</strong>盒子，每个盒子至少放进一个， 求种类数。</p>\n<p>在10 个小球中间插入隔板， 共有 $10-1=9$ 个位置， 需要插入 $3-1=2$ 个隔板将其分成 3 部分。 共 $C_9^2 = 36$ 种。</p>\n</blockquote>\n<ul>\n<li>一般隔板法：</li>\n</ul>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 1$ 的可行解个数。</p>\n<ul>\n<li>添元素隔板法：</li>\n</ul>\n<p>将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n+k-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k=n, x_i \\geq 0$ 的可行解个数。</p>\n<blockquote>\n<p>此时该式可以转化为一般隔板法， 我们让 $x_i \\geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+…+x_k=n+k,x_i \\geq 1$ ，即可转化为一般隔板法。</p>\n</blockquote>\n<ul>\n<li>隔板法应用</li>\n</ul>\n<p>把10个相同的小球放到3个不同的箱子，第一个箱子至少1个，第二个箱子至少3个，第3个箱子可以为</p>\n<p>空，有几种情况？</p>\n<blockquote>\n<p>我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8</p>\n<p>个小球之外的1个小球（即补充了一个球），则问题转化为把9个相同小球放3不同箱子，每箱至</p>\n<p>少1个，几种方法？ </p>\n<p>$C^2_8=28$</p>\n</blockquote>\n"},{"title":"C++ STL总结","top":true,"cover":true,"toc":true,"mathjax":true,"abbrlink":870124582,"date":"2022-08-09T13:34:49.000Z","password":null,"summary":null,"_content":"\n\n\n# C++ STL 总结-基于算法竞赛（悠享版）\n\n本文介绍常用STL知识，注重应用，强调用法，不强调原理和繁杂的记忆。看过之后请多运用，多敲代码试。\n\n> 费尽心思重新梳理了一下，注意了些美观性，修改了部分错误，添加了部分解释，编写过程非常难。\n\n另外C++版本一定要对，C++11即可，C++17或20更好。\n\n> 实践才是检验真理的唯一标准！\n\nCSDN版本：[https://wyq666.blog.csdn.net/article/details/114026148](https://wyq666.blog.csdn.net/article/details/114026148)\n\n## 1 vector\n\n###  1.1 介绍\n\n`vector`为可变长数组（动态数组），定义的`vector`数组可以随时添加数值和删除元素。\n\n> 注意：**在局部区域中（比如局部函数里面）开vector数组，是在堆空间里面开的。** \n>\n> 在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。\n>\n> 故局部区域**不可以**开大长度数组，但是可以开大长度`vector`。\n\n- 头文件\n\n```cpp\n#include <vector>\n```\n\n- 初始化\n\n  - 一维初始化\n\n    ```cpp\n    vector<int> a; //定义了一个名为a的一维数组,数组存储int类型数据\n    vector<double> b;//定义了一个名为b的一维数组，数组存储double类型数据\n    vector<node> c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型\n    ```\n\n    指定**长度**和**初始值**的初始化\n\n    ```cpp\n    vector<int> v(n);//定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]\n    vector<int> v(n, 1);//v[0]到v[n-1]所有的元素初始值均为1\n    //注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）\n    ```\n    \n    初始化中有多个元素\n    \n    ```cpp\n    vector<int> a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5\n    ```\n    \n    拷贝初始化\n    \n    ```cpp\n    vector<int> a(n + 1, 0);\n    vector<int> b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组\n    ```\n    \n  - 二维初始化\n    定义第一维固定长度为`5`，第二维可变化的二维数组\n  \n    ```cpp\n    vector<int> v[5];//定义可变长二维数组\n    //注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素\n    //第一维固定长度为5，第二维长度可以改变\n    ```\n  \n    > `vector<int> v[5]`可以这样理解：长度为5的v数组，数组中存储的是`vector<int> `数据类型，而该类型就是数组形式，故`v`为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：\n    >\n    > ```cpp\n    > v[1].push_back(2);\n    > v[2].push_back(3);\n    > ```\n  \n    行列均可变\n  \n    ```cpp\n    //初始化二维均可变长数组\n    vector<vectot<int>> v;//定义一个行和列均可变的二维数组\n    ```\n  \n    > 应用：可以在`v`数组里面装多个数组\n    >\n    > ```cpp\n    > vector<int> t1{1, 2, 3, 4};\n    > vector<int> t2{2, 3, 4, 5};\n    > v.push_back(t1);\n    > v.push_back(t2);\n    > v.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector\n    > ```\n  \n    行列长度均固定 `n + 1`行 `m + 1`列初始值为0\n  \n    ```cpp\n    vector<vector<int> > a(n + 1, vector<int>(m + 1, 0));\n    ```\n  \n    c++17或者c++20支持的形式（不常用），与上面相同的初始化\n  \n    ```cpp\n    vector a(n + 1, vector(m + 1, 0));\n    ```\n\n---\n\n### 1.2 方法函数\n\n知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。\n\n**c指定为数组名称**，含义中会注明算法复杂度。\n\n| 代码                           | 含义                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| `c.front()`                    | 返回第一个数据$O(1)$                                         |\n| `c.pop_back()`                 | 删除最后一个数据$O(1)$                                       |\n| `c.push_back(element)`         | 在尾部加一个数据$O(1)$                                       |\n| `c.size()`                     | 返回实际数据个数（unsigned类型）$O(1)$                       |\n| `c.clear()`                    | 清除元素个数$O(N)$，N为元素个数                              |\n| `c.resize(n, v)`               | 改变数组大小为`n`,`n`个空间数值赋为`v`，如果没有默认赋值为`0` |\n| `c.insert(it, x)`              | 向任意迭代器`it`插入一个元素`x` ，$O(N)$                     |\n| 例：`c.insert(c.begin()+2,-1)` | 将`-1`插入`c[2]`的位置                                       |\n| `c.erase(first,last)`          | 删除`[first,last)`的所有元素，$O(N)$                         |\n| `c.begin()`                    | 返回首元素的迭代器（通俗来说就是地址）$O(1)$                 |\n| `c.end()`                      | 返回最后一个元素后一个位置的迭代器（地址）$O(1)$             |\n| `c.empty()`                    | 判断是否为空，为空返回真，反之返回假 $O(1)$                  |\n\n注意： `end()`返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，**所有STL容器均是如此**\n\n**排序**\n\n使用`sort`排序要：  `sort(c.begin(), c.end());`\n\n> `sort()`为STL函数，请参考本文最后面STL函数系列。\n\n对所有元素进行排序，如果要对指定区间进行排序，可以对`sort()`里面的参数进行加减改动。\n\n```cpp\nvector<int> a(n + 1);\nsort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序\n```\n\n---\n\n### 1.3  访问\n\n- **下标法：** 和普通数组一样\n\n注意：一维数组的下标是从$0$到$v.size()-1$，访问之外的数会出现越界错误\n\n- **迭代器法：** 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。\n\n代码如下：\n\n```cpp\nvector<int> vi; //定义一个vi数组\nvector<int>::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置\n```\n\n#### 1.3.1 下标访问\n\n直接和普通数组一样进行访问即可。\n\n```cpp\n//添加元素\nfor(int i = 0; i < 5; i++)\n\tvi.push_back(i);\n\t\n//下标访问 \nfor(int i = 0; i < 5; i++)\n\tcout << vi[i] << \" \";\ncout << \"\\n\";\n```\n\n#### 1.3.2 迭代器访问\n\n类似指针。\n\n```cpp\n//迭代器访问\nvector<int>::iterator it;   \n//相当于声明了一个迭代器类型的变量it\n//通俗来说就是声明了一个指针变量\n\n//方式一：\nvector<int>::iterator it = vi.begin(); \nfor(int i = 0; i < 5; i++)\n\tcout << *(it + i) << \" \";\ncout << \"\\n\";\n\n//方式二：\nvector<int>::iterator it;\nfor(it = vi.begin(); it != vi.end();it ++)\n\tcout << *it << \" \";\n//vi.end()指向尾元素地址的下一个地址\n```\n\n#### 1.3.3 智能指针\n\n**只能遍历完数组**，如果要指定的内容进行遍历，需要另选方法。\n**auto** 能够自动识别并获取类型。\n\n```cpp\nvector<int> v;\nv.push_back(12);\nv.push_back(241);\nfor(auto val : v) \n\tcout << val << \" \"; // 12 241\n```\n\n> `vector`注意：\n>\n> - `vi[i]`  和  `*(vi.begin() + i)` 等价\n>\n> - `vector`和`string`的`STL`容器支持`*(it + i)`的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。\n\n---\n\n## 2 stack\n\n### 2.1 介绍\n\n栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。\n\n```cpp\n//头文件需要添加\n#include<stack>\n\n//声明\nstack<int> s;\nstack<string> s;\nstack<node> s;//node是结构体类型\n```\n\n### 2.2 方法函数\n\n| 代码          | 含义                            |\n| ------------- | ------------------------------- |\n| `s.push(ele)` | 元素`ele`入栈，增加元素  $O(1)$ |\n| `s.pop()`     | 移除栈顶元素 $O(1)$             |\n| `s.top()`     | 取得栈顶元素（但不删除）$O(1)$  |\n| `s.empty()`   | 检测栈内是否为空，空为真 $O(1)$ |\n| `s.size()`    | 返回栈内元素的个数 $O(1)$       |\n\n---\n\n### 2.3 栈遍历\n\n#### 2.3.1 栈遍历\n\n栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中\n\n#### 2.3.2 数组模拟栈进行遍历\n\n通过一个**数组**对栈进行模拟，一个存放下标的变量`top`模拟指向栈顶的指针。\n\n**特点：** 比`STL`的`stack`速度更快，遍历元素方便\n\n```cpp\nint s[100]; // 栈 从左至右为栈底到栈顶\nint tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1\n\nfor(int i = 0; i <= 5; i++)\n{\n\t//入栈 \n\ts[++tt] = i;\n}\n// 出栈\nint top_element = s[tt--]; \n\n//入栈操作示意\n//  0  1  2  3  4  5  \n//                tt\n//出栈后示意\n//  0  1  2  3  4 \n//              tt\n```\n\n---\n\n## 3 queue\n\n### 3.1 介绍\n\n队列是一种先进先出的数据结构。\n\n```cpp\n//头文件\n#include<queue>\n//定义初始化\nqueue<int> q;\n```\n\n### 3.2 方法函数\n\n| 代码              | 含义                                                |\n| ----------------- | --------------------------------------------------- |\n| `q.front()`       | 返回队首元素  $O(1)$                                |\n| `q.back()`        | 返回队尾元素 $O(1)$                                 |\n| `q.push(element)` | 尾部添加一个元素`element`  进队$O(1)$               |\n| `q.pop()`         | 删除第一个元素  出队 $O(1)$                         |\n| `q.size()`        | 返回队列中元素个数，返回值类型`unsigned int` $O(1)$ |\n| `q.empty()`       | 判断是否为空，队列为空，返回`true` $O(1)$           |\n\n### 3.3 队列模拟\n\n使用`q[]`数组模拟队列\n`hh`表示队首元素的下标，初始值为`0`\n`tt`表示队尾元素的下标，初始值为`-1`，表示刚**开始队列为空**\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\nint q[N];\n\nint main()\n{\n\tint hh = 0,tt = -1;\n//\t入队 \n\tq[++tt] = 1;\n\tq[++tt] = 2; \n//\t将所有元素出队 \n\twhile(hh <= tt)\n\t{\n\t\tint t = q[hh++];\n\t\tprintf(\"%d \",t);\n\t}\n\treturn 0;\n } \n```\n\n---\n\n## 4 deque\n\n### 4.1 介绍\n\n首尾都可插入和删除的队列为双端队列。\n\n```cpp\n//添加头文件\n#include<deque>\n//初始化定义\ndeque<int> dq;\n```\n\n### 4.2 方法函数\n\n| 代码                                  | 含义                                 |\n| ------------------------------------- | ------------------------------------ |\n| `push_back(x)/push_front(x)`          | 把`x`插入队尾后 / 队首 $O(1)$        |\n| `back()/front()`                      | 返回队尾 / 队首元素 $O(1)$           |\n| `pop_back() / pop_front()`            | 删除队尾 / 队首元素 $O(1)$           |\n| `erase(iterator it)`                  | 删除双端队列中的某一个元素           |\n| `erase(iterator first,iterator last)` | 删除双端队列中`[first,last)`中的元素 |\n| `empty()`                             | 判断deque是否空 $O(1)$               |\n| `size()`                              | 返回deque的元素数量 $O(1)$           |\n| `clear()`                             | 清空deque                            |\n\n### 4.3 注意点\n\ndeque可以进行排序\n\n```cpp\n//从小到大\nsort(q.begin(), q.end())\n//从大到小排序\nsort(q.begin(), q.end(), greater<int>());//deque里面的类型需要是int型\nsort(q.begin(), q.end(), greater());//高版本C++才可以用\n```\n\n---\n\n## 5. priority_queue\n\n### 5.1 介绍\n\n优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。\n\n可以实现每次从优先队列中取出的元素都是队列中**优先级最大**的一个。\n\n它的底层是通过**堆**来实现的。\n\n```cpp\n//头文件\n#include<queue>\n//初始化定义\npriority_queue<int> q;\n```\n\n### 5.2 函数方法\n\n| 代码                                                    | 含义                 |\n| ------------------------------------------------------- | -------------------- |\n| `q.top()`                                               | 访问队首元素         |\n| `q.push()`                                              | 入队                 |\n| `q.pop()`                                               | 堆顶（队首）元素出队 |\n| `q.size()`                                              | 队列元素个数         |\n| `q.empty()`                                             | 是否为空             |\n| **注意**没有`clear()`！                                 | 不提供该方法         |\n| 优先队列只能通过`top()`访问队首元素（优先级最高的元素） |                      |\n\n### 5.3 设置优先级\n\n#### 5.3.1 基本数据类型的优先级\n\n```cpp\npriority_queue<int> pq; // 默认大根堆, 即每次取出的元素是队列中的最大值\npriority_queue<int, vector<int>, greater<int> > q; // 小根堆, 每次取出的元素是队列中的最小值\n```\n\n**参数解释：**\n\n- **第二个参数：**\n  `vector< int >` 是用来承载底层数据结构堆的容器，若优先队列中存放的是`double`型数据，就要填`vector< double >`\n  **总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。**\n\n- **第三个参数：**\n  `less< int >`   表示数字大的优先级大，堆顶为最大的数字\n  `greater< int >`表示数字小的优先级大，堆顶为最小的数字\n  **int代表的是数据类型，也要填优先队列中存储的数据类型**\n\n下面介绍基础数据类型优先级设置的写法。\n\n**1. 基础写法（非常常用）**\n\n```cpp\npriority_queue<int> q1; // 默认大根堆, 即每次取出的元素是队列中的最大值\npriority_queue<int, vector<int>, less<int> > q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行\n\npriority_queue<int, vector<int>, greater<int> > q3; // 小根堆, 每次取出的元素是队列中的最小值\n```\n\n**2. 自定义排序（不常见，主要是写着麻烦）**\n\n下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。\n\n```cpp\nstruct cmp1\n{\n\tbool operator()(int x,int y)\n\t{\n\t\treturn x > y;\n\t}\n};\nstruct cmp2\n{\n\tbool operator()(const int x,const int y)\n\t{\n\t\treturn x < y;\n\t}\n};\npriority_queue<int, vector<int>, cmp1> q1; // 小根堆\npriority_queue<int, vector<int>, cmp2> q2; // 大根堆\n```\n\n---\n\n#### 5.3.2 结构体优先级设置\n\n> 即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。\n\n优先级设置可以定义在**结构体内**进行小于号重载，也可以定义在**结构体外**。\n\n```cpp\n//要排序的结构体（存储在优先队列里面的）\nstruct Point\n{\n\tint x,y;\n};\n```\n\n- **版本一：自定义全局比较规则**\n\n```cpp\n//定义的比较结构体\n//注意：cmp是个结构体 \nstruct cmp\n{//自定义堆的排序规则 \n\tbool operator()(const Point& a,const Point& b)\n\t{\n\t\treturn a.x < b.x;\n\t}\n};\n\n//初始化定义， \npriority_queue<Point, vector<Point>, cmp> q; // x大的在堆顶\n```\n\n\n- **版本二：直接在结构体里面写**\n\n> 因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。\n\n结构体内部有两种方式\n\n**方式一**\n\n```cpp\nstruct node\n{\n\tint x, y;\n\tfriend bool operator < (Point a, Point b)\n\t{//为两个结构体参数，结构体调用一定要写上friend\n\t\treturn a.x < b.x;//按x从小到大排，x大的在堆顶\n\t}\n};\n```\n\n**方式二**\n\n```cpp\nstruct node\n{\n    int x, y;\n    bool operator < (const Point &a) const\n    {//直接传入一个参数，不必要写friend\n        return x < a.x;//按x升序排列，x大的在堆顶\n    }\n};\n```\n\n优先队列的定义\n\n```cpp\npriority_queue<Point> q;\n```\n\n**注意：** 优先队列自定义排序规则和`sort()`函数定义`cmp`函数很相似，但是最后返回的情况是**相反**的。即相同的符号，最后定义的排列顺序是完全相反的。\n所以只需要记住`sort`的排序规则和优先队列的排序规则是相反的就可以了。\n\n---\n\n### 5.4 存储特殊类型的优先级\n\n#### 5.4.1 存储pair类型\n\n- 排序规则：\n  默认先对`pair`的`first`进行降序排序，然后再对`second`降序排序\n  对`first`先排序，大的排在前面，如果`first`元素相同，再对`second`元素排序，保持大的在前面。\n\n> `pair`请参考下文\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    priority_queue<pair<int, int> >q;\n\tq.push({7, 8});\n\tq.push({7, 9});\n\tq.push(make_pair(8, 7));\n    while(!q.empty())\n    {\n        cout << q.top().first << \" \" << q.top().second << \"\\n\";\n        q.pop();\n    }\n    return 0;\n}\n```\n\n>结果：\n>8 7\n>7 9\n>7 8\n\n---\n\n## 6. map\n\n### 6.1 介绍\n\n映射类似于函数的对应关系，每个`x`对应一个`y`，而`map`是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。\n\n>比如说：学习 对应 看书，学习 是键，看书 是值。\n>学习->看书\n>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。\n>玩耍->打游戏\n\n```cpp\n//头文件\n#include<map>\n//初始化定义\nmap<string,string> mp;\nmap<string,int> mp;\nmap<int,node> mp;//node是结构体类型\n```\n\n> map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n\n### 6.2 函数方法\n\n| 代码                   | 含义                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| `mp.find(key)`         | 返回键为key的映射的迭代器 $O(logN) $  注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$ |\n| `mp.erase(it)`         | 删除迭代器对应的键和值$O(1)$                                 |\n| `mp.erase(key)`        | 根据映射的键删除键和值 $O(logN)$                             |\n| `mp.erase(first,last)` | 删除左闭右开区间迭代器对应的键和值 $O(last-first)$           |\n| `mp.size()`            | 返回映射的对数$ O(1)$                                        |\n| `mp.clear()`           | 清空map中的所有元素$O(N)$                                    |\n| `mp.insert()`          | 插入元素，插入时要构造键值对                                 |\n| `mp.empty()`           | 如果map为空，返回true，否则返回false                         |\n| `mp.begin()`           | 返回指向map第一个元素的迭代器（地址）                        |\n| `mp.end()`             | 返回指向map尾部的迭代器（最后一个元素的**下一个**地址）      |\n| `mp.rbegin()`          | 返回指向map最后一个元素的迭代器（地址）                      |\n| `mp.rend()`            | 返回指向map第一个元素前面(上一个）的逆向迭代器（地址）       |\n| `mp.count(key)`        | 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 |\n| `mp.lower_bound()`     | 返回一个迭代器，指向键值>= **key**的第一个元素               |\n| `mp.upper_bound()`     | 返回一个迭代器，指向键值> key的第一个元素                    |\n\n**下面说明部分函数方法的注意点**\n\n>注意：\n>查找元素是否存在时，可以使用\n>①`mp.find()` ② `mp.count()` ③ `mp[key]`\n>但是第三种情况，如果不存在对应的`key`时，会自动创建一个键值对（产生一个额外的键值对空间）\n>所以为了不增加额外的空间负担，最好使用前两种方法\n\n---\n\n**使用迭代器进行正反向遍历：**\n\n `mp.begin()`和`mp.end()`用法：\n**用于正向遍历map**\n\n```cpp\nmap<int,int> mp;\nmp[1] = 2;\nmp[2] = 3;\nmp[3] = 4;\nauto it = mp.begin();\nwhile(it != mp.end())\n{\n\tcout << it->first << \" \" << it->second << \"\\n\";\n\tit ++;\n}\n```\n\n**结果：**\n\n```\n1 2\n2 3\n3 4\n```\n\n\n\n`mp.rbegin()`和`mp.rend()`\n**用于逆向遍历map**\n\n```cpp\nmap<int,int> mp;\nmp[1] = 2;\nmp[2] = 3;\nmp[3] = 4;\nauto it = mp.rbegin();\nwhile(it != mp.rend())\n{\n\tcout << it->first << \" \" << it->second << \"\\n\";\n\tit ++;\n}\n```\n\n**结果：**\n\n```\n3 4\n2 3\n1 2\n```\n\n---\n\n二分查找`lower_bound() upper_bound()`\n\n>map的二分查找以第一个元素（即键为准），对**键**进行二分查找\n>返回值为map迭代器类型\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tmap<int, int> m{{1, 2}, {2, 2}, {1, 2}, {8, 2}, {6, 2}};//有序\n\tmap<int, int>::iterator it1 = m.lower_bound(2);\n\tcout << it1->first << \"\\n\";//it1->first=2\n\tmap<int, int>::iterator it2 = m.upper_bound(2);\n\tcout << it2->first << \"\\n\";//it2->first=6\n\treturn 0;\n}\n\n```\n\n---\n\n###   6.3 添加元素\n\n```cpp\n//先声明\nmap<string,string> mp;\n```\n\n**方式一：**\n\n```cpp\nmp[\"学习\"] = \"看书\";\nmp[\"玩耍\"] = \"打游戏\";\n```\n\n**方式二：插入元素构造键值对**\n\n```cpp\nmp.insert(make_pair(\"vegetable\",\"蔬菜\"));\n```\n\n**方式三：**\n\n```cpp\nmp.insert(pair<string,string>(\"fruit\",\"水果\"));\n```\n\n**方式四:**\n\n```cpp\nmp.insert({\"hahaha\",\"wawawa\"});\n```\n\n---\n\n### 6.4 访问元素\n\n**6.4.1 下标访问：**(大部分情况用于访问单个元素)\n\n```cpp\nmp[\"菜哇菜\"] = \"强哇强\";\ncout << mp[\"菜哇菜\"] << \"\\n\";//只是简写的一个例子，程序并不完整\n```\n\n**6.4.2 遍历访问：**\n\n**方式一：迭代器访问**\n\n```cpp\nmap<string,string>::iterator it;\nfor(it = mp.begin(); it != mp.end(); it++)\n{\n\t//      键                 值 \n\t// it是结构体指针访问所以要用 -> 访问\n\tcout << it->first << \" \" << it->second << \"\\n\";\n\t//*it是结构体变量 访问要用 . 访问\n\t//cout<<(*it).first<<\" \"<<(*it).second;\n}\n```\n\n**方式二：智能指针访问**\n\n```cpp\nfor(auto i : mp)\ncout << i.first << \" \" << i.second << endl;//键，值\n```\n\n**方式三：对指定单个元素访问**\n\n```cpp\nmap<char,int>::iterator it = mp.find('a');\ncout << it -> first << \" \" <<  it->second << \"\\n\";\n```\n\n**方式四：c++17特性才具有**\n\n```cpp\nfor(auto [x, y] : mp)\n\tcout << x << \" \" << y << \"\\n\";\n//x,y对应键和值\n```\n\n### 6.5 与unordered_map的比较\n\n这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。\n\n#### 6.5.1 内部实现原理\n\n**map**：内部用**红黑树**实现，具有**自动排序**（按键从小到大）功能。\n\n**unordered_map**：内部用**哈希表**实现，内部元素无序杂乱。\n\n#### 6.5.2 效率比较\n\n**map**：\n\n- 优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$\n\n- 缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。\n\n**unordered_map**：\n\n- 优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。\n- 缺点：建立哈希表比较耗时。\n\n> 两者方法函数基本一样，差别不大。\n>\n> 注意：\n>\n> - 随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。\n>\n> - 使用`[]`查找元素时，如果元素不存在，两种容器**都是**创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会**大大降低**。\n>\n> - 查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）\n>\n>   ```cpp\n>   // 以 map 为例\n>   map<int, int> mp;\n>   int x = 999999999;\n>   if(mp.count(x)) // 此处判断是否存在x这个键\n>       cout << mp[x] << \"\\n\";   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建\n>   ```\n\n\n\n还有一种映射：\n\n[multimap]()\n键可以重复，即一个键对应多个值，如要了解，可以自行搜索。\n\n---\n\n## 7 set\n\n### 7.1 介绍\n\nset容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。\n\n即：set里面的元素**不重复 且有序**\n\n```cpp\n//头文件\n#include<set>\n//初始化定义\nset<int> s;\n```\n\n### 7.2 函数方法\n\n| 代码                   | 含义                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| `s.begin()`            | 返回set容器的第一个元素的地址（迭代器）$O(1)$                |\n| `s.end()`              | 返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$        |\n| `s.rbegin()`           | 返回逆序迭代器，指向容器元素最后一个位置$O(1)$               |\n| `s.rend()`             | 返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$           |\n| `s.clear()`            | 删除set容器中的所有的元素,返回unsigned int类型$O(N)$         |\n| `s.empty()`            | 判断set容器是否为空$O(1)$                                    |\n| `s.insert()`           | 插入一个元素                                                 |\n| `s.size()`             | 返回当前set容器中的元素个数$O(1)$                            |\n| `erase(iterator)`      | 删除定位器iterator指向的值                                   |\n| `erase(first,second）` | 删除定位器first和second之间的值                              |\n| `erase(key_value)`     | 删除键值key_value的值                                        |\n| 查找                   |                                                              |\n| `s.find(element)`      | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |\n| `s.count(element)`     | 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现 |\n| `s.lower_bound(k)`     | 返回大于等于k的第一个元素的迭代器$O(logN)$                   |\n| `s.upper_bound(k)`     | 返回大于k的第一个元素的迭代器$O(logN)$                       |\n\n---\n\n### 7.3 访问\n\n**迭代器访问**\n\n```cpp\nfor(set<int>::iterator it = s.begin(); it != s.end(); it++)\n\tcout << *it << \" \";\n```\n\n**智能指针**\n\n```cpp\nfor(auto i : s)\n\tcout << i << endl;\n```\n\n**访问最后一个元素**\n\n```cpp\n//第一种\ncout << *s.rbegin() << endl;\n```\n\n```cpp\n //第二种\nset<int>::iterator iter = s.end();\niter--;\ncout << (*iter) << endl; //打印2;\n```\n\n```cpp\n//第三种\ncout << *(--s.end()) << endl;\n```\n\n---\n\n### 7.4 重载<运算符\n\n- **基础数据类型**\n\n方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）\n\n```cpp\nset<int> s1; // 默认从小到大排序\nset<int, greater<int> > s2; // 从大到小排序\n```\n\n方式二：重载运算符。（很麻烦，不太常用，没必要）\n\n```cpp\n//重载 < 运算符\nstruct cmp {\n    bool operator () (const int& u, const int& v) const\n    {\n       // return + 返回条件\n       return u > v;\n    }\n};\nset<int, cmp> s; \n\nfor(int i = 1; i <= 10; i++)\n    s.insert(i);\nfor(auto i : s)\n    cout << i << \" \";\n// 10 9 8 7 6 5 4 3 2 1\n```\n\n方式三：初始化时使用匿名函数定义比较规则\n\n```cpp\nset<int, function<bool(int, int)>> s([&](int i, int j){\n    return i > j; // 从大到小\n});\nfor(int i = 1; i <= 10; i++)\n    s.insert(i);\nfor(auto x : s)\n    cout << x << \" \";\n```\n\n\n\n- **高级数据类型（结构体）**\n\n直接重载结构体运算符即可，让结构体可以比较。\n\n```cpp\nstruct Point\n{\n\tint x, y;\n\tbool operator < (const Point &p) const\n\t{\n\t\t// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大\n\t\tif(x == p.x)\n\t\t\treturn y < p.y;\n\t\treturn x < p.x;\n\t}\n};\n\nset<Point> s;\nfor(int i = 1; i <= 5; i++)\n{\n    int x, y;\n    cin >> x >> y;\n    s.insert({x, y});\n}\t\n/* 输入\n5 4\n5 2\n3 7\n3 5\n4 8\n*/\n\nfor(auto i : s)\n    cout << i.x << \" \" << i.y << \"\\n\";\n/* 输出\n3 5\n3 7\n4 8\n5 2\n5 4\n*/\n```\n\n\n\n### 7.5 其它set\n\n`multiset`:元素可以重复，且元素有序\n`unordered_set`  ：元素无序且只能出现一次\n`unordered_multiset` ：  元素无序可以出现多次\n\n---\n\n## 8 pair\n\n### 8.1 介绍\n\npair只含有两个元素，可以看作是只有两个元素的结构体。\n**应用：**\n\n- 代替二元结构体\n- 作为map键值对进行插入（代码如下）\n\n```cpp\nmap<string,int>mp;\nmp.insert(pair<string,int>(\"xingmaqi\",1));\n```\n\n```cpp\n//头文件\n#include<utility>\n\n//1.初始化定义\npair<string,int> p(\"wangyaqi\",1);//带初始值的\npair<string,int> p;//不带初始值的\n\n//2.赋值\np = {\"wang\",18};\n```\n\n### 8.2 访问\n\n```cpp\n//定义结构体数组\npair<int,int>p[20];\nfor(int i = 0; i < 20; i++)\n{\n\t//和结构体类似，first代表第一个元素，second代表第二个元素\n\tcout << p[i].first << \" \" << p[i].second;\n}\n```\n\n---\n\n## 9 string\n\n### 9.1 介绍\n\nstring是一个字符串类，和`char`型字符串类似。\n\n可以把string理解为一个字符串类型，像int一样可以定义\n\n### 9.2 初始化及定义\n\n\n```cpp\n//头文件\n#include<string>\n\n//1.\nstring str1; //生成空字符串\n\n//2.\nstring str2(\"123456789\"); //生成\"1234456789\"的复制品 \n\n//3.\nstring str3(\"12345\", 0, 3);//结果为\"123\" ，从0位置开始，长度为3\n\n//4.\nstring str4(\"123456\", 5); //结果为\"12345\" ，长度为5\n\n//5.\nstring str5(5, '2'); //结果为\"22222\" ,构造5个字符'2'连接而成的字符串\n\n//6.\nstring str6(str2, 2); //结果为\"3456789\"，截取第三个元素（2对应第三位）到最后\n\n```\n\n**简单使用**\n\n- 访问单个字符：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring s = \"xing ma qi!!!\";\n\tfor(int i = 0; i < s.size(); i++)\n\t\tcout << s[i] << \" \";\n\treturn 0;\n}\n```\n\n- string数组使用：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring s[10];\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\ts[i] = \"loading...  \" ;\n\t\tcout << s[i] << i << \"\\n\";\n\t} \n\treturn 0;\n}\n```\n\n结果：\n\n```\nloading...  1\nloading...  2\nloading...  3\nloading...  4\nloading...  5\nloading...  6\nloading...  7\nloading...  8\nloading...  9\n```\n\n###  9.3 string 特性\n\n- 支持**比较**运算符\n  string字符串支持常见的比较操作符`（>,>=,<,<=,==,!=）`，支持`string`与`C-string`的比较（如 `str < \"hello\"`）。 \n  在使用`>,>=,<,<=`这些操作符的时候是根据“当前字符特性”将字符按 `字典顺序` 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。\n\n  同时，`string (\"aaaa\") <string(aaaaa)`。\n\n - 支持`+`**运算**符，代表拼接字符串\n   string字符串可以拼接，通过\"+\"运算符进行拼接。\n\n   ```cpp\n   string s1 = \"123\";\n   string s2 = \"456\";\n   string s = s1 + s2;\n   cout << s;   //123456\n   ```\n\n### 9.4 读入详解\n\n**读入字符串，遇空格，回车结束**\n\n```cpp\nstring s;\ncin >> s;\n```\n\n **读入一行字符串（包括空格），遇回车结束**\n\n```cpp\nstring s;\ngetline(cin, s);\n```\n\n注意: `getline(cin, s)`会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：`getchar()` 或` cin.get()`\n\n错误读取：\n\n```cpp\nint n;\nstring s;\ncin >> n;\ngetline(cin, s); //此时读取相当于读取了前一个回车字符\n```\n\n正确读取：\n\n```cpp\nint n;\nstring s;\ncin >> n;\ngetchar(); //cin.get()\ngetline(cin, s);//可正确读入下一行的输入\n```\n\n> `cin`与`cin.getline()`混用\n>\n> cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致`getline()`读取回车，结束。\n> 需要在cin后面加`cin.ignore()`；主动删除输入流中的换行符。（不常用）\n\n**cin和cout解锁**\n\n代码（写在main函数开头）：\n\n```cpp\nios::sync_with_stdio(false);\ncin.tie(0),cout.tie(0);\n```\n\n> 为什么要进行`cin`和`cout`的解锁，原因是：\n>\n> 在一些题目中，读入的**数据量很大**，往往超过了1e5（10^5^）的数据量,而`cin`和`cout`的读入输出的速度**很慢**（是因为`cin`和`cout`为了兼容C语言的读入输出在性能上做了妥协），远不如`scanf`和`printf`的速度，具体原因可以搜索相关的博客进行了解。\n>\n> **所以**对`cin`和`cout`进行解锁使`cin`和`cout`的速度几乎接近`scanf`和`printf`，避免输入输出超时。\n\n**注意**：`cin cout`解锁使用时，不能与 `scanf,getchar, printf,cin.getline()`混用，一定要注意，会出错。\n\n> **string与C语言字符串（C-string）的区别**\n>\n> - string\n>   是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为`string`，字符串结尾没有`\\0`字符\n> - C-string\n>   C语言中的字符串，用char数组实现，类型为`const char *`,字符串结尾以`\\0`结尾\n\n一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法`c_str()`实现string向char数组的转换。\n\n```cpp\nstring s = \"xing ma qi\";\nchar s2[] = s.c_str();\n```\n\n### 9.5 函数方法\n\n- **获取字符串长度**\n\n| 代码                     | 含义                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| `s.size()`和`s.length()` | 返回string对象的字符个数，他们执行效果相同。               |\n| `s.max_size()`           | 返回string对象最多包含的字符数，超出会抛出length_error异常 |\n| `s.capacity()`           | 重新分配内存之前，string对象能包含的最大字符数             |\n\n- **插入**\n\n\n| 代码                          | 含义                         |\n| ----------------------------- | ---------------------------- |\n| `s.push_back()`               | 在末尾插入                   |\n| 例：`s.push_back('a')`        | 末尾插入一个字符a            |\n| `s.insert(pos,element)`       | 在pos位置插入element         |\n| 例：`s.insert(s.begin(),'1')` | 在第一个位置插入1字符        |\n| `s.append(str)`               | 在s字符串结尾添加str字符串   |\n| 例：`s.append(\"abc\")`         | 在s字符串末尾添加字符串“abc” |\n\n\n- **删除**\n\n\n| 代码                                   | 含义                                           |\n| -------------------------------------- | ---------------------------------------------- |\n| `erase(iterator p)`                    | 删除字符串中p所指的字符                        |\n| `erase(iterator first, iterator last)` | 删除字符串中迭代器区间`[first,last)`上所有字符 |\n| `erase(pos,  len)`                     | 删除字符串中从索引位置pos开始的len个字符       |\n| `clear()`                              | 删除字符串中所有字符                           |\n\n\n- **字符替换**\n\n\n| 代码                     | 含义                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| `s.replace(pos,n,str)`   | 把当前字符串从索引pos开始的n个字符替换为str                  |\n| `s.replace(pos,n,n1,c)`  | 把当前字符串从索引pos开始的n个字符替换为n1个字符c            |\n| `s.replace(it1,it2,str)` | 把当前字符串`[it1,it2)`区间替换为str    **it1 ,it2为迭代器哦** |\n\n\n- **大小写转换** \n\n法一：\n\n| 代码            | 含义       |\n| --------------- | ---------- |\n| `tolower(s[i])` | 转换为小写 |\n| `toupper(s[i])` | 转换为大写 |\n\n法二：\n\n通过stl的transform算法配合tolower 和toupper 实现。\n有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。\n\n```cpp\nstring s;\ntransform(s.begin(),s.end(),s.begin(),::tolower);//转换小写\ntransform(s.begin(),s.end(),s.begin(),::toupper);//转换大写\n```\n\n\n- **分割**\n\n| 代码              | 含义                       |\n| ----------------- | -------------------------- |\n| `s.substr(pos,n)` | 截取从pos索引开始的n个字符 |\n\n\n- **查找**\n\n| 代码                             | 含义                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| `s.find (str,  pos)`             | 在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 |\n| `s.find (c, pos)`                | 在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符 |\n| `s.rfind (str, pos)`             | 在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串 |\n| `s.rfind (c,pos)`                | 在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_first_of (str, pos)`     | 在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_first_not_of (str,pos)`  | 在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_last_of(str, pos)`       | 在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_last_not_of ( str, pos)` | 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串 |\n\n\n\n```cpp\n#include<string>\n#include<iostream>\nint main()\n{\n    string s(\"dog bird chicken bird cat\");\n//字符串查找-----找到后返回首字母在字符串中的下标\n// 1. 查找一个字符串\n    cout << s.find(\"chicken\") << endl;// 结果是：9\n    \n// 2. 从下标为6开始找字符'i'，返回找到的第一个i的下标\n    cout << s.find('i',6) << endl;// 结果是：11\n    \n// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标\n    cout << s.rfind(\"chicken\") << endl;// 结果是：9\n    \n// 4. 从字符串的末尾开始查找字符\n    cout << s.rfind('i') << endl;// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符\n    \n// 5. 在该字符串中查找第一个属于字符串s的字符\n    cout << s.find_first_of(\"13br98\") << endl;// 结果是：4---b\n    \n// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4\n    cout << s.find_first_not_of(\"hello dog 2006\") << endl; // 结果是：4\n    cout << s.find_first_not_of(\"dog bird 2006\") << endl;  // 结果是：9\n    \n// 7. 在该字符串最后中查找第一个属于字符串s的字符\n    cout << s.find_last_of(\"13r98\") << endl;// 结果是：19\n\n// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21\n    cout << s.find_last_not_of(\"teac\") << endl;// 结果是：21\n}\n```\n\n- **排序**\n\n```cpp\nsort(s.begin(),s.end());  //按ASCII码排序\n```\n\n---\n\n## 10 bitset\n\n### 10.1 介绍\n\nbitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间\n\n```cpp\n//头文件\n#include<bitset>\n```\n\n### 10.2 初始化定义\n\n初始化方法\n\n| 代码                     | 含义                             |\n| ------------------------ | -------------------------------- |\n| `bitset < n >a`          | a有n位，每位都为0                |\n| `bitset < n >a(b)`       | a是unsigned long型u的一个副本    |\n| `bitset < n >a(s)`       | a是string对象s中含有的位串的副本 |\n| `bitset < n >a(s,pos,n)` | a是s中从位置pos开始的n个位的副本 |\n\n> 注意：`n`必须为常量表达式\n\n演示代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tbitset<4> bitset1;　　  //无参构造，长度为４，默认每一位为０\n\t\n\tbitset<9> bitset2(12);　//长度为9，二进制保存，前面用０补充\n\t\n\tstring s = \"100101\";\n\tbitset<10> bitset3(s);　　//长度为10，前面用０补充\n\t\n\tchar s2[] = \"10101\";\n\tbitset<13> bitset4(s2);　　//长度为13，前面用０补充\n\t\n\tcout << bitset1 << endl;　　//0000\n\tcout << bitset2 << endl;　　//000001100\n\tcout << bitset3 << endl;　　//0000100101\n\tcout << bitset4 << endl;　//0000000010101\n\treturn 0;\n}\n```\n\n---\n\n### 10.3 特性\n\n`bitset`可以进行**位操作**\n\n```cpp\nbitset<4> foo (string(\"1001\"));\nbitset<4> bar (string(\"0011\"));\n\ncout << (foo ^= bar) << endl;// 1010 (foo对bar按位异或后赋值给foo)\n\ncout << (foo &= bar) << endl;// 0010 (按位与后赋值给foo)\n\ncout << (foo |= bar) << endl;// 0011 (按位或后赋值给foo)\n\ncout << (foo <<= 2) << endl;// 1100 (左移２位，低位补０，有自身赋值)\n\ncout << (foo >>= 1) << endl;// 0110 (右移１位，高位补０，有自身赋值)\n\ncout << (~bar) << endl;// 1100 (按位取反)\n\ncout << (bar << 1) << endl;// 0110 (左移，不赋值)\n\ncout << (bar >> 1) << endl;// 0001 (右移，不赋值)\n\ncout << (foo == bar) << endl;// false (0110==0011为false)\n\ncout << (foo != bar) << endl;// true  (0110!=0011为true)\n\ncout << (foo & bar) << endl;// 0010 (按位与，不赋值)\n\ncout << (foo | bar) << endl;// 0111 (按位或，不赋值)\n\ncout << (foo ^ bar) << endl;// 0101 (按位异或，不赋值)\n```\n\n**访问**\n\n```cpp\n//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：\nbitset<4> foo (\"1011\"); \n\ncout << foo[0] << endl;　　//1\ncout << foo[1] << endl;　　//1\ncout << foo[2] << endl;　　//0\n```\n\n---\n\n### 10.4 方法函数\n\n|      代码      |                    含义                    |\n| :------------: | :----------------------------------------: |\n|   `b.any()`    |  b中是否存在置为1的二进制位，有 返回true   |\n|   `b.none()`   |        b中是否没有1，没有 返回true         |\n|  `b.count()`   |                b中为1的个数                |\n|   `b.size()`   |             b中二进制位的个数              |\n| `b.test(pos)`  |     测试b在pos位置是否为1，是 返回true     |\n|    `b[pos]`    |           返回b在pos处的二进制位           |\n|   `b.set()`    |             把b中所有位都置为1             |\n|  `b.set(pos)`  |             把b中pos位置置为1              |\n|  `b.reset()`   |             把b中所有位都置为0             |\n| `b.reset(pos)` |             把b中pos位置置为0              |\n|   `b.flip()`   |           把b中所有二进制位取反            |\n| `b.flip(pos)`  |              把b中pos位置取反              |\n| `b.to_ulong()` | 用b中同样的二进制位返回一个unsigned long值 |\n\n---\n\n## 11 array\n\n### 11.1 介绍\n\n头文件\n\n```cpp\n#include<array>\n```\n\n`array`是C++11新增的容器，效率与普通数据相差无几，比`vector`效率要高，自身添加了一些成员函数。\n\n和其它容器不同，array 容器的大小是**固定**的，无法动态的扩展或收缩，**只允许访问或者替换存储的元素。**\n\n**注意：**\n\n`array`的使用要在`std`命名空间里\n\n### 11.2 声明与初始化\n\n**基础数据类型**\n\n声明一个大小为100的`int`型数组，元素的值不确定\n\n```cpp\narray<int, 100> a;\n```\n\n声明一个大小为100的`int`型数组，初始值均为`0`(初始值与默认元素类型等效)\n\n```cpp\narray<int, 100> a{};\n```\n\n声明一个大小为100的`int`型数组，初始化部分值，其余全部为`0`\n\n```cpp\narray<int, 100> a{1, 2, 3};\n```\n\n或者可以用等号\n\n```cpp\narray<int, 100> a = {1, 2, 3};\n```\n\n**高级数据类型**\n\n不同于数组的是对元素类型不做要求，可以套结构体\n\n```cpp\narray<string, 2> s = {\"ha\", string(\"haha\")};\narray<node, 2> a;\n```\n\n---\n\n### 11.3 存取元素\n\n- 修改元素\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\na[0] = 4;\n```\n\n- 访问元素\n\n下标访问\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\nfor(int i = 0; i < 4; i++) \n    cout << a[i] << \" \\n\"[i == 3];\n```\n\n利用`auto`访问\n\n```cpp\nfor(auto i : a)\n    cout << i << \" \";\n```\n\n迭代器访问\n\n```cpp\nauto it = a.begin();\nfor(; it != a.end(); it++) \n    cout << *it << \" \";\n```\n\n `at()`函数访问\n\n下标为`1`的元素加上下标为`2`的元素，答案为`5`\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\nint res = a.at(1) + a.at(2);\ncout << res << \"\\n\";\n```\n\n `get`方法访问\n\n将`a`数组下标为`1`位置处的值改为`x`\n\n注意：获取的下标只能写数字，不能填变量\n\n```cpp\nget<1>(a) = x;\n```\n\n---\n\n### 11.4 成员函数\n\n\n\n| 成员函数              | 功能                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| `begin()`             | 返回容器中第一个元素的访问迭代器（地址）                     |\n| `end()`               | 返回容器最后一个元素之后一个位置的访问迭代器（地址）         |\n| `rbegin()`            | 返回最后一个元素的访问迭代器（地址）                         |\n| `rend()`              | 返回第一个元素之前一个位置的访问迭代器（地址）               |\n| `size()`              | 返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数`N` |\n| `max_size()`          | 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N |\n| `empty()`             | 判断容器是否为空                                             |\n| `at(n)`               | 返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常 |\n| `front()`             | 返回容器中第一个元素的直接引用，函数不适用于空的 array 容器  |\n| `back()`              | 返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。 |\n| `data()`              | 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能 |\n| `fill(x)`             | 将 `x` 这个值赋值给容器中的每个元素,相当于初始化             |\n| `array1.swap(array2)` | 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型 |\n\n---\n\n### 11.5 部分用法示例\n\n`data()`\n\n指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。\n\n`at()`\n\n下标为`1`的元素加上下标为`2`的元素，答案为`5`\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\nint res = a.at(1) + a.at(2);\ncout << res << \"\\n\";\n```\n\n`fill()`\n\narray的`fill()`函数，将`a`数组全部元素值变为`x`\n\n```cpp\na.fill(x);\n```\n\n另外还有其它的`fill()`函数:将`a`数组$[begin,end)$全部值变为`x`\n\n```cpp\nfill(a.begin(), a.end(), x);\n```\n\n**get方法获取元素值**\n\n将`a`数组下标为`1`位置处的值改为`x`\n\n注意:获取的下标只能写数字，不能填变量\n\n```cpp\nget<1>(a) = x;\n```\n\n**排序**\n\n```cpp\nsort(a.begin(), a.end());\n```\n\n---\n\n## 12 tuple\n\n### 12.1 介绍 \n\ntuple模板是pair的泛化，可以封装不同类型任意数量的对象。\n\n可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。\n\ntuple可以等价为**结构体**使用\n\n**头文件**\n\n```cpp\n#include <tuple>\n```\n\n###  12.2 声明初始化\n\n声明一个空的`tuple`三元组\n\n```cpp\ntuple<int, int, string> t1;\n```\n\n赋值\n\n```cpp\nt1 = make_tuple(1, 1, \"hahaha\");\n```\n\n创建的同时初始化\n\n```cpp\ntuple<int, int, int, int> t2(1, 2, 3, 4);\n```\n\n可以使用pair对象构造tuple对象，但tuple对象必须是两个元素\n\n```cpp\nauto p = make_pair(\"wang\", 1);\ntuple<string, int> t3 {p}; //将pair对象赋给tuple对象\n```\n\n### 12.3 元素操作\n\n获取tuple对象`t`的第一个元素\n\n```cpp\nint first = get<0>(t);\n```\n\n修改tuple对象`t`的第一个元素\n\n```cpp\nget<0>(t) = 1;\n```\n\n\n\n### 12.4 函数操作\n\n- 获取元素个数\n\n```cpp\ntuple<int, int, int> t(1, 2, 3);\ncout << tuple_size<decltype(t)>::value << \"\\n\"; // 3\n```\n\n- 获取对应元素的值\n\n通过`get<n>(obj)`方法获取,`n`必须为数字不能是变量\n\n```cpp\ntuple<int, int, int> t(1, 2, 3);\ncout << get<0>(t) << '\\n'; // 1\ncout << get<1>(t) << '\\n'; // 2\ncout << get<2>(t) << '\\n'; // 3\n```\n\n- 通过`tie`解包 获取元素值\n\n`tie`可以让tuple变量中的三个值依次赋到tie中的三个变量中\n\n```cpp\nint one, three;\nstring two; \ntuple<int, string, int> t(1, \"hahaha\", 3);\ntie(one, two, three) = t;\ncout << one << two << three << \"\\n\"; // 1hahaha3\n```\n\n---\n\n# STL函数\n\n## accumulate\n\n```\naccumulate(beg, end, init)\n```\n\n**复杂度：** $O(N)$\n\n> 作用：对一个序列的元素求和\n\n`init`为对序列元素求和的**初始值**\n\n返回值类型：与`init`\n\n- **基础累加求和：**\n\n```cpp\nint a[]={1,3,5,9,10};\n\n//对[0,2]区间求和，初始值为0，结果为0+1+3+5=9\nint res1 = accumulate(a, a + 3, 0);\n\n//对[0,3]区间求和，初始值为5，结果为5+1+3+5+9=23\nint res2 = accumulate(a, a + 4, 5);\n```\n\n- **自定义二元对象求和：**\n\n使用**lamda表达式**\n\n```cpp\ntypedef long long ll;\nstruct node\n{\n    ll num;\n}st[10];\n\nfor(int i = 1; i <= n; i++)\n    st[i].num = i + 10000000000;\n//返回值类型与init一致，同时注意参数类型（a）也要一样\n//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007\nll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b){\n    return a + b.num;\n});\n    \n```\n\n## atoi\n\n```\natoi(const char *)\n```\n\n> 将字符串转换为`int`类型\n\n注意参数为`char`型数组，如果需要将string类型转换为int类型，可以使用`stoi`函数（参考下文），或者将`string`类型转换为`const char *`类型。\n\n关于输出数字的范围：\n`atoi`**不做**范围检查，如果超出上界，输出上界，超出下界，输出下界。\n`stoi`**会做**范围检查，默认必须在`int`范围内，如果超出范围，会出现RE（Runtime Error）错误。\n\n```cpp\nstring s = \"1234\";\nint a = atoi(s.c_str());\ncout << a << \"\\n\"; // 1234\n```\n或者\n```cpp\nchar s[] = \"1234\";\nint a = atoi(s);\ncout << a << \"\\n\";\n```\n\n## fill\n\n```\nfill(beg,end,num)\n```\n\n**复杂度：** $O(N)$\n\n> 对一个序列进行初始化赋值\n\n```cpp\n//对a数组的所有元素赋1\nint a[5];\nfill(a,a+5,1);\nfor(int i=0;i<5;i++)\n    cout<<a[i]<<\" \";\n//1 1 1 1 1\n```\n\n注意区分memset：\n\n`memset()`是按**字节**进行赋值，对于初始化赋`0`或`-1`有比较好的效果.\n\n如果赋某个特定的数会**出错**，赋值特定的数建议使用`fill()`\n\n\n\n## is_sorted\n\n```\nis_sorted(beg,end)\n```\n\n**复杂度：** $O(N)$\n\n> 判断序列是否有序（升序），返回`bool`值\n\n```cpp\n//如果序列有序，输出YES\nif(is_sorted(a,a+n))\n    cout<<\"YES\\n\";\n```\n\n## iota\n\n```\niota(beg, end)\n```\n\n> 让序列递增赋值\n\n```cpp\nvector<int> a(10);\niota(a.begin(), a.end(), 0);\nfor(auto i : a)\n\tcout << i << \" \";\n// 0 1 2 3 4 5 6 7 8 9\n```\n\n## lower_bound + upper_bound\n\n**复杂度：** $O(logN)$\n\n> 作用：二分查找\n\n```cpp\n//在a数组中查找第一个大于等于x的元素，返回该元素的地址\nlower_bound(a, a + n, x);\n//在a数组中查找第一个大于x的元素，返回该元素的地址\nupper_bound(a, a + n, x);\n\n//如果未找到，返回尾地址的下一个位置的地址\n```\n\n##  max_element+min_element\n\n**复杂度：** $O(N)$\n\n> 找最大最小值\n\n```cpp\n//函数都是返回地址，需要加*取值\nint mx = *max_element(a, a + n);\nint mn = *min_element(a, a + n);\n```\n\n##  max+min\n\n**复杂度：** $O(1)$\n\n> 找多个元素的最大值和最小值\n\n```cpp\n//找a，b的最大值和最小值\nmx = max(a, b);\nmn = min(a, b);\n```\n\n```cpp\n//找到a,b,c,d的最大值和最小值\nmx = max({a, b, c, d});\nmn = min({a, b, c, d});\n```\n\n## minmax\n\n```\nminmax(a, b)\n```\n\n**复杂度：** $O(1)$\n\n> 返回一个`pair`类型，第一个元素是`min(a, b)`， 第二个元素是`max(a, b)`\n\n```cpp\npair<int, int> t = minmax(4, 2);\n// t.first = 2, t.second = 4\n```\n\n## minmax_element\n\n```\nminmax_element(beg, end)\n```\n\n**复杂度：** $O(N)$\n\n> 返回序列中的最小和最大值组成pair的对应的地址，返回类型为`pair<vector<int>::iterator, vector<int>::iterator>`\n\n```cpp\nint n = 10;\nvector<int> a(n);\niota(a.begin(), a.end(), 1);\nauto t = minmax_element(a.begin(), a.end()); // 返回的是最小值和最大值对应的地址\n// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针\n```\n\n\n\n## nth_element\n\n```\nnth_element(beg, nth, end)\n```\n\n**复杂度：** 平均$O(N)$\n\n> 寻找第序列第n小的值\n\n`nth`为一个迭代器，指向序列中的一个元素。第n小的值恰好在`nth`位置上。\n\n执行`nth_element()`之后，序列中的元素会围绕nth进行划分：**nth之前的元素都小于等于它，而之后的元素都大于等于它**\n\n**实例：求序列中的第3小的元素**\n\n```cpp\nnth_element(a, a + 2, a + n);\ncout << a[2] << '\\n';\n```\n\n\n\n## next_permutation\n\n```\nnext_permutation(beg, end)\n```\n\n**复杂度：** $O(N)$\n\n> 求序列的下一个排列，下一个排列是字典序大一号的排列\n\n返回`true`或`false`\n\n- `next_permutation(beg,end)`\n\n  如果是最后一个排列，返回`false`,否则求出下一个序列后，返回`true`\n\n```cpp\n//对a序列进行重排\nnext_permutation(a, a + n);\n```\n\n**应用：求所有的排列**\n\n输出`a`的所有排列\n\n```cpp\n//数组a不一定是最小字典序序列，所以将它排序\nsort(a, a + n);\ndo\n{\n \tfor(int i = 0; i < n; i++)\n        printf(\"%d \", a[i]);\n}while(next_permutation(a, a + n));\n```\n\n-  `prev_permutation(beg,end)`\n\n> 求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false\n\n## partial_sort\n\n```\npartial_sort(beg, mid, end)\n```\n\n**复杂度：** 大概$O(N logM)$ `M`为距离\n\n> 部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置\n>\n> 从beg到mid**前**的元素都排好序\n\n对a数组前5个元素排序按从小到大排序\n\n```cpp\nint a[] = {1,2,5,4,7,9,8,10,6,3};\npartial_sort(a, a + 5, a + 10);\nfor(int i = 0; i < 10; i++) \n    cout << a[i] << ' ';\n//1 2 3 4 5 9 8 10 7 6\n//前五个元素都有序\n```\n\n也可以添加自定义排序规则：\n\n `partial_sort(beg,mid,end,cmp)`\n\n对a的前五个元素都是降序排列\n\n```cpp\nint a[] = {1,2,5,4,7,9,8,10,6,3};\npartial_sort(a, a + 5, a + 10, greater<int>());\nfor(int i = 0; i < 10; i++) \n    cout << a[i] << ' ';\n//10 9 8 7 6 1 2 4 5 3\n//前五个元素降序有序\n```\n\n## random_shuffle\n\n**复杂度：** $O(N)$\n\n> 1. 随机打乱序列的顺序\n> 2. 在 `C++14` 中被弃用，在 `C++17` 中被废除，C++11之后应尽量使用`shuffle`来代替。\n\n```cpp\nvector<int> b(n);\niota(b.begin(), b.end(), 1);// 序列b递增赋值 1, 2, 3, 4,...\n//对a数组随机重排\nrandom_shuffle(a, a + n);\n// C++11之后尽量使用shuffle\nshuffle(b.begin(), b.end());\n```\n\n##  reverse\n\n```\nreverse(beg,end)\n```\n\n**复杂度：** $O(N)$\n\n> 对序列进行翻转\n\n```cpp\nstring s = \"abcde\";\nreverse(s.begin(), s.end());//对s进行翻转\ncout << s << '\\n';//edcba\n\n//对a数组进行翻转\nint a[] = {1, 2, 3, 4};\nreverse(a, a + 4);\ncout << a[0] << a[1] << a[2] << a[3];//4321\n```\n\n##  sort\n\n**复杂度：** $O(N logN)$\n\n> 作用：对一个序列进行排序\n\n```cpp\n//原型：\nsort(beg, end);\nsort(beg, end, cmp);\n```\n\n```cpp\n//对a数组的[1,n]位置进行从小到大排序\nsort(a + 1, a + 1 + n);\n\n//对a数组的[0,n-1]位置从大到小排序\nsort(a, a + n, greater<int>());\n//对a数组的[0,n-1]位置从小到大排序\nsort(a, a + n, less<int>());\n\n//自定义排序，定义比较函数\nbool cmp(node a,node b)\n{\n    //按结构体里面的x值降序排列\n    return a.x > b.x;\n}\nsort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则\n```\n\n##  stable_sort\n\n**复杂度：** $O(N logN)$\n\n> 功能和sort()基本一样\n>\n> 区别在于`stable_sort()`能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置\n\n使用用法和`sort()`一样,见上\n\n## stoi\n\n```\nstoi(const string*)\n```\n\n> 将对应string类型字符串转换为数字\n\n注意参数为`string`字符串类型。\n\n关于输出数字的范围：\n`stoi`**会做**范围检查，默认必须在`int`范围内，如果超出范围，会出现RE（Runtime Error）错误。\n`atoi`**不做**范围检查，如果超出上界，输出上界，超出下界，输出下界。\n\n\n```cpp\nstring s = \"1234\";\nint a = atoi(s);\ncout << a << \"\\n\"; // 1234\n```\n\n## transform\n\n**复杂度：** $O(N)$\n\n> 作用：使用给定操作，将结果写到dest中\n\n```cpp\n//原型：\ntransform(beg, end, dest, unaryOp);\n```\n\n\n\n```cpp\n//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中\ntransform(beg, end, dest, ::tolower);\ntransform(beg, end, dest, ::toupper);\n```\n\n\n\n##  to_string\n\n> 将数字转化为字符串,支持小数（double）\n\n```cpp\nint a = 12345678;\ncout << to_string(a) << '\\n';\n```\n\n\n\n## unique\n\n```\nunique(beg, end)\n```\n\n\n\n**复杂度：** $O(N)$\n\n> 消除重复元素，返回消除完重复元素的下一个位置的地址\n>\n> 如：`a[] = {1,2,3,3,4 }`;\n>\n> unique之后a数组为`{1,2,3,4,3}`前面为无重复元素的数组，后面则是重复元素移到后面，返回`a[4]`位置的地址（不重复元素的尾后地址）\n\n消除重复元素一般需要原序列是**有序序列**\n\n**运用：离散化**\n\n```cpp\nfor(int i = 0; i < n; i++)\n{\n    cin >> a[i];\n    b[i] = a[i];//将a数组复制到b数组\n}\nsort(b, b + n);//对b数组排序\nunique(b, b + n);//消除b重复元素\nfor(int i = 0; i < n; i++)\n{\n    //因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）\n    int pos = lower_bound(b, b + n, a[i]) - b;//在b数组中二分查找第一个大于等于a[i]的下标\n    a[i] = pos;//赋值\n}\n```\n\n##  __gcd\n\n```\n__gcd(a,b)\n```\n\n> 求a和b的最大公约数\n\n`__gcd(12,15) = 3`\n\n`__gcd(21,0) = 21`\n\n## __lg\n\n```\n__lg(a)\n```\n\n\n\n> 1. 求一个数二进制下最高位位于第几位（从**第0位**开始）（或二进制数下有几位）\n> 2. `__lg(x)`相当于返回$\\lfloor log_2 x \\rfloor$\n> 3. 复杂度$O(1)$\n\n`__lg(8) = 3`\n\n`__lg(15) = 3`\n\n\n\n## __builtin_ 内置位运算函数\n\n内置函数有相应的`unsigned lnt`和`unsigned long long`版本，`unsigned long long`只需要在函数名后面加上`ll`就可以了，比如`__builtin_clzll(x)`,默认是32位`unsigned int`\n\n### __builtin_ffs\n\n```\n__builtin_ffs(x)\n```\n\n>二进制中对应最后一位`1`的位数，比如`4`会返回`3`（100）\n\n### __builtin_popcount\n\n```\n__builtin_popcount(x)\n```\n\n>`x`中`1`的个数\n\n### __builtin_ctz\n\n```\n__builtin_ctz(x)\n```\n\n> `x`末尾`0`的个数（`count tail zero`）\n\n### __builtin_clz\n\n```\n__builtin_clz(x)\n```\n\n> `x`前导`0`的个数（`count leading zero`）\n\n```cpp\ncout << __builtin_clz(32); // 26\n//因为共有6位,默认数据范围为32位，32 - 6 = 26\n```\n\n### __builtin_parity\n\n```\n__builtin_parity(x)\n```\n\n> `x`中1的个数的奇偶性， 奇数输出`1`，偶数输出`0`\n\n\n\n> 可参考链接：\n>\n> 1. [C++语法糖](https://www.luogu.com.cn/blog/AccRobin/grammar-candies) https://www.luogu.com.cn/blog/AccRobin/grammar-candies\n\n可能有些人需要PDF文件，公众号【行码棋】回复 STL 获取，抱歉😭\n\n![](https://wyqz.top/medias/gzh.jpg)\n","source":"_posts/C-STL超全总结汇总版.md","raw":"---\ntitle: C++ STL总结\ntop: true\ncover: true\ntoc: true\nmathjax: true\ntags:\n  - C++\n  - STL\n  - 学习总结\ncategories:\n  - STL\nabbrlink: 870124582\ndate: 2022-08-09 21:34:49\npassword:\nsummary:\n---\n\n\n\n# C++ STL 总结-基于算法竞赛（悠享版）\n\n本文介绍常用STL知识，注重应用，强调用法，不强调原理和繁杂的记忆。看过之后请多运用，多敲代码试。\n\n> 费尽心思重新梳理了一下，注意了些美观性，修改了部分错误，添加了部分解释，编写过程非常难。\n\n另外C++版本一定要对，C++11即可，C++17或20更好。\n\n> 实践才是检验真理的唯一标准！\n\nCSDN版本：[https://wyq666.blog.csdn.net/article/details/114026148](https://wyq666.blog.csdn.net/article/details/114026148)\n\n## 1 vector\n\n###  1.1 介绍\n\n`vector`为可变长数组（动态数组），定义的`vector`数组可以随时添加数值和删除元素。\n\n> 注意：**在局部区域中（比如局部函数里面）开vector数组，是在堆空间里面开的。** \n>\n> 在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。\n>\n> 故局部区域**不可以**开大长度数组，但是可以开大长度`vector`。\n\n- 头文件\n\n```cpp\n#include <vector>\n```\n\n- 初始化\n\n  - 一维初始化\n\n    ```cpp\n    vector<int> a; //定义了一个名为a的一维数组,数组存储int类型数据\n    vector<double> b;//定义了一个名为b的一维数组，数组存储double类型数据\n    vector<node> c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型\n    ```\n\n    指定**长度**和**初始值**的初始化\n\n    ```cpp\n    vector<int> v(n);//定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]\n    vector<int> v(n, 1);//v[0]到v[n-1]所有的元素初始值均为1\n    //注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）\n    ```\n    \n    初始化中有多个元素\n    \n    ```cpp\n    vector<int> a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5\n    ```\n    \n    拷贝初始化\n    \n    ```cpp\n    vector<int> a(n + 1, 0);\n    vector<int> b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组\n    ```\n    \n  - 二维初始化\n    定义第一维固定长度为`5`，第二维可变化的二维数组\n  \n    ```cpp\n    vector<int> v[5];//定义可变长二维数组\n    //注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素\n    //第一维固定长度为5，第二维长度可以改变\n    ```\n  \n    > `vector<int> v[5]`可以这样理解：长度为5的v数组，数组中存储的是`vector<int> `数据类型，而该类型就是数组形式，故`v`为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：\n    >\n    > ```cpp\n    > v[1].push_back(2);\n    > v[2].push_back(3);\n    > ```\n  \n    行列均可变\n  \n    ```cpp\n    //初始化二维均可变长数组\n    vector<vectot<int>> v;//定义一个行和列均可变的二维数组\n    ```\n  \n    > 应用：可以在`v`数组里面装多个数组\n    >\n    > ```cpp\n    > vector<int> t1{1, 2, 3, 4};\n    > vector<int> t2{2, 3, 4, 5};\n    > v.push_back(t1);\n    > v.push_back(t2);\n    > v.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector\n    > ```\n  \n    行列长度均固定 `n + 1`行 `m + 1`列初始值为0\n  \n    ```cpp\n    vector<vector<int> > a(n + 1, vector<int>(m + 1, 0));\n    ```\n  \n    c++17或者c++20支持的形式（不常用），与上面相同的初始化\n  \n    ```cpp\n    vector a(n + 1, vector(m + 1, 0));\n    ```\n\n---\n\n### 1.2 方法函数\n\n知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。\n\n**c指定为数组名称**，含义中会注明算法复杂度。\n\n| 代码                           | 含义                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| `c.front()`                    | 返回第一个数据$O(1)$                                         |\n| `c.pop_back()`                 | 删除最后一个数据$O(1)$                                       |\n| `c.push_back(element)`         | 在尾部加一个数据$O(1)$                                       |\n| `c.size()`                     | 返回实际数据个数（unsigned类型）$O(1)$                       |\n| `c.clear()`                    | 清除元素个数$O(N)$，N为元素个数                              |\n| `c.resize(n, v)`               | 改变数组大小为`n`,`n`个空间数值赋为`v`，如果没有默认赋值为`0` |\n| `c.insert(it, x)`              | 向任意迭代器`it`插入一个元素`x` ，$O(N)$                     |\n| 例：`c.insert(c.begin()+2,-1)` | 将`-1`插入`c[2]`的位置                                       |\n| `c.erase(first,last)`          | 删除`[first,last)`的所有元素，$O(N)$                         |\n| `c.begin()`                    | 返回首元素的迭代器（通俗来说就是地址）$O(1)$                 |\n| `c.end()`                      | 返回最后一个元素后一个位置的迭代器（地址）$O(1)$             |\n| `c.empty()`                    | 判断是否为空，为空返回真，反之返回假 $O(1)$                  |\n\n注意： `end()`返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，**所有STL容器均是如此**\n\n**排序**\n\n使用`sort`排序要：  `sort(c.begin(), c.end());`\n\n> `sort()`为STL函数，请参考本文最后面STL函数系列。\n\n对所有元素进行排序，如果要对指定区间进行排序，可以对`sort()`里面的参数进行加减改动。\n\n```cpp\nvector<int> a(n + 1);\nsort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序\n```\n\n---\n\n### 1.3  访问\n\n- **下标法：** 和普通数组一样\n\n注意：一维数组的下标是从$0$到$v.size()-1$，访问之外的数会出现越界错误\n\n- **迭代器法：** 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。\n\n代码如下：\n\n```cpp\nvector<int> vi; //定义一个vi数组\nvector<int>::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置\n```\n\n#### 1.3.1 下标访问\n\n直接和普通数组一样进行访问即可。\n\n```cpp\n//添加元素\nfor(int i = 0; i < 5; i++)\n\tvi.push_back(i);\n\t\n//下标访问 \nfor(int i = 0; i < 5; i++)\n\tcout << vi[i] << \" \";\ncout << \"\\n\";\n```\n\n#### 1.3.2 迭代器访问\n\n类似指针。\n\n```cpp\n//迭代器访问\nvector<int>::iterator it;   \n//相当于声明了一个迭代器类型的变量it\n//通俗来说就是声明了一个指针变量\n\n//方式一：\nvector<int>::iterator it = vi.begin(); \nfor(int i = 0; i < 5; i++)\n\tcout << *(it + i) << \" \";\ncout << \"\\n\";\n\n//方式二：\nvector<int>::iterator it;\nfor(it = vi.begin(); it != vi.end();it ++)\n\tcout << *it << \" \";\n//vi.end()指向尾元素地址的下一个地址\n```\n\n#### 1.3.3 智能指针\n\n**只能遍历完数组**，如果要指定的内容进行遍历，需要另选方法。\n**auto** 能够自动识别并获取类型。\n\n```cpp\nvector<int> v;\nv.push_back(12);\nv.push_back(241);\nfor(auto val : v) \n\tcout << val << \" \"; // 12 241\n```\n\n> `vector`注意：\n>\n> - `vi[i]`  和  `*(vi.begin() + i)` 等价\n>\n> - `vector`和`string`的`STL`容器支持`*(it + i)`的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。\n\n---\n\n## 2 stack\n\n### 2.1 介绍\n\n栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。\n\n```cpp\n//头文件需要添加\n#include<stack>\n\n//声明\nstack<int> s;\nstack<string> s;\nstack<node> s;//node是结构体类型\n```\n\n### 2.2 方法函数\n\n| 代码          | 含义                            |\n| ------------- | ------------------------------- |\n| `s.push(ele)` | 元素`ele`入栈，增加元素  $O(1)$ |\n| `s.pop()`     | 移除栈顶元素 $O(1)$             |\n| `s.top()`     | 取得栈顶元素（但不删除）$O(1)$  |\n| `s.empty()`   | 检测栈内是否为空，空为真 $O(1)$ |\n| `s.size()`    | 返回栈内元素的个数 $O(1)$       |\n\n---\n\n### 2.3 栈遍历\n\n#### 2.3.1 栈遍历\n\n栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中\n\n#### 2.3.2 数组模拟栈进行遍历\n\n通过一个**数组**对栈进行模拟，一个存放下标的变量`top`模拟指向栈顶的指针。\n\n**特点：** 比`STL`的`stack`速度更快，遍历元素方便\n\n```cpp\nint s[100]; // 栈 从左至右为栈底到栈顶\nint tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1\n\nfor(int i = 0; i <= 5; i++)\n{\n\t//入栈 \n\ts[++tt] = i;\n}\n// 出栈\nint top_element = s[tt--]; \n\n//入栈操作示意\n//  0  1  2  3  4  5  \n//                tt\n//出栈后示意\n//  0  1  2  3  4 \n//              tt\n```\n\n---\n\n## 3 queue\n\n### 3.1 介绍\n\n队列是一种先进先出的数据结构。\n\n```cpp\n//头文件\n#include<queue>\n//定义初始化\nqueue<int> q;\n```\n\n### 3.2 方法函数\n\n| 代码              | 含义                                                |\n| ----------------- | --------------------------------------------------- |\n| `q.front()`       | 返回队首元素  $O(1)$                                |\n| `q.back()`        | 返回队尾元素 $O(1)$                                 |\n| `q.push(element)` | 尾部添加一个元素`element`  进队$O(1)$               |\n| `q.pop()`         | 删除第一个元素  出队 $O(1)$                         |\n| `q.size()`        | 返回队列中元素个数，返回值类型`unsigned int` $O(1)$ |\n| `q.empty()`       | 判断是否为空，队列为空，返回`true` $O(1)$           |\n\n### 3.3 队列模拟\n\n使用`q[]`数组模拟队列\n`hh`表示队首元素的下标，初始值为`0`\n`tt`表示队尾元素的下标，初始值为`-1`，表示刚**开始队列为空**\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\nint q[N];\n\nint main()\n{\n\tint hh = 0,tt = -1;\n//\t入队 \n\tq[++tt] = 1;\n\tq[++tt] = 2; \n//\t将所有元素出队 \n\twhile(hh <= tt)\n\t{\n\t\tint t = q[hh++];\n\t\tprintf(\"%d \",t);\n\t}\n\treturn 0;\n } \n```\n\n---\n\n## 4 deque\n\n### 4.1 介绍\n\n首尾都可插入和删除的队列为双端队列。\n\n```cpp\n//添加头文件\n#include<deque>\n//初始化定义\ndeque<int> dq;\n```\n\n### 4.2 方法函数\n\n| 代码                                  | 含义                                 |\n| ------------------------------------- | ------------------------------------ |\n| `push_back(x)/push_front(x)`          | 把`x`插入队尾后 / 队首 $O(1)$        |\n| `back()/front()`                      | 返回队尾 / 队首元素 $O(1)$           |\n| `pop_back() / pop_front()`            | 删除队尾 / 队首元素 $O(1)$           |\n| `erase(iterator it)`                  | 删除双端队列中的某一个元素           |\n| `erase(iterator first,iterator last)` | 删除双端队列中`[first,last)`中的元素 |\n| `empty()`                             | 判断deque是否空 $O(1)$               |\n| `size()`                              | 返回deque的元素数量 $O(1)$           |\n| `clear()`                             | 清空deque                            |\n\n### 4.3 注意点\n\ndeque可以进行排序\n\n```cpp\n//从小到大\nsort(q.begin(), q.end())\n//从大到小排序\nsort(q.begin(), q.end(), greater<int>());//deque里面的类型需要是int型\nsort(q.begin(), q.end(), greater());//高版本C++才可以用\n```\n\n---\n\n## 5. priority_queue\n\n### 5.1 介绍\n\n优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。\n\n可以实现每次从优先队列中取出的元素都是队列中**优先级最大**的一个。\n\n它的底层是通过**堆**来实现的。\n\n```cpp\n//头文件\n#include<queue>\n//初始化定义\npriority_queue<int> q;\n```\n\n### 5.2 函数方法\n\n| 代码                                                    | 含义                 |\n| ------------------------------------------------------- | -------------------- |\n| `q.top()`                                               | 访问队首元素         |\n| `q.push()`                                              | 入队                 |\n| `q.pop()`                                               | 堆顶（队首）元素出队 |\n| `q.size()`                                              | 队列元素个数         |\n| `q.empty()`                                             | 是否为空             |\n| **注意**没有`clear()`！                                 | 不提供该方法         |\n| 优先队列只能通过`top()`访问队首元素（优先级最高的元素） |                      |\n\n### 5.3 设置优先级\n\n#### 5.3.1 基本数据类型的优先级\n\n```cpp\npriority_queue<int> pq; // 默认大根堆, 即每次取出的元素是队列中的最大值\npriority_queue<int, vector<int>, greater<int> > q; // 小根堆, 每次取出的元素是队列中的最小值\n```\n\n**参数解释：**\n\n- **第二个参数：**\n  `vector< int >` 是用来承载底层数据结构堆的容器，若优先队列中存放的是`double`型数据，就要填`vector< double >`\n  **总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。**\n\n- **第三个参数：**\n  `less< int >`   表示数字大的优先级大，堆顶为最大的数字\n  `greater< int >`表示数字小的优先级大，堆顶为最小的数字\n  **int代表的是数据类型，也要填优先队列中存储的数据类型**\n\n下面介绍基础数据类型优先级设置的写法。\n\n**1. 基础写法（非常常用）**\n\n```cpp\npriority_queue<int> q1; // 默认大根堆, 即每次取出的元素是队列中的最大值\npriority_queue<int, vector<int>, less<int> > q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行\n\npriority_queue<int, vector<int>, greater<int> > q3; // 小根堆, 每次取出的元素是队列中的最小值\n```\n\n**2. 自定义排序（不常见，主要是写着麻烦）**\n\n下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。\n\n```cpp\nstruct cmp1\n{\n\tbool operator()(int x,int y)\n\t{\n\t\treturn x > y;\n\t}\n};\nstruct cmp2\n{\n\tbool operator()(const int x,const int y)\n\t{\n\t\treturn x < y;\n\t}\n};\npriority_queue<int, vector<int>, cmp1> q1; // 小根堆\npriority_queue<int, vector<int>, cmp2> q2; // 大根堆\n```\n\n---\n\n#### 5.3.2 结构体优先级设置\n\n> 即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。\n\n优先级设置可以定义在**结构体内**进行小于号重载，也可以定义在**结构体外**。\n\n```cpp\n//要排序的结构体（存储在优先队列里面的）\nstruct Point\n{\n\tint x,y;\n};\n```\n\n- **版本一：自定义全局比较规则**\n\n```cpp\n//定义的比较结构体\n//注意：cmp是个结构体 \nstruct cmp\n{//自定义堆的排序规则 \n\tbool operator()(const Point& a,const Point& b)\n\t{\n\t\treturn a.x < b.x;\n\t}\n};\n\n//初始化定义， \npriority_queue<Point, vector<Point>, cmp> q; // x大的在堆顶\n```\n\n\n- **版本二：直接在结构体里面写**\n\n> 因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。\n\n结构体内部有两种方式\n\n**方式一**\n\n```cpp\nstruct node\n{\n\tint x, y;\n\tfriend bool operator < (Point a, Point b)\n\t{//为两个结构体参数，结构体调用一定要写上friend\n\t\treturn a.x < b.x;//按x从小到大排，x大的在堆顶\n\t}\n};\n```\n\n**方式二**\n\n```cpp\nstruct node\n{\n    int x, y;\n    bool operator < (const Point &a) const\n    {//直接传入一个参数，不必要写friend\n        return x < a.x;//按x升序排列，x大的在堆顶\n    }\n};\n```\n\n优先队列的定义\n\n```cpp\npriority_queue<Point> q;\n```\n\n**注意：** 优先队列自定义排序规则和`sort()`函数定义`cmp`函数很相似，但是最后返回的情况是**相反**的。即相同的符号，最后定义的排列顺序是完全相反的。\n所以只需要记住`sort`的排序规则和优先队列的排序规则是相反的就可以了。\n\n---\n\n### 5.4 存储特殊类型的优先级\n\n#### 5.4.1 存储pair类型\n\n- 排序规则：\n  默认先对`pair`的`first`进行降序排序，然后再对`second`降序排序\n  对`first`先排序，大的排在前面，如果`first`元素相同，再对`second`元素排序，保持大的在前面。\n\n> `pair`请参考下文\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    priority_queue<pair<int, int> >q;\n\tq.push({7, 8});\n\tq.push({7, 9});\n\tq.push(make_pair(8, 7));\n    while(!q.empty())\n    {\n        cout << q.top().first << \" \" << q.top().second << \"\\n\";\n        q.pop();\n    }\n    return 0;\n}\n```\n\n>结果：\n>8 7\n>7 9\n>7 8\n\n---\n\n## 6. map\n\n### 6.1 介绍\n\n映射类似于函数的对应关系，每个`x`对应一个`y`，而`map`是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。\n\n>比如说：学习 对应 看书，学习 是键，看书 是值。\n>学习->看书\n>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。\n>玩耍->打游戏\n\n```cpp\n//头文件\n#include<map>\n//初始化定义\nmap<string,string> mp;\nmap<string,int> mp;\nmap<int,node> mp;//node是结构体类型\n```\n\n> map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n\n### 6.2 函数方法\n\n| 代码                   | 含义                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| `mp.find(key)`         | 返回键为key的映射的迭代器 $O(logN) $  注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$ |\n| `mp.erase(it)`         | 删除迭代器对应的键和值$O(1)$                                 |\n| `mp.erase(key)`        | 根据映射的键删除键和值 $O(logN)$                             |\n| `mp.erase(first,last)` | 删除左闭右开区间迭代器对应的键和值 $O(last-first)$           |\n| `mp.size()`            | 返回映射的对数$ O(1)$                                        |\n| `mp.clear()`           | 清空map中的所有元素$O(N)$                                    |\n| `mp.insert()`          | 插入元素，插入时要构造键值对                                 |\n| `mp.empty()`           | 如果map为空，返回true，否则返回false                         |\n| `mp.begin()`           | 返回指向map第一个元素的迭代器（地址）                        |\n| `mp.end()`             | 返回指向map尾部的迭代器（最后一个元素的**下一个**地址）      |\n| `mp.rbegin()`          | 返回指向map最后一个元素的迭代器（地址）                      |\n| `mp.rend()`            | 返回指向map第一个元素前面(上一个）的逆向迭代器（地址）       |\n| `mp.count(key)`        | 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 |\n| `mp.lower_bound()`     | 返回一个迭代器，指向键值>= **key**的第一个元素               |\n| `mp.upper_bound()`     | 返回一个迭代器，指向键值> key的第一个元素                    |\n\n**下面说明部分函数方法的注意点**\n\n>注意：\n>查找元素是否存在时，可以使用\n>①`mp.find()` ② `mp.count()` ③ `mp[key]`\n>但是第三种情况，如果不存在对应的`key`时，会自动创建一个键值对（产生一个额外的键值对空间）\n>所以为了不增加额外的空间负担，最好使用前两种方法\n\n---\n\n**使用迭代器进行正反向遍历：**\n\n `mp.begin()`和`mp.end()`用法：\n**用于正向遍历map**\n\n```cpp\nmap<int,int> mp;\nmp[1] = 2;\nmp[2] = 3;\nmp[3] = 4;\nauto it = mp.begin();\nwhile(it != mp.end())\n{\n\tcout << it->first << \" \" << it->second << \"\\n\";\n\tit ++;\n}\n```\n\n**结果：**\n\n```\n1 2\n2 3\n3 4\n```\n\n\n\n`mp.rbegin()`和`mp.rend()`\n**用于逆向遍历map**\n\n```cpp\nmap<int,int> mp;\nmp[1] = 2;\nmp[2] = 3;\nmp[3] = 4;\nauto it = mp.rbegin();\nwhile(it != mp.rend())\n{\n\tcout << it->first << \" \" << it->second << \"\\n\";\n\tit ++;\n}\n```\n\n**结果：**\n\n```\n3 4\n2 3\n1 2\n```\n\n---\n\n二分查找`lower_bound() upper_bound()`\n\n>map的二分查找以第一个元素（即键为准），对**键**进行二分查找\n>返回值为map迭代器类型\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tmap<int, int> m{{1, 2}, {2, 2}, {1, 2}, {8, 2}, {6, 2}};//有序\n\tmap<int, int>::iterator it1 = m.lower_bound(2);\n\tcout << it1->first << \"\\n\";//it1->first=2\n\tmap<int, int>::iterator it2 = m.upper_bound(2);\n\tcout << it2->first << \"\\n\";//it2->first=6\n\treturn 0;\n}\n\n```\n\n---\n\n###   6.3 添加元素\n\n```cpp\n//先声明\nmap<string,string> mp;\n```\n\n**方式一：**\n\n```cpp\nmp[\"学习\"] = \"看书\";\nmp[\"玩耍\"] = \"打游戏\";\n```\n\n**方式二：插入元素构造键值对**\n\n```cpp\nmp.insert(make_pair(\"vegetable\",\"蔬菜\"));\n```\n\n**方式三：**\n\n```cpp\nmp.insert(pair<string,string>(\"fruit\",\"水果\"));\n```\n\n**方式四:**\n\n```cpp\nmp.insert({\"hahaha\",\"wawawa\"});\n```\n\n---\n\n### 6.4 访问元素\n\n**6.4.1 下标访问：**(大部分情况用于访问单个元素)\n\n```cpp\nmp[\"菜哇菜\"] = \"强哇强\";\ncout << mp[\"菜哇菜\"] << \"\\n\";//只是简写的一个例子，程序并不完整\n```\n\n**6.4.2 遍历访问：**\n\n**方式一：迭代器访问**\n\n```cpp\nmap<string,string>::iterator it;\nfor(it = mp.begin(); it != mp.end(); it++)\n{\n\t//      键                 值 \n\t// it是结构体指针访问所以要用 -> 访问\n\tcout << it->first << \" \" << it->second << \"\\n\";\n\t//*it是结构体变量 访问要用 . 访问\n\t//cout<<(*it).first<<\" \"<<(*it).second;\n}\n```\n\n**方式二：智能指针访问**\n\n```cpp\nfor(auto i : mp)\ncout << i.first << \" \" << i.second << endl;//键，值\n```\n\n**方式三：对指定单个元素访问**\n\n```cpp\nmap<char,int>::iterator it = mp.find('a');\ncout << it -> first << \" \" <<  it->second << \"\\n\";\n```\n\n**方式四：c++17特性才具有**\n\n```cpp\nfor(auto [x, y] : mp)\n\tcout << x << \" \" << y << \"\\n\";\n//x,y对应键和值\n```\n\n### 6.5 与unordered_map的比较\n\n这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。\n\n#### 6.5.1 内部实现原理\n\n**map**：内部用**红黑树**实现，具有**自动排序**（按键从小到大）功能。\n\n**unordered_map**：内部用**哈希表**实现，内部元素无序杂乱。\n\n#### 6.5.2 效率比较\n\n**map**：\n\n- 优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$\n\n- 缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。\n\n**unordered_map**：\n\n- 优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。\n- 缺点：建立哈希表比较耗时。\n\n> 两者方法函数基本一样，差别不大。\n>\n> 注意：\n>\n> - 随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。\n>\n> - 使用`[]`查找元素时，如果元素不存在，两种容器**都是**创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会**大大降低**。\n>\n> - 查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）\n>\n>   ```cpp\n>   // 以 map 为例\n>   map<int, int> mp;\n>   int x = 999999999;\n>   if(mp.count(x)) // 此处判断是否存在x这个键\n>       cout << mp[x] << \"\\n\";   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建\n>   ```\n\n\n\n还有一种映射：\n\n[multimap]()\n键可以重复，即一个键对应多个值，如要了解，可以自行搜索。\n\n---\n\n## 7 set\n\n### 7.1 介绍\n\nset容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。\n\n即：set里面的元素**不重复 且有序**\n\n```cpp\n//头文件\n#include<set>\n//初始化定义\nset<int> s;\n```\n\n### 7.2 函数方法\n\n| 代码                   | 含义                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| `s.begin()`            | 返回set容器的第一个元素的地址（迭代器）$O(1)$                |\n| `s.end()`              | 返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$        |\n| `s.rbegin()`           | 返回逆序迭代器，指向容器元素最后一个位置$O(1)$               |\n| `s.rend()`             | 返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$           |\n| `s.clear()`            | 删除set容器中的所有的元素,返回unsigned int类型$O(N)$         |\n| `s.empty()`            | 判断set容器是否为空$O(1)$                                    |\n| `s.insert()`           | 插入一个元素                                                 |\n| `s.size()`             | 返回当前set容器中的元素个数$O(1)$                            |\n| `erase(iterator)`      | 删除定位器iterator指向的值                                   |\n| `erase(first,second）` | 删除定位器first和second之间的值                              |\n| `erase(key_value)`     | 删除键值key_value的值                                        |\n| 查找                   |                                                              |\n| `s.find(element)`      | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |\n| `s.count(element)`     | 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现 |\n| `s.lower_bound(k)`     | 返回大于等于k的第一个元素的迭代器$O(logN)$                   |\n| `s.upper_bound(k)`     | 返回大于k的第一个元素的迭代器$O(logN)$                       |\n\n---\n\n### 7.3 访问\n\n**迭代器访问**\n\n```cpp\nfor(set<int>::iterator it = s.begin(); it != s.end(); it++)\n\tcout << *it << \" \";\n```\n\n**智能指针**\n\n```cpp\nfor(auto i : s)\n\tcout << i << endl;\n```\n\n**访问最后一个元素**\n\n```cpp\n//第一种\ncout << *s.rbegin() << endl;\n```\n\n```cpp\n //第二种\nset<int>::iterator iter = s.end();\niter--;\ncout << (*iter) << endl; //打印2;\n```\n\n```cpp\n//第三种\ncout << *(--s.end()) << endl;\n```\n\n---\n\n### 7.4 重载<运算符\n\n- **基础数据类型**\n\n方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）\n\n```cpp\nset<int> s1; // 默认从小到大排序\nset<int, greater<int> > s2; // 从大到小排序\n```\n\n方式二：重载运算符。（很麻烦，不太常用，没必要）\n\n```cpp\n//重载 < 运算符\nstruct cmp {\n    bool operator () (const int& u, const int& v) const\n    {\n       // return + 返回条件\n       return u > v;\n    }\n};\nset<int, cmp> s; \n\nfor(int i = 1; i <= 10; i++)\n    s.insert(i);\nfor(auto i : s)\n    cout << i << \" \";\n// 10 9 8 7 6 5 4 3 2 1\n```\n\n方式三：初始化时使用匿名函数定义比较规则\n\n```cpp\nset<int, function<bool(int, int)>> s([&](int i, int j){\n    return i > j; // 从大到小\n});\nfor(int i = 1; i <= 10; i++)\n    s.insert(i);\nfor(auto x : s)\n    cout << x << \" \";\n```\n\n\n\n- **高级数据类型（结构体）**\n\n直接重载结构体运算符即可，让结构体可以比较。\n\n```cpp\nstruct Point\n{\n\tint x, y;\n\tbool operator < (const Point &p) const\n\t{\n\t\t// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大\n\t\tif(x == p.x)\n\t\t\treturn y < p.y;\n\t\treturn x < p.x;\n\t}\n};\n\nset<Point> s;\nfor(int i = 1; i <= 5; i++)\n{\n    int x, y;\n    cin >> x >> y;\n    s.insert({x, y});\n}\t\n/* 输入\n5 4\n5 2\n3 7\n3 5\n4 8\n*/\n\nfor(auto i : s)\n    cout << i.x << \" \" << i.y << \"\\n\";\n/* 输出\n3 5\n3 7\n4 8\n5 2\n5 4\n*/\n```\n\n\n\n### 7.5 其它set\n\n`multiset`:元素可以重复，且元素有序\n`unordered_set`  ：元素无序且只能出现一次\n`unordered_multiset` ：  元素无序可以出现多次\n\n---\n\n## 8 pair\n\n### 8.1 介绍\n\npair只含有两个元素，可以看作是只有两个元素的结构体。\n**应用：**\n\n- 代替二元结构体\n- 作为map键值对进行插入（代码如下）\n\n```cpp\nmap<string,int>mp;\nmp.insert(pair<string,int>(\"xingmaqi\",1));\n```\n\n```cpp\n//头文件\n#include<utility>\n\n//1.初始化定义\npair<string,int> p(\"wangyaqi\",1);//带初始值的\npair<string,int> p;//不带初始值的\n\n//2.赋值\np = {\"wang\",18};\n```\n\n### 8.2 访问\n\n```cpp\n//定义结构体数组\npair<int,int>p[20];\nfor(int i = 0; i < 20; i++)\n{\n\t//和结构体类似，first代表第一个元素，second代表第二个元素\n\tcout << p[i].first << \" \" << p[i].second;\n}\n```\n\n---\n\n## 9 string\n\n### 9.1 介绍\n\nstring是一个字符串类，和`char`型字符串类似。\n\n可以把string理解为一个字符串类型，像int一样可以定义\n\n### 9.2 初始化及定义\n\n\n```cpp\n//头文件\n#include<string>\n\n//1.\nstring str1; //生成空字符串\n\n//2.\nstring str2(\"123456789\"); //生成\"1234456789\"的复制品 \n\n//3.\nstring str3(\"12345\", 0, 3);//结果为\"123\" ，从0位置开始，长度为3\n\n//4.\nstring str4(\"123456\", 5); //结果为\"12345\" ，长度为5\n\n//5.\nstring str5(5, '2'); //结果为\"22222\" ,构造5个字符'2'连接而成的字符串\n\n//6.\nstring str6(str2, 2); //结果为\"3456789\"，截取第三个元素（2对应第三位）到最后\n\n```\n\n**简单使用**\n\n- 访问单个字符：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring s = \"xing ma qi!!!\";\n\tfor(int i = 0; i < s.size(); i++)\n\t\tcout << s[i] << \" \";\n\treturn 0;\n}\n```\n\n- string数组使用：\n\n```cpp\n#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring s[10];\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\ts[i] = \"loading...  \" ;\n\t\tcout << s[i] << i << \"\\n\";\n\t} \n\treturn 0;\n}\n```\n\n结果：\n\n```\nloading...  1\nloading...  2\nloading...  3\nloading...  4\nloading...  5\nloading...  6\nloading...  7\nloading...  8\nloading...  9\n```\n\n###  9.3 string 特性\n\n- 支持**比较**运算符\n  string字符串支持常见的比较操作符`（>,>=,<,<=,==,!=）`，支持`string`与`C-string`的比较（如 `str < \"hello\"`）。 \n  在使用`>,>=,<,<=`这些操作符的时候是根据“当前字符特性”将字符按 `字典顺序` 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。\n\n  同时，`string (\"aaaa\") <string(aaaaa)`。\n\n - 支持`+`**运算**符，代表拼接字符串\n   string字符串可以拼接，通过\"+\"运算符进行拼接。\n\n   ```cpp\n   string s1 = \"123\";\n   string s2 = \"456\";\n   string s = s1 + s2;\n   cout << s;   //123456\n   ```\n\n### 9.4 读入详解\n\n**读入字符串，遇空格，回车结束**\n\n```cpp\nstring s;\ncin >> s;\n```\n\n **读入一行字符串（包括空格），遇回车结束**\n\n```cpp\nstring s;\ngetline(cin, s);\n```\n\n注意: `getline(cin, s)`会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：`getchar()` 或` cin.get()`\n\n错误读取：\n\n```cpp\nint n;\nstring s;\ncin >> n;\ngetline(cin, s); //此时读取相当于读取了前一个回车字符\n```\n\n正确读取：\n\n```cpp\nint n;\nstring s;\ncin >> n;\ngetchar(); //cin.get()\ngetline(cin, s);//可正确读入下一行的输入\n```\n\n> `cin`与`cin.getline()`混用\n>\n> cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致`getline()`读取回车，结束。\n> 需要在cin后面加`cin.ignore()`；主动删除输入流中的换行符。（不常用）\n\n**cin和cout解锁**\n\n代码（写在main函数开头）：\n\n```cpp\nios::sync_with_stdio(false);\ncin.tie(0),cout.tie(0);\n```\n\n> 为什么要进行`cin`和`cout`的解锁，原因是：\n>\n> 在一些题目中，读入的**数据量很大**，往往超过了1e5（10^5^）的数据量,而`cin`和`cout`的读入输出的速度**很慢**（是因为`cin`和`cout`为了兼容C语言的读入输出在性能上做了妥协），远不如`scanf`和`printf`的速度，具体原因可以搜索相关的博客进行了解。\n>\n> **所以**对`cin`和`cout`进行解锁使`cin`和`cout`的速度几乎接近`scanf`和`printf`，避免输入输出超时。\n\n**注意**：`cin cout`解锁使用时，不能与 `scanf,getchar, printf,cin.getline()`混用，一定要注意，会出错。\n\n> **string与C语言字符串（C-string）的区别**\n>\n> - string\n>   是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为`string`，字符串结尾没有`\\0`字符\n> - C-string\n>   C语言中的字符串，用char数组实现，类型为`const char *`,字符串结尾以`\\0`结尾\n\n一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法`c_str()`实现string向char数组的转换。\n\n```cpp\nstring s = \"xing ma qi\";\nchar s2[] = s.c_str();\n```\n\n### 9.5 函数方法\n\n- **获取字符串长度**\n\n| 代码                     | 含义                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| `s.size()`和`s.length()` | 返回string对象的字符个数，他们执行效果相同。               |\n| `s.max_size()`           | 返回string对象最多包含的字符数，超出会抛出length_error异常 |\n| `s.capacity()`           | 重新分配内存之前，string对象能包含的最大字符数             |\n\n- **插入**\n\n\n| 代码                          | 含义                         |\n| ----------------------------- | ---------------------------- |\n| `s.push_back()`               | 在末尾插入                   |\n| 例：`s.push_back('a')`        | 末尾插入一个字符a            |\n| `s.insert(pos,element)`       | 在pos位置插入element         |\n| 例：`s.insert(s.begin(),'1')` | 在第一个位置插入1字符        |\n| `s.append(str)`               | 在s字符串结尾添加str字符串   |\n| 例：`s.append(\"abc\")`         | 在s字符串末尾添加字符串“abc” |\n\n\n- **删除**\n\n\n| 代码                                   | 含义                                           |\n| -------------------------------------- | ---------------------------------------------- |\n| `erase(iterator p)`                    | 删除字符串中p所指的字符                        |\n| `erase(iterator first, iterator last)` | 删除字符串中迭代器区间`[first,last)`上所有字符 |\n| `erase(pos,  len)`                     | 删除字符串中从索引位置pos开始的len个字符       |\n| `clear()`                              | 删除字符串中所有字符                           |\n\n\n- **字符替换**\n\n\n| 代码                     | 含义                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| `s.replace(pos,n,str)`   | 把当前字符串从索引pos开始的n个字符替换为str                  |\n| `s.replace(pos,n,n1,c)`  | 把当前字符串从索引pos开始的n个字符替换为n1个字符c            |\n| `s.replace(it1,it2,str)` | 把当前字符串`[it1,it2)`区间替换为str    **it1 ,it2为迭代器哦** |\n\n\n- **大小写转换** \n\n法一：\n\n| 代码            | 含义       |\n| --------------- | ---------- |\n| `tolower(s[i])` | 转换为小写 |\n| `toupper(s[i])` | 转换为大写 |\n\n法二：\n\n通过stl的transform算法配合tolower 和toupper 实现。\n有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。\n\n```cpp\nstring s;\ntransform(s.begin(),s.end(),s.begin(),::tolower);//转换小写\ntransform(s.begin(),s.end(),s.begin(),::toupper);//转换大写\n```\n\n\n- **分割**\n\n| 代码              | 含义                       |\n| ----------------- | -------------------------- |\n| `s.substr(pos,n)` | 截取从pos索引开始的n个字符 |\n\n\n- **查找**\n\n| 代码                             | 含义                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| `s.find (str,  pos)`             | 在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 |\n| `s.find (c, pos)`                | 在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符 |\n| `s.rfind (str, pos)`             | 在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串 |\n| `s.rfind (c,pos)`                | 在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_first_of (str, pos)`     | 在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_first_not_of (str,pos)`  | 在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_last_of(str, pos)`       | 在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 |\n| `s.find_last_not_of ( str, pos)` | 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串 |\n\n\n\n```cpp\n#include<string>\n#include<iostream>\nint main()\n{\n    string s(\"dog bird chicken bird cat\");\n//字符串查找-----找到后返回首字母在字符串中的下标\n// 1. 查找一个字符串\n    cout << s.find(\"chicken\") << endl;// 结果是：9\n    \n// 2. 从下标为6开始找字符'i'，返回找到的第一个i的下标\n    cout << s.find('i',6) << endl;// 结果是：11\n    \n// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标\n    cout << s.rfind(\"chicken\") << endl;// 结果是：9\n    \n// 4. 从字符串的末尾开始查找字符\n    cout << s.rfind('i') << endl;// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符\n    \n// 5. 在该字符串中查找第一个属于字符串s的字符\n    cout << s.find_first_of(\"13br98\") << endl;// 结果是：4---b\n    \n// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4\n    cout << s.find_first_not_of(\"hello dog 2006\") << endl; // 结果是：4\n    cout << s.find_first_not_of(\"dog bird 2006\") << endl;  // 结果是：9\n    \n// 7. 在该字符串最后中查找第一个属于字符串s的字符\n    cout << s.find_last_of(\"13r98\") << endl;// 结果是：19\n\n// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21\n    cout << s.find_last_not_of(\"teac\") << endl;// 结果是：21\n}\n```\n\n- **排序**\n\n```cpp\nsort(s.begin(),s.end());  //按ASCII码排序\n```\n\n---\n\n## 10 bitset\n\n### 10.1 介绍\n\nbitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间\n\n```cpp\n//头文件\n#include<bitset>\n```\n\n### 10.2 初始化定义\n\n初始化方法\n\n| 代码                     | 含义                             |\n| ------------------------ | -------------------------------- |\n| `bitset < n >a`          | a有n位，每位都为0                |\n| `bitset < n >a(b)`       | a是unsigned long型u的一个副本    |\n| `bitset < n >a(s)`       | a是string对象s中含有的位串的副本 |\n| `bitset < n >a(s,pos,n)` | a是s中从位置pos开始的n个位的副本 |\n\n> 注意：`n`必须为常量表达式\n\n演示代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tbitset<4> bitset1;　　  //无参构造，长度为４，默认每一位为０\n\t\n\tbitset<9> bitset2(12);　//长度为9，二进制保存，前面用０补充\n\t\n\tstring s = \"100101\";\n\tbitset<10> bitset3(s);　　//长度为10，前面用０补充\n\t\n\tchar s2[] = \"10101\";\n\tbitset<13> bitset4(s2);　　//长度为13，前面用０补充\n\t\n\tcout << bitset1 << endl;　　//0000\n\tcout << bitset2 << endl;　　//000001100\n\tcout << bitset3 << endl;　　//0000100101\n\tcout << bitset4 << endl;　//0000000010101\n\treturn 0;\n}\n```\n\n---\n\n### 10.3 特性\n\n`bitset`可以进行**位操作**\n\n```cpp\nbitset<4> foo (string(\"1001\"));\nbitset<4> bar (string(\"0011\"));\n\ncout << (foo ^= bar) << endl;// 1010 (foo对bar按位异或后赋值给foo)\n\ncout << (foo &= bar) << endl;// 0010 (按位与后赋值给foo)\n\ncout << (foo |= bar) << endl;// 0011 (按位或后赋值给foo)\n\ncout << (foo <<= 2) << endl;// 1100 (左移２位，低位补０，有自身赋值)\n\ncout << (foo >>= 1) << endl;// 0110 (右移１位，高位补０，有自身赋值)\n\ncout << (~bar) << endl;// 1100 (按位取反)\n\ncout << (bar << 1) << endl;// 0110 (左移，不赋值)\n\ncout << (bar >> 1) << endl;// 0001 (右移，不赋值)\n\ncout << (foo == bar) << endl;// false (0110==0011为false)\n\ncout << (foo != bar) << endl;// true  (0110!=0011为true)\n\ncout << (foo & bar) << endl;// 0010 (按位与，不赋值)\n\ncout << (foo | bar) << endl;// 0111 (按位或，不赋值)\n\ncout << (foo ^ bar) << endl;// 0101 (按位异或，不赋值)\n```\n\n**访问**\n\n```cpp\n//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：\nbitset<4> foo (\"1011\"); \n\ncout << foo[0] << endl;　　//1\ncout << foo[1] << endl;　　//1\ncout << foo[2] << endl;　　//0\n```\n\n---\n\n### 10.4 方法函数\n\n|      代码      |                    含义                    |\n| :------------: | :----------------------------------------: |\n|   `b.any()`    |  b中是否存在置为1的二进制位，有 返回true   |\n|   `b.none()`   |        b中是否没有1，没有 返回true         |\n|  `b.count()`   |                b中为1的个数                |\n|   `b.size()`   |             b中二进制位的个数              |\n| `b.test(pos)`  |     测试b在pos位置是否为1，是 返回true     |\n|    `b[pos]`    |           返回b在pos处的二进制位           |\n|   `b.set()`    |             把b中所有位都置为1             |\n|  `b.set(pos)`  |             把b中pos位置置为1              |\n|  `b.reset()`   |             把b中所有位都置为0             |\n| `b.reset(pos)` |             把b中pos位置置为0              |\n|   `b.flip()`   |           把b中所有二进制位取反            |\n| `b.flip(pos)`  |              把b中pos位置取反              |\n| `b.to_ulong()` | 用b中同样的二进制位返回一个unsigned long值 |\n\n---\n\n## 11 array\n\n### 11.1 介绍\n\n头文件\n\n```cpp\n#include<array>\n```\n\n`array`是C++11新增的容器，效率与普通数据相差无几，比`vector`效率要高，自身添加了一些成员函数。\n\n和其它容器不同，array 容器的大小是**固定**的，无法动态的扩展或收缩，**只允许访问或者替换存储的元素。**\n\n**注意：**\n\n`array`的使用要在`std`命名空间里\n\n### 11.2 声明与初始化\n\n**基础数据类型**\n\n声明一个大小为100的`int`型数组，元素的值不确定\n\n```cpp\narray<int, 100> a;\n```\n\n声明一个大小为100的`int`型数组，初始值均为`0`(初始值与默认元素类型等效)\n\n```cpp\narray<int, 100> a{};\n```\n\n声明一个大小为100的`int`型数组，初始化部分值，其余全部为`0`\n\n```cpp\narray<int, 100> a{1, 2, 3};\n```\n\n或者可以用等号\n\n```cpp\narray<int, 100> a = {1, 2, 3};\n```\n\n**高级数据类型**\n\n不同于数组的是对元素类型不做要求，可以套结构体\n\n```cpp\narray<string, 2> s = {\"ha\", string(\"haha\")};\narray<node, 2> a;\n```\n\n---\n\n### 11.3 存取元素\n\n- 修改元素\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\na[0] = 4;\n```\n\n- 访问元素\n\n下标访问\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\nfor(int i = 0; i < 4; i++) \n    cout << a[i] << \" \\n\"[i == 3];\n```\n\n利用`auto`访问\n\n```cpp\nfor(auto i : a)\n    cout << i << \" \";\n```\n\n迭代器访问\n\n```cpp\nauto it = a.begin();\nfor(; it != a.end(); it++) \n    cout << *it << \" \";\n```\n\n `at()`函数访问\n\n下标为`1`的元素加上下标为`2`的元素，答案为`5`\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\nint res = a.at(1) + a.at(2);\ncout << res << \"\\n\";\n```\n\n `get`方法访问\n\n将`a`数组下标为`1`位置处的值改为`x`\n\n注意：获取的下标只能写数字，不能填变量\n\n```cpp\nget<1>(a) = x;\n```\n\n---\n\n### 11.4 成员函数\n\n\n\n| 成员函数              | 功能                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| `begin()`             | 返回容器中第一个元素的访问迭代器（地址）                     |\n| `end()`               | 返回容器最后一个元素之后一个位置的访问迭代器（地址）         |\n| `rbegin()`            | 返回最后一个元素的访问迭代器（地址）                         |\n| `rend()`              | 返回第一个元素之前一个位置的访问迭代器（地址）               |\n| `size()`              | 返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数`N` |\n| `max_size()`          | 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N |\n| `empty()`             | 判断容器是否为空                                             |\n| `at(n)`               | 返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常 |\n| `front()`             | 返回容器中第一个元素的直接引用，函数不适用于空的 array 容器  |\n| `back()`              | 返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。 |\n| `data()`              | 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能 |\n| `fill(x)`             | 将 `x` 这个值赋值给容器中的每个元素,相当于初始化             |\n| `array1.swap(array2)` | 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型 |\n\n---\n\n### 11.5 部分用法示例\n\n`data()`\n\n指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。\n\n`at()`\n\n下标为`1`的元素加上下标为`2`的元素，答案为`5`\n\n```cpp\narray<int, 4> a = {1, 2, 3, 4};\nint res = a.at(1) + a.at(2);\ncout << res << \"\\n\";\n```\n\n`fill()`\n\narray的`fill()`函数，将`a`数组全部元素值变为`x`\n\n```cpp\na.fill(x);\n```\n\n另外还有其它的`fill()`函数:将`a`数组$[begin,end)$全部值变为`x`\n\n```cpp\nfill(a.begin(), a.end(), x);\n```\n\n**get方法获取元素值**\n\n将`a`数组下标为`1`位置处的值改为`x`\n\n注意:获取的下标只能写数字，不能填变量\n\n```cpp\nget<1>(a) = x;\n```\n\n**排序**\n\n```cpp\nsort(a.begin(), a.end());\n```\n\n---\n\n## 12 tuple\n\n### 12.1 介绍 \n\ntuple模板是pair的泛化，可以封装不同类型任意数量的对象。\n\n可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。\n\ntuple可以等价为**结构体**使用\n\n**头文件**\n\n```cpp\n#include <tuple>\n```\n\n###  12.2 声明初始化\n\n声明一个空的`tuple`三元组\n\n```cpp\ntuple<int, int, string> t1;\n```\n\n赋值\n\n```cpp\nt1 = make_tuple(1, 1, \"hahaha\");\n```\n\n创建的同时初始化\n\n```cpp\ntuple<int, int, int, int> t2(1, 2, 3, 4);\n```\n\n可以使用pair对象构造tuple对象，但tuple对象必须是两个元素\n\n```cpp\nauto p = make_pair(\"wang\", 1);\ntuple<string, int> t3 {p}; //将pair对象赋给tuple对象\n```\n\n### 12.3 元素操作\n\n获取tuple对象`t`的第一个元素\n\n```cpp\nint first = get<0>(t);\n```\n\n修改tuple对象`t`的第一个元素\n\n```cpp\nget<0>(t) = 1;\n```\n\n\n\n### 12.4 函数操作\n\n- 获取元素个数\n\n```cpp\ntuple<int, int, int> t(1, 2, 3);\ncout << tuple_size<decltype(t)>::value << \"\\n\"; // 3\n```\n\n- 获取对应元素的值\n\n通过`get<n>(obj)`方法获取,`n`必须为数字不能是变量\n\n```cpp\ntuple<int, int, int> t(1, 2, 3);\ncout << get<0>(t) << '\\n'; // 1\ncout << get<1>(t) << '\\n'; // 2\ncout << get<2>(t) << '\\n'; // 3\n```\n\n- 通过`tie`解包 获取元素值\n\n`tie`可以让tuple变量中的三个值依次赋到tie中的三个变量中\n\n```cpp\nint one, three;\nstring two; \ntuple<int, string, int> t(1, \"hahaha\", 3);\ntie(one, two, three) = t;\ncout << one << two << three << \"\\n\"; // 1hahaha3\n```\n\n---\n\n# STL函数\n\n## accumulate\n\n```\naccumulate(beg, end, init)\n```\n\n**复杂度：** $O(N)$\n\n> 作用：对一个序列的元素求和\n\n`init`为对序列元素求和的**初始值**\n\n返回值类型：与`init`\n\n- **基础累加求和：**\n\n```cpp\nint a[]={1,3,5,9,10};\n\n//对[0,2]区间求和，初始值为0，结果为0+1+3+5=9\nint res1 = accumulate(a, a + 3, 0);\n\n//对[0,3]区间求和，初始值为5，结果为5+1+3+5+9=23\nint res2 = accumulate(a, a + 4, 5);\n```\n\n- **自定义二元对象求和：**\n\n使用**lamda表达式**\n\n```cpp\ntypedef long long ll;\nstruct node\n{\n    ll num;\n}st[10];\n\nfor(int i = 1; i <= n; i++)\n    st[i].num = i + 10000000000;\n//返回值类型与init一致，同时注意参数类型（a）也要一样\n//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007\nll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b){\n    return a + b.num;\n});\n    \n```\n\n## atoi\n\n```\natoi(const char *)\n```\n\n> 将字符串转换为`int`类型\n\n注意参数为`char`型数组，如果需要将string类型转换为int类型，可以使用`stoi`函数（参考下文），或者将`string`类型转换为`const char *`类型。\n\n关于输出数字的范围：\n`atoi`**不做**范围检查，如果超出上界，输出上界，超出下界，输出下界。\n`stoi`**会做**范围检查，默认必须在`int`范围内，如果超出范围，会出现RE（Runtime Error）错误。\n\n```cpp\nstring s = \"1234\";\nint a = atoi(s.c_str());\ncout << a << \"\\n\"; // 1234\n```\n或者\n```cpp\nchar s[] = \"1234\";\nint a = atoi(s);\ncout << a << \"\\n\";\n```\n\n## fill\n\n```\nfill(beg,end,num)\n```\n\n**复杂度：** $O(N)$\n\n> 对一个序列进行初始化赋值\n\n```cpp\n//对a数组的所有元素赋1\nint a[5];\nfill(a,a+5,1);\nfor(int i=0;i<5;i++)\n    cout<<a[i]<<\" \";\n//1 1 1 1 1\n```\n\n注意区分memset：\n\n`memset()`是按**字节**进行赋值，对于初始化赋`0`或`-1`有比较好的效果.\n\n如果赋某个特定的数会**出错**，赋值特定的数建议使用`fill()`\n\n\n\n## is_sorted\n\n```\nis_sorted(beg,end)\n```\n\n**复杂度：** $O(N)$\n\n> 判断序列是否有序（升序），返回`bool`值\n\n```cpp\n//如果序列有序，输出YES\nif(is_sorted(a,a+n))\n    cout<<\"YES\\n\";\n```\n\n## iota\n\n```\niota(beg, end)\n```\n\n> 让序列递增赋值\n\n```cpp\nvector<int> a(10);\niota(a.begin(), a.end(), 0);\nfor(auto i : a)\n\tcout << i << \" \";\n// 0 1 2 3 4 5 6 7 8 9\n```\n\n## lower_bound + upper_bound\n\n**复杂度：** $O(logN)$\n\n> 作用：二分查找\n\n```cpp\n//在a数组中查找第一个大于等于x的元素，返回该元素的地址\nlower_bound(a, a + n, x);\n//在a数组中查找第一个大于x的元素，返回该元素的地址\nupper_bound(a, a + n, x);\n\n//如果未找到，返回尾地址的下一个位置的地址\n```\n\n##  max_element+min_element\n\n**复杂度：** $O(N)$\n\n> 找最大最小值\n\n```cpp\n//函数都是返回地址，需要加*取值\nint mx = *max_element(a, a + n);\nint mn = *min_element(a, a + n);\n```\n\n##  max+min\n\n**复杂度：** $O(1)$\n\n> 找多个元素的最大值和最小值\n\n```cpp\n//找a，b的最大值和最小值\nmx = max(a, b);\nmn = min(a, b);\n```\n\n```cpp\n//找到a,b,c,d的最大值和最小值\nmx = max({a, b, c, d});\nmn = min({a, b, c, d});\n```\n\n## minmax\n\n```\nminmax(a, b)\n```\n\n**复杂度：** $O(1)$\n\n> 返回一个`pair`类型，第一个元素是`min(a, b)`， 第二个元素是`max(a, b)`\n\n```cpp\npair<int, int> t = minmax(4, 2);\n// t.first = 2, t.second = 4\n```\n\n## minmax_element\n\n```\nminmax_element(beg, end)\n```\n\n**复杂度：** $O(N)$\n\n> 返回序列中的最小和最大值组成pair的对应的地址，返回类型为`pair<vector<int>::iterator, vector<int>::iterator>`\n\n```cpp\nint n = 10;\nvector<int> a(n);\niota(a.begin(), a.end(), 1);\nauto t = minmax_element(a.begin(), a.end()); // 返回的是最小值和最大值对应的地址\n// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针\n```\n\n\n\n## nth_element\n\n```\nnth_element(beg, nth, end)\n```\n\n**复杂度：** 平均$O(N)$\n\n> 寻找第序列第n小的值\n\n`nth`为一个迭代器，指向序列中的一个元素。第n小的值恰好在`nth`位置上。\n\n执行`nth_element()`之后，序列中的元素会围绕nth进行划分：**nth之前的元素都小于等于它，而之后的元素都大于等于它**\n\n**实例：求序列中的第3小的元素**\n\n```cpp\nnth_element(a, a + 2, a + n);\ncout << a[2] << '\\n';\n```\n\n\n\n## next_permutation\n\n```\nnext_permutation(beg, end)\n```\n\n**复杂度：** $O(N)$\n\n> 求序列的下一个排列，下一个排列是字典序大一号的排列\n\n返回`true`或`false`\n\n- `next_permutation(beg,end)`\n\n  如果是最后一个排列，返回`false`,否则求出下一个序列后，返回`true`\n\n```cpp\n//对a序列进行重排\nnext_permutation(a, a + n);\n```\n\n**应用：求所有的排列**\n\n输出`a`的所有排列\n\n```cpp\n//数组a不一定是最小字典序序列，所以将它排序\nsort(a, a + n);\ndo\n{\n \tfor(int i = 0; i < n; i++)\n        printf(\"%d \", a[i]);\n}while(next_permutation(a, a + n));\n```\n\n-  `prev_permutation(beg,end)`\n\n> 求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false\n\n## partial_sort\n\n```\npartial_sort(beg, mid, end)\n```\n\n**复杂度：** 大概$O(N logM)$ `M`为距离\n\n> 部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置\n>\n> 从beg到mid**前**的元素都排好序\n\n对a数组前5个元素排序按从小到大排序\n\n```cpp\nint a[] = {1,2,5,4,7,9,8,10,6,3};\npartial_sort(a, a + 5, a + 10);\nfor(int i = 0; i < 10; i++) \n    cout << a[i] << ' ';\n//1 2 3 4 5 9 8 10 7 6\n//前五个元素都有序\n```\n\n也可以添加自定义排序规则：\n\n `partial_sort(beg,mid,end,cmp)`\n\n对a的前五个元素都是降序排列\n\n```cpp\nint a[] = {1,2,5,4,7,9,8,10,6,3};\npartial_sort(a, a + 5, a + 10, greater<int>());\nfor(int i = 0; i < 10; i++) \n    cout << a[i] << ' ';\n//10 9 8 7 6 1 2 4 5 3\n//前五个元素降序有序\n```\n\n## random_shuffle\n\n**复杂度：** $O(N)$\n\n> 1. 随机打乱序列的顺序\n> 2. 在 `C++14` 中被弃用，在 `C++17` 中被废除，C++11之后应尽量使用`shuffle`来代替。\n\n```cpp\nvector<int> b(n);\niota(b.begin(), b.end(), 1);// 序列b递增赋值 1, 2, 3, 4,...\n//对a数组随机重排\nrandom_shuffle(a, a + n);\n// C++11之后尽量使用shuffle\nshuffle(b.begin(), b.end());\n```\n\n##  reverse\n\n```\nreverse(beg,end)\n```\n\n**复杂度：** $O(N)$\n\n> 对序列进行翻转\n\n```cpp\nstring s = \"abcde\";\nreverse(s.begin(), s.end());//对s进行翻转\ncout << s << '\\n';//edcba\n\n//对a数组进行翻转\nint a[] = {1, 2, 3, 4};\nreverse(a, a + 4);\ncout << a[0] << a[1] << a[2] << a[3];//4321\n```\n\n##  sort\n\n**复杂度：** $O(N logN)$\n\n> 作用：对一个序列进行排序\n\n```cpp\n//原型：\nsort(beg, end);\nsort(beg, end, cmp);\n```\n\n```cpp\n//对a数组的[1,n]位置进行从小到大排序\nsort(a + 1, a + 1 + n);\n\n//对a数组的[0,n-1]位置从大到小排序\nsort(a, a + n, greater<int>());\n//对a数组的[0,n-1]位置从小到大排序\nsort(a, a + n, less<int>());\n\n//自定义排序，定义比较函数\nbool cmp(node a,node b)\n{\n    //按结构体里面的x值降序排列\n    return a.x > b.x;\n}\nsort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则\n```\n\n##  stable_sort\n\n**复杂度：** $O(N logN)$\n\n> 功能和sort()基本一样\n>\n> 区别在于`stable_sort()`能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置\n\n使用用法和`sort()`一样,见上\n\n## stoi\n\n```\nstoi(const string*)\n```\n\n> 将对应string类型字符串转换为数字\n\n注意参数为`string`字符串类型。\n\n关于输出数字的范围：\n`stoi`**会做**范围检查，默认必须在`int`范围内，如果超出范围，会出现RE（Runtime Error）错误。\n`atoi`**不做**范围检查，如果超出上界，输出上界，超出下界，输出下界。\n\n\n```cpp\nstring s = \"1234\";\nint a = atoi(s);\ncout << a << \"\\n\"; // 1234\n```\n\n## transform\n\n**复杂度：** $O(N)$\n\n> 作用：使用给定操作，将结果写到dest中\n\n```cpp\n//原型：\ntransform(beg, end, dest, unaryOp);\n```\n\n\n\n```cpp\n//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中\ntransform(beg, end, dest, ::tolower);\ntransform(beg, end, dest, ::toupper);\n```\n\n\n\n##  to_string\n\n> 将数字转化为字符串,支持小数（double）\n\n```cpp\nint a = 12345678;\ncout << to_string(a) << '\\n';\n```\n\n\n\n## unique\n\n```\nunique(beg, end)\n```\n\n\n\n**复杂度：** $O(N)$\n\n> 消除重复元素，返回消除完重复元素的下一个位置的地址\n>\n> 如：`a[] = {1,2,3,3,4 }`;\n>\n> unique之后a数组为`{1,2,3,4,3}`前面为无重复元素的数组，后面则是重复元素移到后面，返回`a[4]`位置的地址（不重复元素的尾后地址）\n\n消除重复元素一般需要原序列是**有序序列**\n\n**运用：离散化**\n\n```cpp\nfor(int i = 0; i < n; i++)\n{\n    cin >> a[i];\n    b[i] = a[i];//将a数组复制到b数组\n}\nsort(b, b + n);//对b数组排序\nunique(b, b + n);//消除b重复元素\nfor(int i = 0; i < n; i++)\n{\n    //因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）\n    int pos = lower_bound(b, b + n, a[i]) - b;//在b数组中二分查找第一个大于等于a[i]的下标\n    a[i] = pos;//赋值\n}\n```\n\n##  __gcd\n\n```\n__gcd(a,b)\n```\n\n> 求a和b的最大公约数\n\n`__gcd(12,15) = 3`\n\n`__gcd(21,0) = 21`\n\n## __lg\n\n```\n__lg(a)\n```\n\n\n\n> 1. 求一个数二进制下最高位位于第几位（从**第0位**开始）（或二进制数下有几位）\n> 2. `__lg(x)`相当于返回$\\lfloor log_2 x \\rfloor$\n> 3. 复杂度$O(1)$\n\n`__lg(8) = 3`\n\n`__lg(15) = 3`\n\n\n\n## __builtin_ 内置位运算函数\n\n内置函数有相应的`unsigned lnt`和`unsigned long long`版本，`unsigned long long`只需要在函数名后面加上`ll`就可以了，比如`__builtin_clzll(x)`,默认是32位`unsigned int`\n\n### __builtin_ffs\n\n```\n__builtin_ffs(x)\n```\n\n>二进制中对应最后一位`1`的位数，比如`4`会返回`3`（100）\n\n### __builtin_popcount\n\n```\n__builtin_popcount(x)\n```\n\n>`x`中`1`的个数\n\n### __builtin_ctz\n\n```\n__builtin_ctz(x)\n```\n\n> `x`末尾`0`的个数（`count tail zero`）\n\n### __builtin_clz\n\n```\n__builtin_clz(x)\n```\n\n> `x`前导`0`的个数（`count leading zero`）\n\n```cpp\ncout << __builtin_clz(32); // 26\n//因为共有6位,默认数据范围为32位，32 - 6 = 26\n```\n\n### __builtin_parity\n\n```\n__builtin_parity(x)\n```\n\n> `x`中1的个数的奇偶性， 奇数输出`1`，偶数输出`0`\n\n\n\n> 可参考链接：\n>\n> 1. [C++语法糖](https://www.luogu.com.cn/blog/AccRobin/grammar-candies) https://www.luogu.com.cn/blog/AccRobin/grammar-candies\n\n可能有些人需要PDF文件，公众号【行码棋】回复 STL 获取，抱歉😭\n\n![](https://wyqz.top/medias/gzh.jpg)\n","slug":"C-STL超全总结汇总版","published":1,"updated":"2023-01-19T08:36:19.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolht001r6kuhhm1bkcx1","content":"<h1 id=\"C-STL-总结-基于算法竞赛（悠享版）\"><a href=\"#C-STL-总结-基于算法竞赛（悠享版）\" class=\"headerlink\" title=\"C++ STL 总结-基于算法竞赛（悠享版）\"></a>C++ STL 总结-基于算法竞赛（悠享版）</h1><p>本文介绍常用STL知识，注重应用，强调用法，不强调原理和繁杂的记忆。看过之后请多运用，多敲代码试。</p>\n<blockquote>\n<p>费尽心思重新梳理了一下，注意了些美观性，修改了部分错误，添加了部分解释，编写过程非常难。</p>\n</blockquote>\n<p>另外C++版本一定要对，C++11即可，C++17或20更好。</p>\n<blockquote>\n<p>实践才是检验真理的唯一标准！</p>\n</blockquote>\n<p>CSDN版本：<a href=\"https://wyq666.blog.csdn.net/article/details/114026148\" target=\"_blank\" rel=\"noopener\">https://wyq666.blog.csdn.net/article/details/114026148</a></p>\n<h2 id=\"1-vector\"><a href=\"#1-vector\" class=\"headerlink\" title=\"1 vector\"></a>1 vector</h2><h3 id=\"1-1-介绍\"><a href=\"#1-1-介绍\" class=\"headerlink\" title=\"1.1 介绍\"></a>1.1 介绍</h3><p><code>vector</code>为可变长数组（动态数组），定义的<code>vector</code>数组可以随时添加数值和删除元素。</p>\n<blockquote>\n<p>注意：<strong>在局部区域中（比如局部函数里面）开vector数组，是在堆空间里面开的。</strong> </p>\n<p>在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p>\n<p>故局部区域<strong>不可以</strong>开大长度数组，但是可以开大长度<code>vector</code>。</p>\n</blockquote>\n<ul>\n<li>头文件</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;vector></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li><p>初始化</p>\n<ul>\n<li><p>一维初始化</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//定义了一个名为a的一维数组,数组存储int类型数据</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">double</span><span class=\"token operator\">></span> b<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//定义了一个名为b的一维数组，数组存储double类型数据</span>\nvector<span class=\"token operator\">&lt;</span>node<span class=\"token operator\">></span> c<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>指定<strong>长度</strong>和<strong>初始值</strong>的初始化</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">v</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">v</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//v[0]到v[n-1]所有的元素初始值均为1</span>\n<span class=\"token comment\" spellcheck=\"true\">//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>初始化中有多个元素</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//数组a中有五个元素，数组长度就为5</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>拷贝初始化</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>二维初始化<br>定义第一维固定长度为<code>5</code>，第二维可变化的二维数组</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//定义可变长二维数组</span>\n<span class=\"token comment\" spellcheck=\"true\">//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素</span>\n<span class=\"token comment\" spellcheck=\"true\">//第一维固定长度为5，第二维长度可以改变</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p><code>vector&lt;int&gt; v[5]</code>可以这样理解：长度为5的v数组，数组中存储的是<code>vector&lt;int&gt;</code>数据类型，而该类型就是数组形式，故<code>v</code>为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">v<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</blockquote>\n<p>行列均可变</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//初始化二维均可变长数组</span>\nvector<span class=\"token operator\">&lt;</span>vectot<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> v<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//定义一个行和列均可变的二维数组</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<blockquote>\n<p>应用：可以在<code>v</code>数组里面装多个数组</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> t1<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> t2<span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<p>行列长度均固定 <code>n + 1</code>行 <code>m + 1</code>列初始值为0</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>c++17或者c++20支持的形式（不常用），与上面相同的初始化</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vector</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"1-2-方法函数\"><a href=\"#1-2-方法函数\" class=\"headerlink\" title=\"1.2 方法函数\"></a>1.2 方法函数</h3><p>知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。</p>\n<p><strong>c指定为数组名称</strong>，含义中会注明算法复杂度。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>c.front()</code></td>\n<td>返回第一个数据$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.pop_back()</code></td>\n<td>删除最后一个数据$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.push_back(element)</code></td>\n<td>在尾部加一个数据$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.size()</code></td>\n<td>返回实际数据个数（unsigned类型）$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.clear()</code></td>\n<td>清除元素个数$O(N)$，N为元素个数</td>\n</tr>\n<tr>\n<td><code>c.resize(n, v)</code></td>\n<td>改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td>\n</tr>\n<tr>\n<td><code>c.insert(it, x)</code></td>\n<td>向任意迭代器<code>it</code>插入一个元素<code>x</code> ，$O(N)$</td>\n</tr>\n<tr>\n<td>例：<code>c.insert(c.begin()+2,-1)</code></td>\n<td>将<code>-1</code>插入<code>c[2]</code>的位置</td>\n</tr>\n<tr>\n<td><code>c.erase(first,last)</code></td>\n<td>删除<code>[first,last)</code>的所有元素，$O(N)$</td>\n</tr>\n<tr>\n<td><code>c.begin()</code></td>\n<td>返回首元素的迭代器（通俗来说就是地址）$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.end()</code></td>\n<td>返回最后一个元素后一个位置的迭代器（地址）$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.empty()</code></td>\n<td>判断是否为空，为空返回真，反之返回假 $O(1)$</td>\n</tr>\n</tbody></table>\n<p>注意： <code>end()</code>返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有STL容器均是如此</strong></p>\n<p><strong>排序</strong></p>\n<p>使用<code>sort</code>排序要：  <code>sort(c.begin(), c.end());</code></p>\n<blockquote>\n<p><code>sort()</code>为STL函数，请参考本文最后面STL函数系列。</p>\n</blockquote>\n<p>对所有元素进行排序，如果要对指定区间进行排序，可以对<code>sort()</code>里面的参数进行加减改动。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 对[1, n]区间进行从小到大排序</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<h3 id=\"1-3-访问\"><a href=\"#1-3-访问\" class=\"headerlink\" title=\"1.3  访问\"></a>1.3  访问</h3><ul>\n<li><strong>下标法：</strong> 和普通数组一样</li>\n</ul>\n<p>注意：一维数组的下标是从$0$到$v.size()-1$，访问之外的数会出现越界错误</p>\n<ul>\n<li><strong>迭代器法：</strong> 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> vi<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//定义一个vi数组</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it <span class=\"token operator\">=</span> vi<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//声明一个迭代器指向vi的初始位置</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"1-3-1-下标访问\"><a href=\"#1-3-1-下标访问\" class=\"headerlink\" title=\"1.3.1 下标访问\"></a>1.3.1 下标访问</h4><p>直接和普通数组一样进行访问即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//添加元素</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    vi<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//下标访问 </span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> vi<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"1-3-2-迭代器访问\"><a href=\"#1-3-2-迭代器访问\" class=\"headerlink\" title=\"1.3.2 迭代器访问\"></a>1.3.2 迭代器访问</h4><p>类似指针。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//迭代器访问</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it<span class=\"token punctuation\">;</span>   \n<span class=\"token comment\" spellcheck=\"true\">//相当于声明了一个迭代器类型的变量it</span>\n<span class=\"token comment\" spellcheck=\"true\">//通俗来说就是声明了一个指针变量</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//方式一：</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it <span class=\"token operator\">=</span> vi<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>it <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//方式二：</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>it <span class=\"token operator\">=</span> vi<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> vi<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>it <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>it <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//vi.end()指向尾元素地址的下一个地址</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"1-3-3-智能指针\"><a href=\"#1-3-3-智能指针\" class=\"headerlink\" title=\"1.3.3 智能指针\"></a>1.3.3 智能指针</h4><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。<br><strong>auto</strong> 能够自动识别并获取类型。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">241</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> val <span class=\"token operator\">:</span> v<span class=\"token punctuation\">)</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> val <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 12 241</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p><code>vector</code>注意：</p>\n<ul>\n<li><p><code>vi[i]</code>  和  <code>*(vi.begin() + i)</code> 等价</p>\n</li>\n<li><p><code>vector</code>和<code>string</code>的<code>STL</code>容器支持<code>*(it + i)</code>的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"2-stack\"><a href=\"#2-stack\" class=\"headerlink\" title=\"2 stack\"></a>2 stack</h2><h3 id=\"2-1-介绍\"><a href=\"#2-1-介绍\" class=\"headerlink\" title=\"2.1 介绍\"></a>2.1 介绍</h3><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件需要添加</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stack></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">//声明</span>\nstack<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span>\nstack<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span>\nstack<span class=\"token operator\">&lt;</span>node<span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//node是结构体类型</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-2-方法函数\"><a href=\"#2-2-方法函数\" class=\"headerlink\" title=\"2.2 方法函数\"></a>2.2 方法函数</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.push(ele)</code></td>\n<td>元素<code>ele</code>入栈，增加元素  $O(1)$</td>\n</tr>\n<tr>\n<td><code>s.pop()</code></td>\n<td>移除栈顶元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>s.top()</code></td>\n<td>取得栈顶元素（但不删除）$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.empty()</code></td>\n<td>检测栈内是否为空，空为真 $O(1)$</td>\n</tr>\n<tr>\n<td><code>s.size()</code></td>\n<td>返回栈内元素的个数 $O(1)$</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"2-3-栈遍历\"><a href=\"#2-3-栈遍历\" class=\"headerlink\" title=\"2.3 栈遍历\"></a>2.3 栈遍历</h3><h4 id=\"2-3-1-栈遍历\"><a href=\"#2-3-1-栈遍历\" class=\"headerlink\" title=\"2.3.1 栈遍历\"></a>2.3.1 栈遍历</h4><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p>\n<h4 id=\"2-3-2-数组模拟栈进行遍历\"><a href=\"#2-3-2-数组模拟栈进行遍历\" class=\"headerlink\" title=\"2.3.2 数组模拟栈进行遍历\"></a>2.3.2 数组模拟栈进行遍历</h4><p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p>\n<p><strong>特点：</strong> 比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 栈 从左至右为栈底到栈顶</span>\n<span class=\"token keyword\">int</span> tt <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// tt 代表栈顶指针,初始栈内无元素，tt为-1</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//入栈 </span>\n    s<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>tt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 出栈</span>\n<span class=\"token keyword\">int</span> top_element <span class=\"token operator\">=</span> s<span class=\"token punctuation\">[</span>tt<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">//入栈操作示意</span>\n<span class=\"token comment\" spellcheck=\"true\">//  0  1  2  3  4  5  </span>\n<span class=\"token comment\" spellcheck=\"true\">//                tt</span>\n<span class=\"token comment\" spellcheck=\"true\">//出栈后示意</span>\n<span class=\"token comment\" spellcheck=\"true\">//  0  1  2  3  4 </span>\n<span class=\"token comment\" spellcheck=\"true\">//              tt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"3-queue\"><a href=\"#3-queue\" class=\"headerlink\" title=\"3 queue\"></a>3 queue</h2><h3 id=\"3-1-介绍\"><a href=\"#3-1-介绍\" class=\"headerlink\" title=\"3.1 介绍\"></a>3.1 介绍</h3><p>队列是一种先进先出的数据结构。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;queue></span></span>\n<span class=\"token comment\" spellcheck=\"true\">//定义初始化</span>\nqueue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"3-2-方法函数\"><a href=\"#3-2-方法函数\" class=\"headerlink\" title=\"3.2 方法函数\"></a>3.2 方法函数</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>q.front()</code></td>\n<td>返回队首元素  $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.back()</code></td>\n<td>返回队尾元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.push(element)</code></td>\n<td>尾部添加一个元素<code>element</code>  进队$O(1)$</td>\n</tr>\n<tr>\n<td><code>q.pop()</code></td>\n<td>删除第一个元素  出队 $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.size()</code></td>\n<td>返回队列中元素个数，返回值类型<code>unsigned int</code> $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.empty()</code></td>\n<td>判断是否为空，队列为空，返回<code>true</code> $O(1)$</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-3-队列模拟\"><a href=\"#3-3-队列模拟\" class=\"headerlink\" title=\"3.3 队列模拟\"></a>3.3 队列模拟</h3><p>使用<code>q[]</code>数组模拟队列<br><code>hh</code>表示队首元素的下标，初始值为<code>0</code><br><code>tt</code>表示队尾元素的下标，初始值为<code>-1</code>，表示刚<strong>开始队列为空</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e5</span><span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> q<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> hh <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>tt <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//    入队 </span>\n    q<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>tt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>tt<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">//    将所有元素出队 </span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>hh <span class=\"token operator\">&lt;=</span> tt<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> q<span class=\"token punctuation\">[</span>hh<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"4-deque\"><a href=\"#4-deque\" class=\"headerlink\" title=\"4 deque\"></a>4 deque</h2><h3 id=\"4-1-介绍\"><a href=\"#4-1-介绍\" class=\"headerlink\" title=\"4.1 介绍\"></a>4.1 介绍</h3><p>首尾都可插入和删除的队列为双端队列。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//添加头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;deque></span></span>\n<span class=\"token comment\" spellcheck=\"true\">//初始化定义</span>\ndeque<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> dq<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"4-2-方法函数\"><a href=\"#4-2-方法函数\" class=\"headerlink\" title=\"4.2 方法函数\"></a>4.2 方法函数</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_back(x)/push_front(x)</code></td>\n<td>把<code>x</code>插入队尾后 / 队首 $O(1)$</td>\n</tr>\n<tr>\n<td><code>back()/front()</code></td>\n<td>返回队尾 / 队首元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>pop_back() / pop_front()</code></td>\n<td>删除队尾 / 队首元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>erase(iterator it)</code></td>\n<td>删除双端队列中的某一个元素</td>\n</tr>\n<tr>\n<td><code>erase(iterator first,iterator last)</code></td>\n<td>删除双端队列中<code>[first,last)</code>中的元素</td>\n</tr>\n<tr>\n<td><code>empty()</code></td>\n<td>判断deque是否空 $O(1)$</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>返回deque的元素数量 $O(1)$</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空deque</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-3-注意点\"><a href=\"#4-3-注意点\" class=\"headerlink\" title=\"4.3 注意点\"></a>4.3 注意点</h3><p>deque可以进行排序</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//从小到大</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//从大到小排序</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//deque里面的类型需要是int型</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">greater</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//高版本C++才可以用</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"5-priority-queue\"><a href=\"#5-priority-queue\" class=\"headerlink\" title=\"5. priority_queue\"></a>5. priority_queue</h2><h3 id=\"5-1-介绍\"><a href=\"#5-1-介绍\" class=\"headerlink\" title=\"5.1 介绍\"></a>5.1 介绍</h3><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p>\n<p>可以实现每次从优先队列中取出的元素都是队列中<strong>优先级最大</strong>的一个。</p>\n<p>它的底层是通过<strong>堆</strong>来实现的。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;queue></span></span>\n<span class=\"token comment\" spellcheck=\"true\">//初始化定义</span>\npriority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"5-2-函数方法\"><a href=\"#5-2-函数方法\" class=\"headerlink\" title=\"5.2 函数方法\"></a>5.2 函数方法</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>q.top()</code></td>\n<td>访问队首元素</td>\n</tr>\n<tr>\n<td><code>q.push()</code></td>\n<td>入队</td>\n</tr>\n<tr>\n<td><code>q.pop()</code></td>\n<td>堆顶（队首）元素出队</td>\n</tr>\n<tr>\n<td><code>q.size()</code></td>\n<td>队列元素个数</td>\n</tr>\n<tr>\n<td><code>q.empty()</code></td>\n<td>是否为空</td>\n</tr>\n<tr>\n<td><strong>注意</strong>没有<code>clear()</code>！</td>\n<td>不提供该方法</td>\n</tr>\n<tr>\n<td>优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"5-3-设置优先级\"><a href=\"#5-3-设置优先级\" class=\"headerlink\" title=\"5.3 设置优先级\"></a>5.3 设置优先级</h3><h4 id=\"5-3-1-基本数据类型的优先级\"><a href=\"#5-3-1-基本数据类型的优先级\" class=\"headerlink\" title=\"5.3.1 基本数据类型的优先级\"></a>5.3.1 基本数据类型的优先级</h4><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">priority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> pq<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 默认大根堆, 即每次取出的元素是队列中的最大值</span>\npriority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 小根堆, 每次取出的元素是队列中的最小值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>参数解释：</strong></p>\n<ul>\n<li><p><strong>第二个参数：</strong><br><code>vector&lt; int &gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是<code>double</code>型数据，就要填<code>vector&lt; double &gt;</code><br><strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p>\n</li>\n<li><p><strong>第三个参数：</strong><br><code>less&lt; int &gt;</code>   表示数字大的优先级大，堆顶为最大的数字<br><code>greater&lt; int &gt;</code>表示数字小的优先级大，堆顶为最小的数字<br><strong>int代表的是数据类型，也要填优先队列中存储的数据类型</strong></p>\n</li>\n</ul>\n<p>下面介绍基础数据类型优先级设置的写法。</p>\n<p><strong>1. 基础写法（非常常用）</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">priority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> q1<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 默认大根堆, 即每次取出的元素是队列中的最大值</span>\npriority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> less<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> q2<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 大根堆, 每次取出的元素是队列中的最大值，同第一行</span>\n\npriority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> q3<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 小根堆, 每次取出的元素是队列中的最小值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 自定义排序（不常见，主要是写着麻烦）</strong></p>\n<p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> cmp1\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">></span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> cmp2\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">&lt;</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\npriority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> cmp1<span class=\"token operator\">></span> q1<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 小根堆</span>\npriority_queue<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> cmp2<span class=\"token operator\">></span> q2<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 大根堆</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h4 id=\"5-3-2-结构体优先级设置\"><a href=\"#5-3-2-结构体优先级设置\" class=\"headerlink\" title=\"5.3.2 结构体优先级设置\"></a>5.3.2 结构体优先级设置</h4><blockquote>\n<p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p>\n</blockquote>\n<p>优先级设置可以定义在<strong>结构体内</strong>进行小于号重载，也可以定义在<strong>结构体外</strong>。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//要排序的结构体（存储在优先队列里面的）</span>\n<span class=\"token keyword\">struct</span> Point\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>版本一：自定义全局比较规则</strong></li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//定义的比较结构体</span>\n<span class=\"token comment\" spellcheck=\"true\">//注意：cmp是个结构体 </span>\n<span class=\"token keyword\">struct</span> cmp\n<span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//自定义堆的排序规则 </span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Point<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">const</span> Point<span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//初始化定义， </span>\npriority_queue<span class=\"token operator\">&lt;</span>Point<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>Point<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> cmp<span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// x大的在堆顶</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>版本二：直接在结构体里面写</strong></li>\n</ul>\n<blockquote>\n<p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p>\n</blockquote>\n<p>结构体内部有两种方式</p>\n<p><strong>方式一</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> node\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">friend</span> <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>Point a<span class=\"token punctuation\">,</span> Point b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//为两个结构体参数，结构体调用一定要写上friend</span>\n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//按x从小到大排，x大的在堆顶</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>方式二</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> node\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Point <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n    <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//直接传入一个参数，不必要写friend</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//按x升序排列，x大的在堆顶</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>优先队列的定义</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">priority_queue<span class=\"token operator\">&lt;</span>Point<span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>注意：</strong> 优先队列自定义排序规则和<code>sort()</code>函数定义<code>cmp</code>函数很相似，但是最后返回的情况是<strong>相反</strong>的。即相同的符号，最后定义的排列顺序是完全相反的。<br>所以只需要记住<code>sort</code>的排序规则和优先队列的排序规则是相反的就可以了。</p>\n<hr>\n<h3 id=\"5-4-存储特殊类型的优先级\"><a href=\"#5-4-存储特殊类型的优先级\" class=\"headerlink\" title=\"5.4 存储特殊类型的优先级\"></a>5.4 存储特殊类型的优先级</h3><h4 id=\"5-4-1-存储pair类型\"><a href=\"#5-4-1-存储pair类型\" class=\"headerlink\" title=\"5.4.1 存储pair类型\"></a>5.4.1 存储pair类型</h4><ul>\n<li>排序规则：<br>默认先对<code>pair</code>的<code>first</code>进行降序排序，然后再对<code>second</code>降序排序<br>对<code>first</code>先排序，大的排在前面，如果<code>first</code>元素相同，再对<code>second</code>元素排序，保持大的在前面。</li>\n</ul>\n<blockquote>\n<p><code>pair</code>请参考下文</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    priority_queue<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span>q<span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>second <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n        q<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>结果：<br>8 7<br>7 9<br>7 8</p>\n</blockquote>\n<hr>\n<h2 id=\"6-map\"><a href=\"#6-map\" class=\"headerlink\" title=\"6. map\"></a>6. map</h2><h3 id=\"6-1-介绍\"><a href=\"#6-1-介绍\" class=\"headerlink\" title=\"6.1 介绍\"></a>6.1 介绍</h3><p>映射类似于函数的对应关系，每个<code>x</code>对应一个<code>y</code>，而<code>map</code>是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。</p>\n<blockquote>\n<p>比如说：学习 对应 看书，学习 是键，看书 是值。<br>学习-&gt;看书<br>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。<br>玩耍-&gt;打游戏</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;map></span></span>\n<span class=\"token comment\" spellcheck=\"true\">//初始化定义</span>\nmap<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span>string<span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span>\nmap<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span>\nmap<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>node<span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//node是结构体类型</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p>\n</blockquote>\n<h3 id=\"6-2-函数方法\"><a href=\"#6-2-函数方法\" class=\"headerlink\" title=\"6.2 函数方法\"></a>6.2 函数方法</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>mp.find(key)</code></td>\n<td>返回键为key的映射的迭代器 $O(logN) $  注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$</td>\n</tr>\n<tr>\n<td><code>mp.erase(it)</code></td>\n<td>删除迭代器对应的键和值$O(1)$</td>\n</tr>\n<tr>\n<td><code>mp.erase(key)</code></td>\n<td>根据映射的键删除键和值 $O(logN)$</td>\n</tr>\n<tr>\n<td><code>mp.erase(first,last)</code></td>\n<td>删除左闭右开区间迭代器对应的键和值 $O(last-first)$</td>\n</tr>\n<tr>\n<td><code>mp.size()</code></td>\n<td>返回映射的对数$ O(1)$</td>\n</tr>\n<tr>\n<td><code>mp.clear()</code></td>\n<td>清空map中的所有元素$O(N)$</td>\n</tr>\n<tr>\n<td><code>mp.insert()</code></td>\n<td>插入元素，插入时要构造键值对</td>\n</tr>\n<tr>\n<td><code>mp.empty()</code></td>\n<td>如果map为空，返回true，否则返回false</td>\n</tr>\n<tr>\n<td><code>mp.begin()</code></td>\n<td>返回指向map第一个元素的迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>mp.end()</code></td>\n<td>返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td>\n</tr>\n<tr>\n<td><code>mp.rbegin()</code></td>\n<td>返回指向map最后一个元素的迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>mp.rend()</code></td>\n<td>返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>mp.count(key)</code></td>\n<td>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>\n</tr>\n<tr>\n<td><code>mp.lower_bound()</code></td>\n<td>返回一个迭代器，指向键值&gt;= <strong>key</strong>的第一个元素</td>\n</tr>\n<tr>\n<td><code>mp.upper_bound()</code></td>\n<td>返回一个迭代器，指向键值&gt; key的第一个元素</td>\n</tr>\n</tbody></table>\n<p><strong>下面说明部分函数方法的注意点</strong></p>\n<blockquote>\n<p>注意：<br>查找元素是否存在时，可以使用<br>①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p>\n</blockquote>\n<hr>\n<p><strong>使用迭代器进行正反向遍历：</strong></p>\n<p> <code>mp.begin()</code>和<code>mp.end()</code>用法：<br><strong>用于正向遍历map</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>it <span class=\"token operator\">!=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> it<span class=\"token operator\">-</span><span class=\"token operator\">></span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> it<span class=\"token operator\">-</span><span class=\"token operator\">></span>second <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    it <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>结果：</strong></p>\n<pre><code>1 2\n2 3\n3 4</code></pre><p><code>mp.rbegin()</code>和<code>mp.rend()</code><br><strong>用于逆向遍历map</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">rbegin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>it <span class=\"token operator\">!=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">rend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> it<span class=\"token operator\">-</span><span class=\"token operator\">></span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> it<span class=\"token operator\">-</span><span class=\"token operator\">></span>second <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    it <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>结果：</strong></p>\n<pre><code>3 4\n2 3\n1 2</code></pre><hr>\n<p>二分查找<code>lower_bound() upper_bound()</code></p>\n<blockquote>\n<p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找<br>返回值为map迭代器类型</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> m<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//有序</span>\n    map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it1 <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">lower_bound</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> it1<span class=\"token operator\">-</span><span class=\"token operator\">></span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//it1->first=2</span>\n    map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it2 <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">upper_bound</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> it2<span class=\"token operator\">-</span><span class=\"token operator\">></span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//it2->first=6</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h3 id=\"6-3-添加元素\"><a href=\"#6-3-添加元素\" class=\"headerlink\" title=\"6.3 添加元素\"></a>6.3 添加元素</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//先声明</span>\nmap<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span>string<span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>方式一：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">mp<span class=\"token punctuation\">[</span><span class=\"token string\">\"学习\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"看书\"</span><span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">[</span><span class=\"token string\">\"玩耍\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"打游戏\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>方式二：插入元素构造键值对</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">mp<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"vegetable\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"蔬菜\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>方式三：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">mp<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>pair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fruit\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"水果\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>方式四:</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">mp<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"hahaha\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"wawawa\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<hr>\n<h3 id=\"6-4-访问元素\"><a href=\"#6-4-访问元素\" class=\"headerlink\" title=\"6.4 访问元素\"></a>6.4 访问元素</h3><p><strong>6.4.1 下标访问：</strong>(大部分情况用于访问单个元素)</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">mp<span class=\"token punctuation\">[</span><span class=\"token string\">\"菜哇菜\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"强哇强\"</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> mp<span class=\"token punctuation\">[</span><span class=\"token string\">\"菜哇菜\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//只是简写的一个例子，程序并不完整</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>6.4.2 遍历访问：</strong></p>\n<p><strong>方式一：迭代器访问</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span>string<span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>it <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//      键                 值 </span>\n    <span class=\"token comment\" spellcheck=\"true\">// it是结构体指针访问所以要用 -> 访问</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> it<span class=\"token operator\">-</span><span class=\"token operator\">></span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> it<span class=\"token operator\">-</span><span class=\"token operator\">></span>second <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//*it是结构体变量 访问要用 . 访问</span>\n    <span class=\"token comment\" spellcheck=\"true\">//cout&lt;&lt;(*it).first&lt;&lt;\" \"&lt;&lt;(*it).second;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>方式二：智能指针访问</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">:</span> mp<span class=\"token punctuation\">)</span>\ncout <span class=\"token operator\">&lt;&lt;</span> i<span class=\"token punctuation\">.</span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> i<span class=\"token punctuation\">.</span>second <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//键，值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>方式三：对指定单个元素访问</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> it <span class=\"token operator\">-</span><span class=\"token operator\">></span> first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span>  it<span class=\"token operator\">-</span><span class=\"token operator\">></span>second <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>方式四：c++17特性才具有</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> mp<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> x <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> y <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//x,y对应键和值</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"6-5-与unordered-map的比较\"><a href=\"#6-5-与unordered-map的比较\" class=\"headerlink\" title=\"6.5 与unordered_map的比较\"></a>6.5 与unordered_map的比较</h3><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p>\n<h4 id=\"6-5-1-内部实现原理\"><a href=\"#6-5-1-内部实现原理\" class=\"headerlink\" title=\"6.5.1 内部实现原理\"></a>6.5.1 内部实现原理</h4><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p>\n<p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p>\n<h4 id=\"6-5-2-效率比较\"><a href=\"#6-5-2-效率比较\" class=\"headerlink\" title=\"6.5.2 效率比较\"></a>6.5.2 效率比较</h4><p><strong>map</strong>：</p>\n<ul>\n<li><p>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$</p>\n</li>\n<li><p>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</p>\n</li>\n</ul>\n<p><strong>unordered_map</strong>：</p>\n<ul>\n<li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li>\n<li>缺点：建立哈希表比较耗时。</li>\n</ul>\n<blockquote>\n<p>两者方法函数基本一样，差别不大。</p>\n<p>注意：</p>\n<ul>\n<li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p>\n</li>\n<li><p>使用<code>[]</code>查找元素时，如果元素不存在，两种容器<strong>都是</strong>创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会<strong>大大降低</strong>。</p>\n</li>\n<li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// 以 map 为例</span>\nmap<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">999999999</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 此处判断是否存在x这个键</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> mp<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 只有存在才会索引对应的值，避免不存在x时多余空元素的创建</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</blockquote>\n<p>还有一种映射：</p>\n<p><a href>multimap</a><br>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p>\n<hr>\n<h2 id=\"7-set\"><a href=\"#7-set\" class=\"headerlink\" title=\"7 set\"></a>7 set</h2><h3 id=\"7-1-介绍\"><a href=\"#7-1-介绍\" class=\"headerlink\" title=\"7.1 介绍\"></a>7.1 介绍</h3><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p>\n<p>即：set里面的元素<strong>不重复 且有序</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;set></span></span>\n<span class=\"token comment\" spellcheck=\"true\">//初始化定义</span>\nset<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"7-2-函数方法\"><a href=\"#7-2-函数方法\" class=\"headerlink\" title=\"7.2 函数方法\"></a>7.2 函数方法</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.begin()</code></td>\n<td>返回set容器的第一个元素的地址（迭代器）$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.end()</code></td>\n<td>返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.rbegin()</code></td>\n<td>返回逆序迭代器，指向容器元素最后一个位置$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.rend()</code></td>\n<td>返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.clear()</code></td>\n<td>删除set容器中的所有的元素,返回unsigned int类型$O(N)$</td>\n</tr>\n<tr>\n<td><code>s.empty()</code></td>\n<td>判断set容器是否为空$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.insert()</code></td>\n<td>插入一个元素</td>\n</tr>\n<tr>\n<td><code>s.size()</code></td>\n<td>返回当前set容器中的元素个数$O(1)$</td>\n</tr>\n<tr>\n<td><code>erase(iterator)</code></td>\n<td>删除定位器iterator指向的值</td>\n</tr>\n<tr>\n<td><code>erase(first,second）</code></td>\n<td>删除定位器first和second之间的值</td>\n</tr>\n<tr>\n<td><code>erase(key_value)</code></td>\n<td>删除键值key_value的值</td>\n</tr>\n<tr>\n<td>查找</td>\n<td></td>\n</tr>\n<tr>\n<td><code>s.find(element)</code></td>\n<td>查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td>\n</tr>\n<tr>\n<td><code>s.count(element)</code></td>\n<td>查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td>\n</tr>\n<tr>\n<td><code>s.lower_bound(k)</code></td>\n<td>返回大于等于k的第一个元素的迭代器$O(logN)$</td>\n</tr>\n<tr>\n<td><code>s.upper_bound(k)</code></td>\n<td>返回大于k的第一个元素的迭代器$O(logN)$</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"7-3-访问\"><a href=\"#7-3-访问\" class=\"headerlink\" title=\"7.3 访问\"></a>7.3 访问</h3><p><strong>迭代器访问</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>set<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator it <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>it <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>智能指针</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">:</span> s<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>访问最后一个元素</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//第一种</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">rbegin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"> <span class=\"token comment\" spellcheck=\"true\">//第二种</span>\nset<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>iterator iter <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\niter<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>iter<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//打印2;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//第三种</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<h3 id=\"7-4-重载-lt-运算符\"><a href=\"#7-4-重载-lt-运算符\" class=\"headerlink\" title=\"7.4 重载&lt;运算符\"></a>7.4 重载&lt;运算符</h3><ul>\n<li><strong>基础数据类型</strong></li>\n</ul>\n<p>方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">set<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> s1<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 默认从小到大排序</span>\nset<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> s2<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 从大到小排序</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//重载 &lt; 运算符</span>\n<span class=\"token keyword\">struct</span> cmp <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n    <span class=\"token punctuation\">{</span>\n       <span class=\"token comment\" spellcheck=\"true\">// return + 返回条件</span>\n       <span class=\"token keyword\">return</span> u <span class=\"token operator\">></span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nset<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> cmp<span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">:</span> s<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 10 9 8 7 6 5 4 3 2 1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>方式三：初始化时使用匿名函数定义比较规则</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">set<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> function<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">>></span> <span class=\"token function\">s</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> i <span class=\"token operator\">></span> j<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 从大到小</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x <span class=\"token operator\">:</span> s<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> x <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>高级数据类型（结构体）</strong></li>\n</ul>\n<p>直接重载结构体运算符即可，让结构体可以比较。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> Point\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Point <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> p<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> y <span class=\"token operator\">&lt;</span> p<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">&lt;</span> p<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nset<span class=\"token operator\">&lt;</span>Point<span class=\"token operator\">></span> s<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> x <span class=\"token operator\">>></span> y<span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>    \n<span class=\"token comment\" spellcheck=\"true\">/* 输入\n5 4\n5 2\n3 7\n3 5\n4 8\n*/</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">:</span> s<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> i<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> i<span class=\"token punctuation\">.</span>y <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/* 输出\n3 5\n3 7\n4 8\n5 2\n5 4\n*/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"7-5-其它set\"><a href=\"#7-5-其它set\" class=\"headerlink\" title=\"7.5 其它set\"></a>7.5 其它set</h3><p><code>multiset</code>:元素可以重复，且元素有序<br><code>unordered_set</code>  ：元素无序且只能出现一次<br><code>unordered_multiset</code> ：  元素无序可以出现多次</p>\n<hr>\n<h2 id=\"8-pair\"><a href=\"#8-pair\" class=\"headerlink\" title=\"8 pair\"></a>8 pair</h2><h3 id=\"8-1-介绍\"><a href=\"#8-1-介绍\" class=\"headerlink\" title=\"8.1 介绍\"></a>8.1 介绍</h3><p>pair只含有两个元素，可以看作是只有两个元素的结构体。<br><strong>应用：</strong></p>\n<ul>\n<li>代替二元结构体</li>\n<li>作为map键值对进行插入（代码如下）</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span>mp<span class=\"token punctuation\">;</span>\nmp<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>pair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xingmaqi\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;utility></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">//1.初始化定义</span>\npair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wangyaqi\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//带初始值的</span>\npair<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//不带初始值的</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//2.赋值</span>\np <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"wang\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">18</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"8-2-访问\"><a href=\"#8-2-访问\" class=\"headerlink\" title=\"8.2 访问\"></a>8.2 访问</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//定义结构体数组</span>\npair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span>p<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//和结构体类似，first代表第一个元素，second代表第二个元素</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"9-string\"><a href=\"#9-string\" class=\"headerlink\" title=\"9 string\"></a>9 string</h2><h3 id=\"9-1-介绍\"><a href=\"#9-1-介绍\" class=\"headerlink\" title=\"9.1 介绍\"></a>9.1 介绍</h3><p>string是一个字符串类，和<code>char</code>型字符串类似。</p>\n<p>可以把string理解为一个字符串类型，像int一样可以定义</p>\n<h3 id=\"9-2-初始化及定义\"><a href=\"#9-2-初始化及定义\" class=\"headerlink\" title=\"9.2 初始化及定义\"></a>9.2 初始化及定义</h3><pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;string></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">//1.</span>\nstring str1<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//生成空字符串</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//2.</span>\nstring <span class=\"token function\">str2</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"123456789\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//生成\"1234456789\"的复制品 </span>\n\n<span class=\"token comment\" spellcheck=\"true\">//3.</span>\nstring <span class=\"token function\">str3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"12345\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//结果为\"123\" ，从0位置开始，长度为3</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//4.</span>\nstring <span class=\"token function\">str4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"123456\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//结果为\"12345\" ，长度为5</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//5.</span>\nstring <span class=\"token function\">str5</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//结果为\"22222\" ,构造5个字符'2'连接而成的字符串</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//6.</span>\nstring <span class=\"token function\">str6</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//结果为\"3456789\"，截取第三个元素（2对应第三位）到最后</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>简单使用</strong></p>\n<ul>\n<li>访问单个字符：</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;string></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    string s <span class=\"token operator\">=</span> <span class=\"token string\">\"xing ma qi!!!\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>string数组使用：</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;string></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    string s<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"loading...  \"</span> <span class=\"token punctuation\">;</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结果：</p>\n<pre><code>loading...  1\nloading...  2\nloading...  3\nloading...  4\nloading...  5\nloading...  6\nloading...  7\nloading...  8\nloading...  9</code></pre><h3 id=\"9-3-string-特性\"><a href=\"#9-3-string-特性\" class=\"headerlink\" title=\"9.3 string 特性\"></a>9.3 string 特性</h3><ul>\n<li><p>支持<strong>比较</strong>运算符<br>string字符串支持常见的比较操作符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持<code>string</code>与<code>C-string</code>的比较（如 <code>str &lt; &quot;hello&quot;</code>）。<br>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p>\n<p>同时，<code>string (&quot;aaaa&quot;) &lt;string(aaaaa)</code>。</p>\n<ul>\n<li><p>支持<code>+</code><strong>运算</strong>符，代表拼接字符串<br>string字符串可以拼接，通过”+”运算符进行拼接。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"123\"</span><span class=\"token punctuation\">;</span>\nstring s2 <span class=\"token operator\">=</span> <span class=\"token string\">\"456\"</span><span class=\"token punctuation\">;</span>\nstring s <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//123456</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9-4-读入详解\"><a href=\"#9-4-读入详解\" class=\"headerlink\" title=\"9.4 读入详解\"></a>9.4 读入详解</h3><p><strong>读入字符串，遇空格，回车结束</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s<span class=\"token punctuation\">;</span>\ncin <span class=\"token operator\">>></span> s<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p> <strong>读入一行字符串（包括空格），遇回车结束</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s<span class=\"token punctuation\">;</span>\n<span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>注意: <code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或<code>cin.get()</code></p>\n<p>错误读取：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\nstring s<span class=\"token punctuation\">;</span>\ncin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n<span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//此时读取相当于读取了前一个回车字符</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>正确读取：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\nstring s<span class=\"token punctuation\">;</span>\ncin <span class=\"token operator\">>></span> n<span class=\"token punctuation\">;</span>\n<span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//cin.get()</span>\n<span class=\"token function\">getline</span><span class=\"token punctuation\">(</span>cin<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//可正确读入下一行的输入</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p><code>cin</code>与<code>cin.getline()</code>混用</p>\n<p>cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致<code>getline()</code>读取回车，结束。<br>需要在cin后面加<code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p>\n</blockquote>\n<p><strong>cin和cout解锁</strong></p>\n<p>代码（写在main函数开头）：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>cout<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<blockquote>\n<p>为什么要进行<code>cin</code>和<code>cout</code>的解锁，原因是：</p>\n<p>在一些题目中，读入的<strong>数据量很大</strong>，往往超过了1e5（10^5^）的数据量,而<code>cin</code>和<code>cout</code>的读入输出的速度<strong>很慢</strong>（是因为<code>cin</code>和<code>cout</code>为了兼容C语言的读入输出在性能上做了妥协），远不如<code>scanf</code>和<code>printf</code>的速度，具体原因可以搜索相关的博客进行了解。</p>\n<p><strong>所以</strong>对<code>cin</code>和<code>cout</code>进行解锁使<code>cin</code>和<code>cout</code>的速度几乎接近<code>scanf</code>和<code>printf</code>，避免输入输出超时。</p>\n</blockquote>\n<p><strong>注意</strong>：<code>cin cout</code>解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code>混用，一定要注意，会出错。</p>\n<blockquote>\n<p><strong>string与C语言字符串（C-string）的区别</strong></p>\n<ul>\n<li>string<br>是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为<code>string</code>，字符串结尾没有<code>\\0</code>字符</li>\n<li>C-string<br>C语言中的字符串，用char数组实现，类型为<code>const char *</code>,字符串结尾以<code>\\0</code>结尾</li>\n</ul>\n</blockquote>\n<p>一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法<code>c_str()</code>实现string向char数组的转换。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"xing ma qi\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> s2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"9-5-函数方法\"><a href=\"#9-5-函数方法\" class=\"headerlink\" title=\"9.5 函数方法\"></a>9.5 函数方法</h3><ul>\n<li><strong>获取字符串长度</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.size()</code>和<code>s.length()</code></td>\n<td>返回string对象的字符个数，他们执行效果相同。</td>\n</tr>\n<tr>\n<td><code>s.max_size()</code></td>\n<td>返回string对象最多包含的字符数，超出会抛出length_error异常</td>\n</tr>\n<tr>\n<td><code>s.capacity()</code></td>\n<td>重新分配内存之前，string对象能包含的最大字符数</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>插入</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.push_back()</code></td>\n<td>在末尾插入</td>\n</tr>\n<tr>\n<td>例：<code>s.push_back(&#39;a&#39;)</code></td>\n<td>末尾插入一个字符a</td>\n</tr>\n<tr>\n<td><code>s.insert(pos,element)</code></td>\n<td>在pos位置插入element</td>\n</tr>\n<tr>\n<td>例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td>\n<td>在第一个位置插入1字符</td>\n</tr>\n<tr>\n<td><code>s.append(str)</code></td>\n<td>在s字符串结尾添加str字符串</td>\n</tr>\n<tr>\n<td>例：<code>s.append(&quot;abc&quot;)</code></td>\n<td>在s字符串末尾添加字符串“abc”</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>删除</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>erase(iterator p)</code></td>\n<td>删除字符串中p所指的字符</td>\n</tr>\n<tr>\n<td><code>erase(iterator first, iterator last)</code></td>\n<td>删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td>\n</tr>\n<tr>\n<td><code>erase(pos,  len)</code></td>\n<td>删除字符串中从索引位置pos开始的len个字符</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>删除字符串中所有字符</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>字符替换</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.replace(pos,n,str)</code></td>\n<td>把当前字符串从索引pos开始的n个字符替换为str</td>\n</tr>\n<tr>\n<td><code>s.replace(pos,n,n1,c)</code></td>\n<td>把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>\n</tr>\n<tr>\n<td><code>s.replace(it1,it2,str)</code></td>\n<td>把当前字符串<code>[it1,it2)</code>区间替换为str    <strong>it1 ,it2为迭代器哦</strong></td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>大小写转换</strong> </li>\n</ul>\n<p>法一：</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tolower(s[i])</code></td>\n<td>转换为小写</td>\n</tr>\n<tr>\n<td><code>toupper(s[i])</code></td>\n<td>转换为大写</td>\n</tr>\n</tbody></table>\n<p>法二：</p>\n<p>通过stl的transform算法配合tolower 和toupper 实现。<br>有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s<span class=\"token punctuation\">;</span>\n<span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token operator\">::</span>tolower<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//转换小写</span>\n<span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token operator\">::</span>toupper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//转换大写</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>分割</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.substr(pos,n)</code></td>\n<td>截取从pos索引开始的n个字符</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>查找</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.find (str,  pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>\n</tr>\n<tr>\n<td><code>s.find (c, pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.rfind (str, pos)</code></td>\n<td>在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td>\n</tr>\n<tr>\n<td><code>s.rfind (c,pos)</code></td>\n<td>在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_first_of (str, pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_first_not_of (str,pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_last_of(str, pos)</code></td>\n<td>在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_last_not_of ( str, pos)</code></td>\n<td>在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;string></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    string <span class=\"token function\">s</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dog bird chicken bird cat\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//字符串查找-----找到后返回首字母在字符串中的下标</span>\n<span class=\"token comment\" spellcheck=\"true\">// 1. 查找一个字符串</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"chicken\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：9</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 2. 从下标为6开始找字符'i'，返回找到的第一个i的下标</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token string\">'i'</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：11</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">rfind</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"chicken\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：9</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 4. 从字符串的末尾开始查找字符</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">rfind</span><span class=\"token punctuation\">(</span><span class=\"token string\">'i'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 5. 在该字符串中查找第一个属于字符串s的字符</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find_first_of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"13br98\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：4---b</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find_first_not_of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello dog 2006\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 结果是：4</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find_first_not_of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dog bird 2006\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 结果是：9</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find_last_of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"13r98\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：19</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">find_last_not_of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"teac\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 结果是：21</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>排序</strong></li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//按ASCII码排序</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<hr>\n<h2 id=\"10-bitset\"><a href=\"#10-bitset\" class=\"headerlink\" title=\"10 bitset\"></a>10 bitset</h2><h3 id=\"10-1-介绍\"><a href=\"#10-1-介绍\" class=\"headerlink\" title=\"10.1 介绍\"></a>10.1 介绍</h3><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//头文件</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bitset></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"10-2-初始化定义\"><a href=\"#10-2-初始化定义\" class=\"headerlink\" title=\"10.2 初始化定义\"></a>10.2 初始化定义</h3><p>初始化方法</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>bitset &lt; n &gt;a</code></td>\n<td>a有n位，每位都为0</td>\n</tr>\n<tr>\n<td><code>bitset &lt; n &gt;a(b)</code></td>\n<td>a是unsigned long型u的一个副本</td>\n</tr>\n<tr>\n<td><code>bitset &lt; n &gt;a(s)</code></td>\n<td>a是string对象s中含有的位串的副本</td>\n</tr>\n<tr>\n<td><code>bitset &lt; n &gt;a(s,pos,n)</code></td>\n<td>a是s中从位置pos开始的n个位的副本</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：<code>n</code>必须为常量表达式</p>\n</blockquote>\n<p>演示代码：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    bitset<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token operator\">></span> bitset1<span class=\"token punctuation\">;</span>　　  <span class=\"token comment\" spellcheck=\"true\">//无参构造，长度为４，默认每一位为０</span>\n\n    bitset<span class=\"token operator\">&lt;</span><span class=\"token number\">9</span><span class=\"token operator\">></span> <span class=\"token function\">bitset2</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　<span class=\"token comment\" spellcheck=\"true\">//长度为9，二进制保存，前面用０补充</span>\n\n    string s <span class=\"token operator\">=</span> <span class=\"token string\">\"100101\"</span><span class=\"token punctuation\">;</span>\n    bitset<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token operator\">></span> <span class=\"token function\">bitset3</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//长度为10，前面用０补充</span>\n\n    <span class=\"token keyword\">char</span> s2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"10101\"</span><span class=\"token punctuation\">;</span>\n    bitset<span class=\"token operator\">&lt;</span><span class=\"token number\">13</span><span class=\"token operator\">></span> <span class=\"token function\">bitset4</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//长度为13，前面用０补充</span>\n\n    cout <span class=\"token operator\">&lt;&lt;</span> bitset1 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//0000</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> bitset2 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//000001100</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> bitset3 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//0000100101</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> bitset4 <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　<span class=\"token comment\" spellcheck=\"true\">//0000000010101</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h3 id=\"10-3-特性\"><a href=\"#10-3-特性\" class=\"headerlink\" title=\"10.3 特性\"></a>10.3 特性</h3><p><code>bitset</code>可以进行<strong>位操作</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">bitset<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token operator\">></span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1001\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbitset<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token operator\">></span> <span class=\"token function\">bar</span> <span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0011\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">^</span><span class=\"token operator\">=</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 1010 (foo对bar按位异或后赋值给foo)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">&amp;</span><span class=\"token operator\">=</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0010 (按位与后赋值给foo)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">|</span><span class=\"token operator\">=</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0011 (按位或后赋值给foo)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">&lt;&lt;=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 1100 (左移２位，低位补０，有自身赋值)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0110 (右移１位，高位补０，有自身赋值)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">~</span>bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 1100 (按位取反)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>bar <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0110 (左移，不赋值)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>bar <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0001 (右移，不赋值)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">==</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// false (0110==0011为false)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">!=</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// true  (0110!=0011为true)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">&amp;</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0010 (按位与，不赋值)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">|</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0111 (按位或，不赋值)</span>\n\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token punctuation\">(</span>foo <span class=\"token operator\">^</span> bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 0101 (按位异或，不赋值)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>访问</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：</span>\nbitset<span class=\"token operator\">&lt;</span><span class=\"token number\">4</span><span class=\"token operator\">></span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"1011\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\ncout <span class=\"token operator\">&lt;&lt;</span> foo<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//1</span>\ncout <span class=\"token operator\">&lt;&lt;</span> foo<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//1</span>\ncout <span class=\"token operator\">&lt;&lt;</span> foo<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">//0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h3 id=\"10-4-方法函数\"><a href=\"#10-4-方法函数\" class=\"headerlink\" title=\"10.4 方法函数\"></a>10.4 方法函数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">代码</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>b.any()</code></td>\n<td align=\"center\">b中是否存在置为1的二进制位，有 返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.none()</code></td>\n<td align=\"center\">b中是否没有1，没有 返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.count()</code></td>\n<td align=\"center\">b中为1的个数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.size()</code></td>\n<td align=\"center\">b中二进制位的个数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.test(pos)</code></td>\n<td align=\"center\">测试b在pos位置是否为1，是 返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b[pos]</code></td>\n<td align=\"center\">返回b在pos处的二进制位</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.set()</code></td>\n<td align=\"center\">把b中所有位都置为1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.set(pos)</code></td>\n<td align=\"center\">把b中pos位置置为1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.reset()</code></td>\n<td align=\"center\">把b中所有位都置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.reset(pos)</code></td>\n<td align=\"center\">把b中pos位置置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.flip()</code></td>\n<td align=\"center\">把b中所有二进制位取反</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.flip(pos)</code></td>\n<td align=\"center\">把b中pos位置取反</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.to_ulong()</code></td>\n<td align=\"center\">用b中同样的二进制位返回一个unsigned long值</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-array\"><a href=\"#11-array\" class=\"headerlink\" title=\"11 array\"></a>11 array</h2><h3 id=\"11-1-介绍\"><a href=\"#11-1-介绍\" class=\"headerlink\" title=\"11.1 介绍\"></a>11.1 介绍</h3><p>头文件</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;array></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>array</code>是C++11新增的容器，效率与普通数据相差无几，比<code>vector</code>效率要高，自身添加了一些成员函数。</p>\n<p>和其它容器不同，array 容器的大小是<strong>固定</strong>的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p>\n<p><strong>注意：</strong></p>\n<p><code>array</code>的使用要在<code>std</code>命名空间里</p>\n<h3 id=\"11-2-声明与初始化\"><a href=\"#11-2-声明与初始化\" class=\"headerlink\" title=\"11.2 声明与初始化\"></a>11.2 声明与初始化</h3><p><strong>基础数据类型</strong></p>\n<p>声明一个大小为100的<code>int</code>型数组，元素的值不确定</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>声明一个大小为100的<code>int</code>型数组，初始值均为<code>0</code>(初始值与默认元素类型等效)</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>声明一个大小为100的<code>int</code>型数组，初始化部分值，其余全部为<code>0</code></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>或者可以用等号</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>高级数据类型</strong></p>\n<p>不同于数组的是对元素类型不做要求，可以套结构体</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token operator\">></span> s <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"ha\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"haha\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\narray<span class=\"token operator\">&lt;</span>node<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token operator\">></span> a<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<h3 id=\"11-3-存取元素\"><a href=\"#11-3-存取元素\" class=\"headerlink\" title=\"11.3 存取元素\"></a>11.3 存取元素</h3><ul>\n<li>修改元素</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li>访问元素</li>\n</ul>\n<p>下标访问</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \\n\"</span><span class=\"token punctuation\">[</span>i <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>利用<code>auto</code>访问</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>迭代器访问</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> it <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>it <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p> <code>at()</code>函数访问</p>\n<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> res <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p> <code>get</code>方法访问</p>\n<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>\n<p>注意：获取的下标只能写数字，不能填变量</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">get<span class=\"token operator\">&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<hr>\n<h3 id=\"11-4-成员函数\"><a href=\"#11-4-成员函数\" class=\"headerlink\" title=\"11.4 成员函数\"></a>11.4 成员函数</h3><table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>begin()</code></td>\n<td>返回容器中第一个元素的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>end()</code></td>\n<td>返回容器最后一个元素之后一个位置的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>rbegin()</code></td>\n<td>返回最后一个元素的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>rend()</code></td>\n<td>返回第一个元素之前一个位置的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数<code>N</code></td>\n</tr>\n<tr>\n<td><code>max_size()</code></td>\n<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>\n</tr>\n<tr>\n<td><code>empty()</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>at(n)</code></td>\n<td>返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td>\n</tr>\n<tr>\n<td><code>front()</code></td>\n<td>返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td>\n</tr>\n<tr>\n<td><code>back()</code></td>\n<td>返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td>\n</tr>\n<tr>\n<td><code>data()</code></td>\n<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td>\n</tr>\n<tr>\n<td><code>fill(x)</code></td>\n<td>将 <code>x</code> 这个值赋值给容器中的每个元素,相当于初始化</td>\n</tr>\n<tr>\n<td><code>array1.swap(array2)</code></td>\n<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"11-5-部分用法示例\"><a href=\"#11-5-部分用法示例\" class=\"headerlink\" title=\"11.5 部分用法示例\"></a>11.5 部分用法示例</h3><p><code>data()</code></p>\n<p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p>\n<p><code>at()</code></p>\n<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">array<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">at</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> res <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><code>fill()</code></p>\n<p>array的<code>fill()</code>函数，将<code>a</code>数组全部元素值变为<code>x</code></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">a<span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>另外还有其它的<code>fill()</code>函数:将<code>a</code>数组$[begin,end)$全部值变为<code>x</code></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>get方法获取元素值</strong></p>\n<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>\n<p>注意:获取的下标只能写数字，不能填变量</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">get<span class=\"token operator\">&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>排序</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<hr>\n<h2 id=\"12-tuple\"><a href=\"#12-tuple\" class=\"headerlink\" title=\"12 tuple\"></a>12 tuple</h2><h3 id=\"12-1-介绍\"><a href=\"#12-1-介绍\" class=\"headerlink\" title=\"12.1 介绍\"></a>12.1 介绍</h3><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p>\n<p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p>\n<p>tuple可以等价为<strong>结构体</strong>使用</p>\n<p><strong>头文件</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;tuple></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"12-2-声明初始化\"><a href=\"#12-2-声明初始化\" class=\"headerlink\" title=\"12.2 声明初始化\"></a>12.2 声明初始化</h3><p>声明一个空的<code>tuple</code>三元组</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">tuple<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> t1<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>赋值</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">t1 <span class=\"token operator\">=</span> <span class=\"token function\">make_tuple</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hahaha\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>创建的同时初始化</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">tuple<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">t2</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可以使用pair对象构造tuple对象，但tuple对象必须是两个元素</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wang\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntuple<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> t3 <span class=\"token punctuation\">{</span>p<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//将pair对象赋给tuple对象</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"12-3-元素操作\"><a href=\"#12-3-元素操作\" class=\"headerlink\" title=\"12.3 元素操作\"></a>12.3 元素操作</h3><p>获取tuple对象<code>t</code>的第一个元素</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> first <span class=\"token operator\">=</span> get<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>修改tuple对象<code>t</code>的第一个元素</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">get<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"12-4-函数操作\"><a href=\"#12-4-函数操作\" class=\"headerlink\" title=\"12.4 函数操作\"></a>12.4 函数操作</h3><ul>\n<li>获取元素个数</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">tuple<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">t</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> tuple_size<span class=\"token operator\">&lt;</span><span class=\"token keyword\">decltype</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token operator\">::</span>value <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li>获取对应元素的值</li>\n</ul>\n<p>通过<code>get&lt;n&gt;(obj)</code>方法获取,<code>n</code>必须为数字不能是变量</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">tuple<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">t</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> get<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1</span>\ncout <span class=\"token operator\">&lt;&lt;</span> get<span class=\"token operator\">&lt;</span><span class=\"token number\">1</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 2</span>\ncout <span class=\"token operator\">&lt;&lt;</span> get<span class=\"token operator\">&lt;</span><span class=\"token number\">2</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>通过<code>tie</code>解包 获取元素值</li>\n</ul>\n<p><code>tie</code>可以让tuple变量中的三个值依次赋到tie中的三个变量中</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> one<span class=\"token punctuation\">,</span> three<span class=\"token punctuation\">;</span>\nstring two<span class=\"token punctuation\">;</span> \ntuple<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> string<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">t</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hahaha\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">tie</span><span class=\"token punctuation\">(</span>one<span class=\"token punctuation\">,</span> two<span class=\"token punctuation\">,</span> three<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> one <span class=\"token operator\">&lt;&lt;</span> two <span class=\"token operator\">&lt;&lt;</span> three <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1hahaha3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h1 id=\"STL函数\"><a href=\"#STL函数\" class=\"headerlink\" title=\"STL函数\"></a>STL函数</h1><h2 id=\"accumulate\"><a href=\"#accumulate\" class=\"headerlink\" title=\"accumulate\"></a>accumulate</h2><pre><code>accumulate(beg, end, init)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>作用：对一个序列的元素求和</p>\n</blockquote>\n<p><code>init</code>为对序列元素求和的<strong>初始值</strong></p>\n<p>返回值类型：与<code>init</code></p>\n<ul>\n<li><strong>基础累加求和：</strong></li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//对[0,2]区间求和，初始值为0，结果为0+1+3+5=9</span>\n<span class=\"token keyword\">int</span> res1 <span class=\"token operator\">=</span> <span class=\"token function\">accumulate</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//对[0,3]区间求和，初始值为5，结果为5+1+3+5+9=23</span>\n<span class=\"token keyword\">int</span> res2 <span class=\"token operator\">=</span> <span class=\"token function\">accumulate</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>自定义二元对象求和：</strong></li>\n</ul>\n<p>使用<strong>lamda表达式</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> ll<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> node\n<span class=\"token punctuation\">{</span>\n    ll num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>st<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    st<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">10000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//返回值类型与init一致，同时注意参数类型（a）也要一样</span>\n<span class=\"token comment\" spellcheck=\"true\">//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007</span>\nll res <span class=\"token operator\">=</span> <span class=\"token function\">accumulate</span><span class=\"token punctuation\">(</span>st <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> st <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1ll</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>ll a<span class=\"token punctuation\">,</span>node b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"atoi\"><a href=\"#atoi\" class=\"headerlink\" title=\"atoi\"></a>atoi</h2><pre><code>atoi(const char *)</code></pre><blockquote>\n<p>将字符串转换为<code>int</code>类型</p>\n</blockquote>\n<p>注意参数为<code>char</code>型数组，如果需要将string类型转换为int类型，可以使用<code>stoi</code>函数（参考下文），或者将<code>string</code>类型转换为<code>const char *</code>类型。</p>\n<p>关于输出数字的范围：<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"1234\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> a <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1234</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>或者</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">char</span> s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"1234\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> a <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h2><pre><code>fill(beg,end,num)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>对一个序列进行初始化赋值</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//对a数组的所有元素赋1</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>a<span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    cout<span class=\"token operator\">&lt;&lt;</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//1 1 1 1 1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注意区分memset：</p>\n<p><code>memset()</code>是按<strong>字节</strong>进行赋值，对于初始化赋<code>0</code>或<code>-1</code>有比较好的效果.</p>\n<p>如果赋某个特定的数会<strong>出错</strong>，赋值特定的数建议使用<code>fill()</code></p>\n<h2 id=\"is-sorted\"><a href=\"#is-sorted\" class=\"headerlink\" title=\"is_sorted\"></a>is_sorted</h2><pre><code>is_sorted(beg,end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>判断序列是否有序（升序），返回<code>bool</code>值</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//如果序列有序，输出YES</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">is_sorted</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>a<span class=\"token operator\">+</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"YES\\n\"</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"iota\"><a href=\"#iota\" class=\"headerlink\" title=\"iota\"></a>iota</h2><pre><code>iota(beg, end)</code></pre><blockquote>\n<p>让序列递增赋值</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">iota</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 0 1 2 3 4 5 6 7 8 9</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"lower-bound-upper-bound\"><a href=\"#lower-bound-upper-bound\" class=\"headerlink\" title=\"lower_bound + upper_bound\"></a>lower_bound + upper_bound</h2><p><strong>复杂度：</strong> $O(logN)$</p>\n<blockquote>\n<p>作用：二分查找</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//在a数组中查找第一个大于等于x的元素，返回该元素的地址</span>\n<span class=\"token function\">lower_bound</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//在a数组中查找第一个大于x的元素，返回该元素的地址</span>\n<span class=\"token function\">upper_bound</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//如果未找到，返回尾地址的下一个位置的地址</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"max-element-min-element\"><a href=\"#max-element-min-element\" class=\"headerlink\" title=\"max_element+min_element\"></a>max_element+min_element</h2><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>找最大最小值</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//函数都是返回地址，需要加*取值</span>\n<span class=\"token keyword\">int</span> mx <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">max_element</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> mn <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">min_element</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"max-min\"><a href=\"#max-min\" class=\"headerlink\" title=\"max+min\"></a>max+min</h2><p><strong>复杂度：</strong> $O(1)$</p>\n<blockquote>\n<p>找多个元素的最大值和最小值</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//找a，b的最大值和最小值</span>\nmx <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmn <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//找到a,b,c,d的最大值和最小值</span>\nmx <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmn <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"minmax\"><a href=\"#minmax\" class=\"headerlink\" title=\"minmax\"></a>minmax</h2><pre><code>minmax(a, b)</code></pre><p><strong>复杂度：</strong> $O(1)$</p>\n<blockquote>\n<p>返回一个<code>pair</code>类型，第一个元素是<code>min(a, b)</code>， 第二个元素是<code>max(a, b)</code></p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> t <span class=\"token operator\">=</span> <span class=\"token function\">minmax</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// t.first = 2, t.second = 4</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"minmax-element\"><a href=\"#minmax-element\" class=\"headerlink\" title=\"minmax_element\"></a>minmax_element</h2><pre><code>minmax_element(beg, end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>返回序列中的最小和最大值组成pair的对应的地址，返回类型为<code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">iota</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> t <span class=\"token operator\">=</span> <span class=\"token function\">minmax_element</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回的是最小值和最大值对应的地址</span>\n<span class=\"token comment\" spellcheck=\"true\">// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"nth-element\"><a href=\"#nth-element\" class=\"headerlink\" title=\"nth_element\"></a>nth_element</h2><pre><code>nth_element(beg, nth, end)</code></pre><p><strong>复杂度：</strong> 平均$O(N)$</p>\n<blockquote>\n<p>寻找第序列第n小的值</p>\n</blockquote>\n<p><code>nth</code>为一个迭代器，指向序列中的一个元素。第n小的值恰好在<code>nth</code>位置上。</p>\n<p>执行<code>nth_element()</code>之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p>\n<p><strong>实例：求序列中的第3小的元素</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">nth_element</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"next-permutation\"><a href=\"#next-permutation\" class=\"headerlink\" title=\"next_permutation\"></a>next_permutation</h2><pre><code>next_permutation(beg, end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>求序列的下一个排列，下一个排列是字典序大一号的排列</p>\n</blockquote>\n<p>返回<code>true</code>或<code>false</code></p>\n<ul>\n<li><p><code>next_permutation(beg,end)</code></p>\n<p>如果是最后一个排列，返回<code>false</code>,否则求出下一个序列后，返回<code>true</code></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//对a序列进行重排</span>\n<span class=\"token function\">next_permutation</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>应用：求所有的排列</strong></p>\n<p>输出<code>a</code>的所有排列</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//数组a不一定是最小字典序序列，所以将它排序</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">do</span>\n<span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">next_permutation</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><code>prev_permutation(beg,end)</code></li>\n</ul>\n<blockquote>\n<p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false</p>\n</blockquote>\n<h2 id=\"partial-sort\"><a href=\"#partial-sort\" class=\"headerlink\" title=\"partial_sort\"></a>partial_sort</h2><pre><code>partial_sort(beg, mid, end)</code></pre><p><strong>复杂度：</strong> 大概$O(N logM)$ <code>M</code>为距离</p>\n<blockquote>\n<p>部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置</p>\n<p>从beg到mid<strong>前</strong>的元素都排好序</p>\n</blockquote>\n<p>对a数组前5个元素排序按从小到大排序</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">partial_sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//1 2 3 4 5 9 8 10 7 6</span>\n<span class=\"token comment\" spellcheck=\"true\">//前五个元素都有序</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>也可以添加自定义排序规则：</p>\n<p> <code>partial_sort(beg,mid,end,cmp)</code></p>\n<p>对a的前五个元素都是降序排列</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">partial_sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    cout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//10 9 8 7 6 1 2 4 5 3</span>\n<span class=\"token comment\" spellcheck=\"true\">//前五个元素降序有序</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"random-shuffle\"><a href=\"#random-shuffle\" class=\"headerlink\" title=\"random_shuffle\"></a>random_shuffle</h2><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<ol>\n<li>随机打乱序列的顺序</li>\n<li>在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11之后应尽量使用<code>shuffle</code>来代替。</li>\n</ol>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">iota</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 序列b递增赋值 1, 2, 3, 4,...</span>\n<span class=\"token comment\" spellcheck=\"true\">//对a数组随机重排</span>\n<span class=\"token function\">random_shuffle</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// C++11之后尽量使用shuffle</span>\n<span class=\"token function\">shuffle</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h2><pre><code>reverse(beg,end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>对序列进行翻转</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"abcde\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//对s进行翻转</span>\ncout <span class=\"token operator\">&lt;&lt;</span> s <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//edcba</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//对a数组进行翻转</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//4321</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><p><strong>复杂度：</strong> $O(N logN)$</p>\n<blockquote>\n<p>作用：对一个序列进行排序</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//原型：</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>beg<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>beg<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//对a数组的[1,n]位置进行从小到大排序</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//对a数组的[0,n-1]位置从大到小排序</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">,</span> greater<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//对a数组的[0,n-1]位置从小到大排序</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> n<span class=\"token punctuation\">,</span> less<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//自定义排序，定义比较函数</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">cmp</span><span class=\"token punctuation\">(</span>node a<span class=\"token punctuation\">,</span>node b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//按结构体里面的x值降序排列</span>\n    <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">.</span>x <span class=\"token operator\">></span> b<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> node <span class=\"token operator\">+</span> n<span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"stable-sort\"><a href=\"#stable-sort\" class=\"headerlink\" title=\"stable_sort\"></a>stable_sort</h2><p><strong>复杂度：</strong> $O(N logN)$</p>\n<blockquote>\n<p>功能和sort()基本一样</p>\n<p>区别在于<code>stable_sort()</code>能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置</p>\n</blockquote>\n<p>使用用法和<code>sort()</code>一样,见上</p>\n<h2 id=\"stoi\"><a href=\"#stoi\" class=\"headerlink\" title=\"stoi\"></a>stoi</h2><pre><code>stoi(const string*)</code></pre><blockquote>\n<p>将对应string类型字符串转换为数字</p>\n</blockquote>\n<p>注意参数为<code>string</code>字符串类型。</p>\n<p>关于输出数字的范围：<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"1234\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> a <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 1234</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h2><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>作用：使用给定操作，将结果写到dest中</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//原型：</span>\n<span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>beg<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> dest<span class=\"token punctuation\">,</span> unaryOp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中</span>\n<span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>beg<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> dest<span class=\"token punctuation\">,</span> <span class=\"token operator\">::</span>tolower<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>beg<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> dest<span class=\"token punctuation\">,</span> <span class=\"token operator\">::</span>toupper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"to-string\"><a href=\"#to-string\" class=\"headerlink\" title=\"to_string\"></a>to_string</h2><blockquote>\n<p>将数字转化为字符串,支持小数（double）</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">12345678</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"unique\"><a href=\"#unique\" class=\"headerlink\" title=\"unique\"></a>unique</h2><pre><code>unique(beg, end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>消除重复元素，返回消除完重复元素的下一个位置的地址</p>\n<p>如：<code>a[] = {1,2,3,3,4 }</code>;</p>\n<p>unique之后a数组为<code>{1,2,3,4,3}</code>前面为无重复元素的数组，后面则是重复元素移到后面，返回<code>a[4]</code>位置的地址（不重复元素的尾后地址）</p>\n</blockquote>\n<p>消除重复元素一般需要原序列是<strong>有序序列</strong></p>\n<p><strong>运用：离散化</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cin <span class=\"token operator\">>></span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    b<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//将a数组复制到b数组</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> b <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//对b数组排序</span>\n<span class=\"token function\">unique</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> b <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//消除b重复元素</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）</span>\n    <span class=\"token keyword\">int</span> pos <span class=\"token operator\">=</span> <span class=\"token function\">lower_bound</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> b <span class=\"token operator\">+</span> n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> b<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//在b数组中二分查找第一个大于等于a[i]的下标</span>\n    a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pos<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//赋值</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"gcd\"><a href=\"#gcd\" class=\"headerlink\" title=\"__gcd\"></a>__gcd</h2><pre><code>__gcd(a,b)</code></pre><blockquote>\n<p>求a和b的最大公约数</p>\n</blockquote>\n<p><code>__gcd(12,15) = 3</code></p>\n<p><code>__gcd(21,0) = 21</code></p>\n<h2 id=\"lg\"><a href=\"#lg\" class=\"headerlink\" title=\"__lg\"></a>__lg</h2><pre><code>__lg(a)</code></pre><blockquote>\n<ol>\n<li>求一个数二进制下最高位位于第几位（从<strong>第0位</strong>开始）（或二进制数下有几位）</li>\n<li><code>__lg(x)</code>相当于返回$\\lfloor log_2 x \\rfloor$</li>\n<li>复杂度$O(1)$</li>\n</ol>\n</blockquote>\n<p><code>__lg(8) = 3</code></p>\n<p><code>__lg(15) = 3</code></p>\n<h2 id=\"builtin-内置位运算函数\"><a href=\"#builtin-内置位运算函数\" class=\"headerlink\" title=\"__builtin_ 内置位运算函数\"></a>__builtin_ 内置位运算函数</h2><p>内置函数有相应的<code>unsigned lnt</code>和<code>unsigned long long</code>版本，<code>unsigned long long</code>只需要在函数名后面加上<code>ll</code>就可以了，比如<code>__builtin_clzll(x)</code>,默认是32位<code>unsigned int</code></p>\n<h3 id=\"builtin-ffs\"><a href=\"#builtin-ffs\" class=\"headerlink\" title=\"__builtin_ffs\"></a>__builtin_ffs</h3><pre><code>__builtin_ffs(x)</code></pre><blockquote>\n<p>二进制中对应最后一位<code>1</code>的位数，比如<code>4</code>会返回<code>3</code>（100）</p>\n</blockquote>\n<h3 id=\"builtin-popcount\"><a href=\"#builtin-popcount\" class=\"headerlink\" title=\"__builtin_popcount\"></a>__builtin_popcount</h3><pre><code>__builtin_popcount(x)</code></pre><blockquote>\n<p><code>x</code>中<code>1</code>的个数</p>\n</blockquote>\n<h3 id=\"builtin-ctz\"><a href=\"#builtin-ctz\" class=\"headerlink\" title=\"__builtin_ctz\"></a>__builtin_ctz</h3><pre><code>__builtin_ctz(x)</code></pre><blockquote>\n<p><code>x</code>末尾<code>0</code>的个数（<code>count tail zero</code>）</p>\n</blockquote>\n<h3 id=\"builtin-clz\"><a href=\"#builtin-clz\" class=\"headerlink\" title=\"__builtin_clz\"></a>__builtin_clz</h3><pre><code>__builtin_clz(x)</code></pre><blockquote>\n<p><code>x</code>前导<code>0</code>的个数（<code>count leading zero</code>）</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">__builtin_clz</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 26</span>\n<span class=\"token comment\" spellcheck=\"true\">//因为共有6位,默认数据范围为32位，32 - 6 = 26</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"builtin-parity\"><a href=\"#builtin-parity\" class=\"headerlink\" title=\"__builtin_parity\"></a>__builtin_parity</h3><pre><code>__builtin_parity(x)</code></pre><blockquote>\n<p><code>x</code>中1的个数的奇偶性， 奇数输出<code>1</code>，偶数输出<code>0</code></p>\n</blockquote>\n<blockquote>\n<p>可参考链接：</p>\n<ol>\n<li><a href=\"https://www.luogu.com.cn/blog/AccRobin/grammar-candies\" target=\"_blank\" rel=\"noopener\">C++语法糖</a> <a href=\"https://www.luogu.com.cn/blog/AccRobin/grammar-candies\" target=\"_blank\" rel=\"noopener\">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li>\n</ol>\n</blockquote>\n<p>可能有些人需要PDF文件，公众号【行码棋】回复 STL 获取，抱歉😭</p>\n<p><img src=\"https://wyqz.top/medias/gzh.jpg\" alt></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"C-STL-总结-基于算法竞赛（悠享版）\"><a href=\"#C-STL-总结-基于算法竞赛（悠享版）\" class=\"headerlink\" title=\"C++ STL 总结-基于算法竞赛（悠享版）\"></a>C++ STL 总结-基于算法竞赛（悠享版）</h1><p>本文介绍常用STL知识，注重应用，强调用法，不强调原理和繁杂的记忆。看过之后请多运用，多敲代码试。</p>\n<blockquote>\n<p>费尽心思重新梳理了一下，注意了些美观性，修改了部分错误，添加了部分解释，编写过程非常难。</p>\n</blockquote>\n<p>另外C++版本一定要对，C++11即可，C++17或20更好。</p>\n<blockquote>\n<p>实践才是检验真理的唯一标准！</p>\n</blockquote>\n<p>CSDN版本：<a href=\"https://wyq666.blog.csdn.net/article/details/114026148\" target=\"_blank\" rel=\"noopener\">https://wyq666.blog.csdn.net/article/details/114026148</a></p>\n<h2 id=\"1-vector\"><a href=\"#1-vector\" class=\"headerlink\" title=\"1 vector\"></a>1 vector</h2><h3 id=\"1-1-介绍\"><a href=\"#1-1-介绍\" class=\"headerlink\" title=\"1.1 介绍\"></a>1.1 介绍</h3><p><code>vector</code>为可变长数组（动态数组），定义的<code>vector</code>数组可以随时添加数值和删除元素。</p>\n<blockquote>\n<p>注意：<strong>在局部区域中（比如局部函数里面）开vector数组，是在堆空间里面开的。</strong> </p>\n<p>在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p>\n<p>故局部区域<strong>不可以</strong>开大长度数组，但是可以开大长度<code>vector</code>。</p>\n</blockquote>\n<ul>\n<li>头文件</li>\n</ul>\n<pre><code class=\"cpp\">#include &lt;vector&gt;</code></pre>\n<ul>\n<li><p>初始化</p>\n<ul>\n<li><p>一维初始化</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; a; //定义了一个名为a的一维数组,数组存储int类型数据\nvector&lt;double&gt; b;//定义了一个名为b的一维数组，数组存储double类型数据\nvector&lt;node&gt; c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型</code></pre>\n<p>指定<strong>长度</strong>和<strong>初始值</strong>的初始化</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; v(n);//定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]\nvector&lt;int&gt; v(n, 1);//v[0]到v[n-1]所有的元素初始值均为1\n//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</code></pre>\n<p>初始化中有多个元素</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5</code></pre>\n<p>拷贝初始化</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; a(n + 1, 0);\nvector&lt;int&gt; b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组</code></pre>\n</li>\n<li><p>二维初始化<br>定义第一维固定长度为<code>5</code>，第二维可变化的二维数组</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; v[5];//定义可变长二维数组\n//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素\n//第一维固定长度为5，第二维长度可以改变</code></pre>\n<blockquote>\n<p><code>vector&lt;int&gt; v[5]</code>可以这样理解：长度为5的v数组，数组中存储的是<code>vector&lt;int&gt;</code>数据类型，而该类型就是数组形式，故<code>v</code>为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p>\n<pre><code class=\"cpp\">v[1].push_back(2);\nv[2].push_back(3);</code></pre>\n</blockquote>\n<p>行列均可变</p>\n<pre><code class=\"cpp\">//初始化二维均可变长数组\nvector&lt;vectot&lt;int&gt;&gt; v;//定义一个行和列均可变的二维数组</code></pre>\n<blockquote>\n<p>应用：可以在<code>v</code>数组里面装多个数组</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; t1{1, 2, 3, 4};\nvector&lt;int&gt; t2{2, 3, 4, 5};\nv.push_back(t1);\nv.push_back(t2);\nv.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector</code></pre>\n</blockquote>\n<p>行列长度均固定 <code>n + 1</code>行 <code>m + 1</code>列初始值为0</p>\n<pre><code class=\"cpp\">vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));</code></pre>\n<p>c++17或者c++20支持的形式（不常用），与上面相同的初始化</p>\n<pre><code class=\"cpp\">vector a(n + 1, vector(m + 1, 0));</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"1-2-方法函数\"><a href=\"#1-2-方法函数\" class=\"headerlink\" title=\"1.2 方法函数\"></a>1.2 方法函数</h3><p>知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。</p>\n<p><strong>c指定为数组名称</strong>，含义中会注明算法复杂度。</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>c.front()</code></td>\n<td>返回第一个数据$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.pop_back()</code></td>\n<td>删除最后一个数据$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.push_back(element)</code></td>\n<td>在尾部加一个数据$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.size()</code></td>\n<td>返回实际数据个数（unsigned类型）$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.clear()</code></td>\n<td>清除元素个数$O(N)$，N为元素个数</td>\n</tr>\n<tr>\n<td><code>c.resize(n, v)</code></td>\n<td>改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td>\n</tr>\n<tr>\n<td><code>c.insert(it, x)</code></td>\n<td>向任意迭代器<code>it</code>插入一个元素<code>x</code> ，$O(N)$</td>\n</tr>\n<tr>\n<td>例：<code>c.insert(c.begin()+2,-1)</code></td>\n<td>将<code>-1</code>插入<code>c[2]</code>的位置</td>\n</tr>\n<tr>\n<td><code>c.erase(first,last)</code></td>\n<td>删除<code>[first,last)</code>的所有元素，$O(N)$</td>\n</tr>\n<tr>\n<td><code>c.begin()</code></td>\n<td>返回首元素的迭代器（通俗来说就是地址）$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.end()</code></td>\n<td>返回最后一个元素后一个位置的迭代器（地址）$O(1)$</td>\n</tr>\n<tr>\n<td><code>c.empty()</code></td>\n<td>判断是否为空，为空返回真，反之返回假 $O(1)$</td>\n</tr>\n</tbody></table>\n<p>注意： <code>end()</code>返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有STL容器均是如此</strong></p>\n<p><strong>排序</strong></p>\n<p>使用<code>sort</code>排序要：  <code>sort(c.begin(), c.end());</code></p>\n<blockquote>\n<p><code>sort()</code>为STL函数，请参考本文最后面STL函数系列。</p>\n</blockquote>\n<p>对所有元素进行排序，如果要对指定区间进行排序，可以对<code>sort()</code>里面的参数进行加减改动。</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; a(n + 1);\nsort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序</code></pre>\n<hr>\n<h3 id=\"1-3-访问\"><a href=\"#1-3-访问\" class=\"headerlink\" title=\"1.3  访问\"></a>1.3  访问</h3><ul>\n<li><strong>下标法：</strong> 和普通数组一样</li>\n</ul>\n<p>注意：一维数组的下标是从$0$到$v.size()-1$，访问之外的数会出现越界错误</p>\n<ul>\n<li><strong>迭代器法：</strong> 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; vi; //定义一个vi数组\nvector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置</code></pre>\n<h4 id=\"1-3-1-下标访问\"><a href=\"#1-3-1-下标访问\" class=\"headerlink\" title=\"1.3.1 下标访问\"></a>1.3.1 下标访问</h4><p>直接和普通数组一样进行访问即可。</p>\n<pre><code class=\"cpp\">//添加元素\nfor(int i = 0; i &lt; 5; i++)\n    vi.push_back(i);\n\n//下标访问 \nfor(int i = 0; i &lt; 5; i++)\n    cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;\ncout &lt;&lt; &quot;\\n&quot;;</code></pre>\n<h4 id=\"1-3-2-迭代器访问\"><a href=\"#1-3-2-迭代器访问\" class=\"headerlink\" title=\"1.3.2 迭代器访问\"></a>1.3.2 迭代器访问</h4><p>类似指针。</p>\n<pre><code class=\"cpp\">//迭代器访问\nvector&lt;int&gt;::iterator it;   \n//相当于声明了一个迭代器类型的变量it\n//通俗来说就是声明了一个指针变量\n\n//方式一：\nvector&lt;int&gt;::iterator it = vi.begin(); \nfor(int i = 0; i &lt; 5; i++)\n    cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;\ncout &lt;&lt; &quot;\\n&quot;;\n\n//方式二：\nvector&lt;int&gt;::iterator it;\nfor(it = vi.begin(); it != vi.end();it ++)\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n//vi.end()指向尾元素地址的下一个地址</code></pre>\n<h4 id=\"1-3-3-智能指针\"><a href=\"#1-3-3-智能指针\" class=\"headerlink\" title=\"1.3.3 智能指针\"></a>1.3.3 智能指针</h4><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。<br><strong>auto</strong> 能够自动识别并获取类型。</p>\n<pre><code class=\"cpp\">vector&lt;int&gt; v;\nv.push_back(12);\nv.push_back(241);\nfor(auto val : v) \n    cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241</code></pre>\n<blockquote>\n<p><code>vector</code>注意：</p>\n<ul>\n<li><p><code>vi[i]</code>  和  <code>*(vi.begin() + i)</code> 等价</p>\n</li>\n<li><p><code>vector</code>和<code>string</code>的<code>STL</code>容器支持<code>*(it + i)</code>的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"2-stack\"><a href=\"#2-stack\" class=\"headerlink\" title=\"2 stack\"></a>2 stack</h2><h3 id=\"2-1-介绍\"><a href=\"#2-1-介绍\" class=\"headerlink\" title=\"2.1 介绍\"></a>2.1 介绍</h3><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。</p>\n<pre><code class=\"cpp\">//头文件需要添加\n#include&lt;stack&gt;\n\n//声明\nstack&lt;int&gt; s;\nstack&lt;string&gt; s;\nstack&lt;node&gt; s;//node是结构体类型</code></pre>\n<h3 id=\"2-2-方法函数\"><a href=\"#2-2-方法函数\" class=\"headerlink\" title=\"2.2 方法函数\"></a>2.2 方法函数</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.push(ele)</code></td>\n<td>元素<code>ele</code>入栈，增加元素  $O(1)$</td>\n</tr>\n<tr>\n<td><code>s.pop()</code></td>\n<td>移除栈顶元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>s.top()</code></td>\n<td>取得栈顶元素（但不删除）$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.empty()</code></td>\n<td>检测栈内是否为空，空为真 $O(1)$</td>\n</tr>\n<tr>\n<td><code>s.size()</code></td>\n<td>返回栈内元素的个数 $O(1)$</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"2-3-栈遍历\"><a href=\"#2-3-栈遍历\" class=\"headerlink\" title=\"2.3 栈遍历\"></a>2.3 栈遍历</h3><h4 id=\"2-3-1-栈遍历\"><a href=\"#2-3-1-栈遍历\" class=\"headerlink\" title=\"2.3.1 栈遍历\"></a>2.3.1 栈遍历</h4><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p>\n<h4 id=\"2-3-2-数组模拟栈进行遍历\"><a href=\"#2-3-2-数组模拟栈进行遍历\" class=\"headerlink\" title=\"2.3.2 数组模拟栈进行遍历\"></a>2.3.2 数组模拟栈进行遍历</h4><p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p>\n<p><strong>特点：</strong> 比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p>\n<pre><code class=\"cpp\">int s[100]; // 栈 从左至右为栈底到栈顶\nint tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1\n\nfor(int i = 0; i &lt;= 5; i++)\n{\n    //入栈 \n    s[++tt] = i;\n}\n// 出栈\nint top_element = s[tt--]; \n\n//入栈操作示意\n//  0  1  2  3  4  5  \n//                tt\n//出栈后示意\n//  0  1  2  3  4 \n//              tt</code></pre>\n<hr>\n<h2 id=\"3-queue\"><a href=\"#3-queue\" class=\"headerlink\" title=\"3 queue\"></a>3 queue</h2><h3 id=\"3-1-介绍\"><a href=\"#3-1-介绍\" class=\"headerlink\" title=\"3.1 介绍\"></a>3.1 介绍</h3><p>队列是一种先进先出的数据结构。</p>\n<pre><code class=\"cpp\">//头文件\n#include&lt;queue&gt;\n//定义初始化\nqueue&lt;int&gt; q;</code></pre>\n<h3 id=\"3-2-方法函数\"><a href=\"#3-2-方法函数\" class=\"headerlink\" title=\"3.2 方法函数\"></a>3.2 方法函数</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>q.front()</code></td>\n<td>返回队首元素  $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.back()</code></td>\n<td>返回队尾元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.push(element)</code></td>\n<td>尾部添加一个元素<code>element</code>  进队$O(1)$</td>\n</tr>\n<tr>\n<td><code>q.pop()</code></td>\n<td>删除第一个元素  出队 $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.size()</code></td>\n<td>返回队列中元素个数，返回值类型<code>unsigned int</code> $O(1)$</td>\n</tr>\n<tr>\n<td><code>q.empty()</code></td>\n<td>判断是否为空，队列为空，返回<code>true</code> $O(1)$</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-3-队列模拟\"><a href=\"#3-3-队列模拟\" class=\"headerlink\" title=\"3.3 队列模拟\"></a>3.3 队列模拟</h3><p>使用<code>q[]</code>数组模拟队列<br><code>hh</code>表示队首元素的下标，初始值为<code>0</code><br><code>tt</code>表示队尾元素的下标，初始值为<code>-1</code>，表示刚<strong>开始队列为空</strong></p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5+5;\nint q[N];\n\nint main()\n{\n    int hh = 0,tt = -1;\n//    入队 \n    q[++tt] = 1;\n    q[++tt] = 2; \n//    将所有元素出队 \n    while(hh &lt;= tt)\n    {\n        int t = q[hh++];\n        printf(&quot;%d &quot;,t);\n    }\n    return 0;\n } </code></pre>\n<hr>\n<h2 id=\"4-deque\"><a href=\"#4-deque\" class=\"headerlink\" title=\"4 deque\"></a>4 deque</h2><h3 id=\"4-1-介绍\"><a href=\"#4-1-介绍\" class=\"headerlink\" title=\"4.1 介绍\"></a>4.1 介绍</h3><p>首尾都可插入和删除的队列为双端队列。</p>\n<pre><code class=\"cpp\">//添加头文件\n#include&lt;deque&gt;\n//初始化定义\ndeque&lt;int&gt; dq;</code></pre>\n<h3 id=\"4-2-方法函数\"><a href=\"#4-2-方法函数\" class=\"headerlink\" title=\"4.2 方法函数\"></a>4.2 方法函数</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_back(x)/push_front(x)</code></td>\n<td>把<code>x</code>插入队尾后 / 队首 $O(1)$</td>\n</tr>\n<tr>\n<td><code>back()/front()</code></td>\n<td>返回队尾 / 队首元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>pop_back() / pop_front()</code></td>\n<td>删除队尾 / 队首元素 $O(1)$</td>\n</tr>\n<tr>\n<td><code>erase(iterator it)</code></td>\n<td>删除双端队列中的某一个元素</td>\n</tr>\n<tr>\n<td><code>erase(iterator first,iterator last)</code></td>\n<td>删除双端队列中<code>[first,last)</code>中的元素</td>\n</tr>\n<tr>\n<td><code>empty()</code></td>\n<td>判断deque是否空 $O(1)$</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>返回deque的元素数量 $O(1)$</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>清空deque</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-3-注意点\"><a href=\"#4-3-注意点\" class=\"headerlink\" title=\"4.3 注意点\"></a>4.3 注意点</h3><p>deque可以进行排序</p>\n<pre><code class=\"cpp\">//从小到大\nsort(q.begin(), q.end())\n//从大到小排序\nsort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型\nsort(q.begin(), q.end(), greater());//高版本C++才可以用</code></pre>\n<hr>\n<h2 id=\"5-priority-queue\"><a href=\"#5-priority-queue\" class=\"headerlink\" title=\"5. priority_queue\"></a>5. priority_queue</h2><h3 id=\"5-1-介绍\"><a href=\"#5-1-介绍\" class=\"headerlink\" title=\"5.1 介绍\"></a>5.1 介绍</h3><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p>\n<p>可以实现每次从优先队列中取出的元素都是队列中<strong>优先级最大</strong>的一个。</p>\n<p>它的底层是通过<strong>堆</strong>来实现的。</p>\n<pre><code class=\"cpp\">//头文件\n#include&lt;queue&gt;\n//初始化定义\npriority_queue&lt;int&gt; q;</code></pre>\n<h3 id=\"5-2-函数方法\"><a href=\"#5-2-函数方法\" class=\"headerlink\" title=\"5.2 函数方法\"></a>5.2 函数方法</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>q.top()</code></td>\n<td>访问队首元素</td>\n</tr>\n<tr>\n<td><code>q.push()</code></td>\n<td>入队</td>\n</tr>\n<tr>\n<td><code>q.pop()</code></td>\n<td>堆顶（队首）元素出队</td>\n</tr>\n<tr>\n<td><code>q.size()</code></td>\n<td>队列元素个数</td>\n</tr>\n<tr>\n<td><code>q.empty()</code></td>\n<td>是否为空</td>\n</tr>\n<tr>\n<td><strong>注意</strong>没有<code>clear()</code>！</td>\n<td>不提供该方法</td>\n</tr>\n<tr>\n<td>优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"5-3-设置优先级\"><a href=\"#5-3-设置优先级\" class=\"headerlink\" title=\"5.3 设置优先级\"></a>5.3 设置优先级</h3><h4 id=\"5-3-1-基本数据类型的优先级\"><a href=\"#5-3-1-基本数据类型的优先级\" class=\"headerlink\" title=\"5.3.1 基本数据类型的优先级\"></a>5.3.1 基本数据类型的优先级</h4><pre><code class=\"cpp\">priority_queue&lt;int&gt; pq; // 默认大根堆, 即每次取出的元素是队列中的最大值\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; // 小根堆, 每次取出的元素是队列中的最小值</code></pre>\n<p><strong>参数解释：</strong></p>\n<ul>\n<li><p><strong>第二个参数：</strong><br><code>vector&lt; int &gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是<code>double</code>型数据，就要填<code>vector&lt; double &gt;</code><br><strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p>\n</li>\n<li><p><strong>第三个参数：</strong><br><code>less&lt; int &gt;</code>   表示数字大的优先级大，堆顶为最大的数字<br><code>greater&lt; int &gt;</code>表示数字小的优先级大，堆顶为最小的数字<br><strong>int代表的是数据类型，也要填优先队列中存储的数据类型</strong></p>\n</li>\n</ul>\n<p>下面介绍基础数据类型优先级设置的写法。</p>\n<p><strong>1. 基础写法（非常常用）</strong></p>\n<pre><code class=\"cpp\">priority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值\npriority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行\n\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值</code></pre>\n<p><strong>2. 自定义排序（不常见，主要是写着麻烦）</strong></p>\n<p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p>\n<pre><code class=\"cpp\">struct cmp1\n{\n    bool operator()(int x,int y)\n    {\n        return x &gt; y;\n    }\n};\nstruct cmp2\n{\n    bool operator()(const int x,const int y)\n    {\n        return x &lt; y;\n    }\n};\npriority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆\npriority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆</code></pre>\n<hr>\n<h4 id=\"5-3-2-结构体优先级设置\"><a href=\"#5-3-2-结构体优先级设置\" class=\"headerlink\" title=\"5.3.2 结构体优先级设置\"></a>5.3.2 结构体优先级设置</h4><blockquote>\n<p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p>\n</blockquote>\n<p>优先级设置可以定义在<strong>结构体内</strong>进行小于号重载，也可以定义在<strong>结构体外</strong>。</p>\n<pre><code class=\"cpp\">//要排序的结构体（存储在优先队列里面的）\nstruct Point\n{\n    int x,y;\n};</code></pre>\n<ul>\n<li><strong>版本一：自定义全局比较规则</strong></li>\n</ul>\n<pre><code class=\"cpp\">//定义的比较结构体\n//注意：cmp是个结构体 \nstruct cmp\n{//自定义堆的排序规则 \n    bool operator()(const Point&amp; a,const Point&amp; b)\n    {\n        return a.x &lt; b.x;\n    }\n};\n\n//初始化定义， \npriority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; // x大的在堆顶</code></pre>\n<ul>\n<li><strong>版本二：直接在结构体里面写</strong></li>\n</ul>\n<blockquote>\n<p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p>\n</blockquote>\n<p>结构体内部有两种方式</p>\n<p><strong>方式一</strong></p>\n<pre><code class=\"cpp\">struct node\n{\n    int x, y;\n    friend bool operator &lt; (Point a, Point b)\n    {//为两个结构体参数，结构体调用一定要写上friend\n        return a.x &lt; b.x;//按x从小到大排，x大的在堆顶\n    }\n};</code></pre>\n<p><strong>方式二</strong></p>\n<pre><code class=\"cpp\">struct node\n{\n    int x, y;\n    bool operator &lt; (const Point &amp;a) const\n    {//直接传入一个参数，不必要写friend\n        return x &lt; a.x;//按x升序排列，x大的在堆顶\n    }\n};</code></pre>\n<p>优先队列的定义</p>\n<pre><code class=\"cpp\">priority_queue&lt;Point&gt; q;</code></pre>\n<p><strong>注意：</strong> 优先队列自定义排序规则和<code>sort()</code>函数定义<code>cmp</code>函数很相似，但是最后返回的情况是<strong>相反</strong>的。即相同的符号，最后定义的排列顺序是完全相反的。<br>所以只需要记住<code>sort</code>的排序规则和优先队列的排序规则是相反的就可以了。</p>\n<hr>\n<h3 id=\"5-4-存储特殊类型的优先级\"><a href=\"#5-4-存储特殊类型的优先级\" class=\"headerlink\" title=\"5.4 存储特殊类型的优先级\"></a>5.4 存储特殊类型的优先级</h3><h4 id=\"5-4-1-存储pair类型\"><a href=\"#5-4-1-存储pair类型\" class=\"headerlink\" title=\"5.4.1 存储pair类型\"></a>5.4.1 存储pair类型</h4><ul>\n<li>排序规则：<br>默认先对<code>pair</code>的<code>first</code>进行降序排序，然后再对<code>second</code>降序排序<br>对<code>first</code>先排序，大的排在前面，如果<code>first</code>元素相同，再对<code>second</code>元素排序，保持大的在前面。</li>\n</ul>\n<blockquote>\n<p><code>pair</code>请参考下文</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    priority_queue&lt;pair&lt;int, int&gt; &gt;q;\n    q.push({7, 8});\n    q.push({7, 9});\n    q.push(make_pair(8, 7));\n    while(!q.empty())\n    {\n        cout &lt;&lt; q.top().first &lt;&lt; &quot; &quot; &lt;&lt; q.top().second &lt;&lt; &quot;\\n&quot;;\n        q.pop();\n    }\n    return 0;\n}</code></pre>\n<blockquote>\n<p>结果：<br>8 7<br>7 9<br>7 8</p>\n</blockquote>\n<hr>\n<h2 id=\"6-map\"><a href=\"#6-map\" class=\"headerlink\" title=\"6. map\"></a>6. map</h2><h3 id=\"6-1-介绍\"><a href=\"#6-1-介绍\" class=\"headerlink\" title=\"6.1 介绍\"></a>6.1 介绍</h3><p>映射类似于函数的对应关系，每个<code>x</code>对应一个<code>y</code>，而<code>map</code>是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。</p>\n<blockquote>\n<p>比如说：学习 对应 看书，学习 是键，看书 是值。<br>学习-&gt;看书<br>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。<br>玩耍-&gt;打游戏</p>\n</blockquote>\n<pre><code class=\"cpp\">//头文件\n#include&lt;map&gt;\n//初始化定义\nmap&lt;string,string&gt; mp;\nmap&lt;string,int&gt; mp;\nmap&lt;int,node&gt; mp;//node是结构体类型</code></pre>\n<blockquote>\n<p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p>\n</blockquote>\n<h3 id=\"6-2-函数方法\"><a href=\"#6-2-函数方法\" class=\"headerlink\" title=\"6.2 函数方法\"></a>6.2 函数方法</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>mp.find(key)</code></td>\n<td>返回键为key的映射的迭代器 $O(logN) $  注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$</td>\n</tr>\n<tr>\n<td><code>mp.erase(it)</code></td>\n<td>删除迭代器对应的键和值$O(1)$</td>\n</tr>\n<tr>\n<td><code>mp.erase(key)</code></td>\n<td>根据映射的键删除键和值 $O(logN)$</td>\n</tr>\n<tr>\n<td><code>mp.erase(first,last)</code></td>\n<td>删除左闭右开区间迭代器对应的键和值 $O(last-first)$</td>\n</tr>\n<tr>\n<td><code>mp.size()</code></td>\n<td>返回映射的对数$ O(1)$</td>\n</tr>\n<tr>\n<td><code>mp.clear()</code></td>\n<td>清空map中的所有元素$O(N)$</td>\n</tr>\n<tr>\n<td><code>mp.insert()</code></td>\n<td>插入元素，插入时要构造键值对</td>\n</tr>\n<tr>\n<td><code>mp.empty()</code></td>\n<td>如果map为空，返回true，否则返回false</td>\n</tr>\n<tr>\n<td><code>mp.begin()</code></td>\n<td>返回指向map第一个元素的迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>mp.end()</code></td>\n<td>返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td>\n</tr>\n<tr>\n<td><code>mp.rbegin()</code></td>\n<td>返回指向map最后一个元素的迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>mp.rend()</code></td>\n<td>返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>mp.count(key)</code></td>\n<td>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>\n</tr>\n<tr>\n<td><code>mp.lower_bound()</code></td>\n<td>返回一个迭代器，指向键值&gt;= <strong>key</strong>的第一个元素</td>\n</tr>\n<tr>\n<td><code>mp.upper_bound()</code></td>\n<td>返回一个迭代器，指向键值&gt; key的第一个元素</td>\n</tr>\n</tbody></table>\n<p><strong>下面说明部分函数方法的注意点</strong></p>\n<blockquote>\n<p>注意：<br>查找元素是否存在时，可以使用<br>①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p>\n</blockquote>\n<hr>\n<p><strong>使用迭代器进行正反向遍历：</strong></p>\n<p> <code>mp.begin()</code>和<code>mp.end()</code>用法：<br><strong>用于正向遍历map</strong></p>\n<pre><code class=\"cpp\">map&lt;int,int&gt; mp;\nmp[1] = 2;\nmp[2] = 3;\nmp[3] = 4;\nauto it = mp.begin();\nwhile(it != mp.end())\n{\n    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\n    it ++;\n}</code></pre>\n<p><strong>结果：</strong></p>\n<pre><code>1 2\n2 3\n3 4</code></pre><p><code>mp.rbegin()</code>和<code>mp.rend()</code><br><strong>用于逆向遍历map</strong></p>\n<pre><code class=\"cpp\">map&lt;int,int&gt; mp;\nmp[1] = 2;\nmp[2] = 3;\nmp[3] = 4;\nauto it = mp.rbegin();\nwhile(it != mp.rend())\n{\n    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\n    it ++;\n}</code></pre>\n<p><strong>结果：</strong></p>\n<pre><code>3 4\n2 3\n1 2</code></pre><hr>\n<p>二分查找<code>lower_bound() upper_bound()</code></p>\n<blockquote>\n<p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找<br>返回值为map迭代器类型</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main()\n{\n    map&lt;int, int&gt; m{{1, 2}, {2, 2}, {1, 2}, {8, 2}, {6, 2}};//有序\n    map&lt;int, int&gt;::iterator it1 = m.lower_bound(2);\n    cout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\\n&quot;;//it1-&gt;first=2\n    map&lt;int, int&gt;::iterator it2 = m.upper_bound(2);\n    cout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\\n&quot;;//it2-&gt;first=6\n    return 0;\n}\n</code></pre>\n<hr>\n<h3 id=\"6-3-添加元素\"><a href=\"#6-3-添加元素\" class=\"headerlink\" title=\"6.3 添加元素\"></a>6.3 添加元素</h3><pre><code class=\"cpp\">//先声明\nmap&lt;string,string&gt; mp;</code></pre>\n<p><strong>方式一：</strong></p>\n<pre><code class=\"cpp\">mp[&quot;学习&quot;] = &quot;看书&quot;;\nmp[&quot;玩耍&quot;] = &quot;打游戏&quot;;</code></pre>\n<p><strong>方式二：插入元素构造键值对</strong></p>\n<pre><code class=\"cpp\">mp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;));</code></pre>\n<p><strong>方式三：</strong></p>\n<pre><code class=\"cpp\">mp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;));</code></pre>\n<p><strong>方式四:</strong></p>\n<pre><code class=\"cpp\">mp.insert({&quot;hahaha&quot;,&quot;wawawa&quot;});</code></pre>\n<hr>\n<h3 id=\"6-4-访问元素\"><a href=\"#6-4-访问元素\" class=\"headerlink\" title=\"6.4 访问元素\"></a>6.4 访问元素</h3><p><strong>6.4.1 下标访问：</strong>(大部分情况用于访问单个元素)</p>\n<pre><code class=\"cpp\">mp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;\ncout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\\n&quot;;//只是简写的一个例子，程序并不完整</code></pre>\n<p><strong>6.4.2 遍历访问：</strong></p>\n<p><strong>方式一：迭代器访问</strong></p>\n<pre><code class=\"cpp\">map&lt;string,string&gt;::iterator it;\nfor(it = mp.begin(); it != mp.end(); it++)\n{\n    //      键                 值 \n    // it是结构体指针访问所以要用 -&gt; 访问\n    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\n    //*it是结构体变量 访问要用 . 访问\n    //cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;\n}</code></pre>\n<p><strong>方式二：智能指针访问</strong></p>\n<pre><code class=\"cpp\">for(auto i : mp)\ncout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值</code></pre>\n<p><strong>方式三：对指定单个元素访问</strong></p>\n<pre><code class=\"cpp\">map&lt;char,int&gt;::iterator it = mp.find(&#39;a&#39;);\ncout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt;  it-&gt;second &lt;&lt; &quot;\\n&quot;;</code></pre>\n<p><strong>方式四：c++17特性才具有</strong></p>\n<pre><code class=\"cpp\">for(auto [x, y] : mp)\n    cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\\n&quot;;\n//x,y对应键和值</code></pre>\n<h3 id=\"6-5-与unordered-map的比较\"><a href=\"#6-5-与unordered-map的比较\" class=\"headerlink\" title=\"6.5 与unordered_map的比较\"></a>6.5 与unordered_map的比较</h3><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p>\n<h4 id=\"6-5-1-内部实现原理\"><a href=\"#6-5-1-内部实现原理\" class=\"headerlink\" title=\"6.5.1 内部实现原理\"></a>6.5.1 内部实现原理</h4><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p>\n<p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p>\n<h4 id=\"6-5-2-效率比较\"><a href=\"#6-5-2-效率比较\" class=\"headerlink\" title=\"6.5.2 效率比较\"></a>6.5.2 效率比较</h4><p><strong>map</strong>：</p>\n<ul>\n<li><p>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$</p>\n</li>\n<li><p>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</p>\n</li>\n</ul>\n<p><strong>unordered_map</strong>：</p>\n<ul>\n<li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li>\n<li>缺点：建立哈希表比较耗时。</li>\n</ul>\n<blockquote>\n<p>两者方法函数基本一样，差别不大。</p>\n<p>注意：</p>\n<ul>\n<li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p>\n</li>\n<li><p>使用<code>[]</code>查找元素时，如果元素不存在，两种容器<strong>都是</strong>创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会<strong>大大降低</strong>。</p>\n</li>\n<li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>\n<pre><code class=\"cpp\">// 以 map 为例\nmap&lt;int, int&gt; mp;\nint x = 999999999;\nif(mp.count(x)) // 此处判断是否存在x这个键\n    cout &lt;&lt; mp[x] &lt;&lt; &quot;\\n&quot;;   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建</code></pre>\n</li>\n</ul>\n</blockquote>\n<p>还有一种映射：</p>\n<p><a href>multimap</a><br>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p>\n<hr>\n<h2 id=\"7-set\"><a href=\"#7-set\" class=\"headerlink\" title=\"7 set\"></a>7 set</h2><h3 id=\"7-1-介绍\"><a href=\"#7-1-介绍\" class=\"headerlink\" title=\"7.1 介绍\"></a>7.1 介绍</h3><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p>\n<p>即：set里面的元素<strong>不重复 且有序</strong></p>\n<pre><code class=\"cpp\">//头文件\n#include&lt;set&gt;\n//初始化定义\nset&lt;int&gt; s;</code></pre>\n<h3 id=\"7-2-函数方法\"><a href=\"#7-2-函数方法\" class=\"headerlink\" title=\"7.2 函数方法\"></a>7.2 函数方法</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.begin()</code></td>\n<td>返回set容器的第一个元素的地址（迭代器）$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.end()</code></td>\n<td>返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.rbegin()</code></td>\n<td>返回逆序迭代器，指向容器元素最后一个位置$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.rend()</code></td>\n<td>返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.clear()</code></td>\n<td>删除set容器中的所有的元素,返回unsigned int类型$O(N)$</td>\n</tr>\n<tr>\n<td><code>s.empty()</code></td>\n<td>判断set容器是否为空$O(1)$</td>\n</tr>\n<tr>\n<td><code>s.insert()</code></td>\n<td>插入一个元素</td>\n</tr>\n<tr>\n<td><code>s.size()</code></td>\n<td>返回当前set容器中的元素个数$O(1)$</td>\n</tr>\n<tr>\n<td><code>erase(iterator)</code></td>\n<td>删除定位器iterator指向的值</td>\n</tr>\n<tr>\n<td><code>erase(first,second）</code></td>\n<td>删除定位器first和second之间的值</td>\n</tr>\n<tr>\n<td><code>erase(key_value)</code></td>\n<td>删除键值key_value的值</td>\n</tr>\n<tr>\n<td>查找</td>\n<td></td>\n</tr>\n<tr>\n<td><code>s.find(element)</code></td>\n<td>查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td>\n</tr>\n<tr>\n<td><code>s.count(element)</code></td>\n<td>查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td>\n</tr>\n<tr>\n<td><code>s.lower_bound(k)</code></td>\n<td>返回大于等于k的第一个元素的迭代器$O(logN)$</td>\n</tr>\n<tr>\n<td><code>s.upper_bound(k)</code></td>\n<td>返回大于k的第一个元素的迭代器$O(logN)$</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"7-3-访问\"><a href=\"#7-3-访问\" class=\"headerlink\" title=\"7.3 访问\"></a>7.3 访问</h3><p><strong>迭代器访问</strong></p>\n<pre><code class=\"cpp\">for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</code></pre>\n<p><strong>智能指针</strong></p>\n<pre><code class=\"cpp\">for(auto i : s)\n    cout &lt;&lt; i &lt;&lt; endl;</code></pre>\n<p><strong>访问最后一个元素</strong></p>\n<pre><code class=\"cpp\">//第一种\ncout &lt;&lt; *s.rbegin() &lt;&lt; endl;</code></pre>\n<pre><code class=\"cpp\"> //第二种\nset&lt;int&gt;::iterator iter = s.end();\niter--;\ncout &lt;&lt; (*iter) &lt;&lt; endl; //打印2;</code></pre>\n<pre><code class=\"cpp\">//第三种\ncout &lt;&lt; *(--s.end()) &lt;&lt; endl;</code></pre>\n<hr>\n<h3 id=\"7-4-重载-lt-运算符\"><a href=\"#7-4-重载-lt-运算符\" class=\"headerlink\" title=\"7.4 重载&lt;运算符\"></a>7.4 重载&lt;运算符</h3><ul>\n<li><strong>基础数据类型</strong></li>\n</ul>\n<p>方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）</p>\n<pre><code class=\"cpp\">set&lt;int&gt; s1; // 默认从小到大排序\nset&lt;int, greater&lt;int&gt; &gt; s2; // 从大到小排序</code></pre>\n<p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p>\n<pre><code class=\"cpp\">//重载 &lt; 运算符\nstruct cmp {\n    bool operator () (const int&amp; u, const int&amp; v) const\n    {\n       // return + 返回条件\n       return u &gt; v;\n    }\n};\nset&lt;int, cmp&gt; s; \n\nfor(int i = 1; i &lt;= 10; i++)\n    s.insert(i);\nfor(auto i : s)\n    cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n// 10 9 8 7 6 5 4 3 2 1</code></pre>\n<p>方式三：初始化时使用匿名函数定义比较规则</p>\n<pre><code class=\"cpp\">set&lt;int, function&lt;bool(int, int)&gt;&gt; s([&amp;](int i, int j){\n    return i &gt; j; // 从大到小\n});\nfor(int i = 1; i &lt;= 10; i++)\n    s.insert(i);\nfor(auto x : s)\n    cout &lt;&lt; x &lt;&lt; &quot; &quot;;</code></pre>\n<ul>\n<li><strong>高级数据类型（结构体）</strong></li>\n</ul>\n<p>直接重载结构体运算符即可，让结构体可以比较。</p>\n<pre><code class=\"cpp\">struct Point\n{\n    int x, y;\n    bool operator &lt; (const Point &amp;p) const\n    {\n        // 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大\n        if(x == p.x)\n            return y &lt; p.y;\n        return x &lt; p.x;\n    }\n};\n\nset&lt;Point&gt; s;\nfor(int i = 1; i &lt;= 5; i++)\n{\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    s.insert({x, y});\n}    \n/* 输入\n5 4\n5 2\n3 7\n3 5\n4 8\n*/\n\nfor(auto i : s)\n    cout &lt;&lt; i.x &lt;&lt; &quot; &quot; &lt;&lt; i.y &lt;&lt; &quot;\\n&quot;;\n/* 输出\n3 5\n3 7\n4 8\n5 2\n5 4\n*/</code></pre>\n<h3 id=\"7-5-其它set\"><a href=\"#7-5-其它set\" class=\"headerlink\" title=\"7.5 其它set\"></a>7.5 其它set</h3><p><code>multiset</code>:元素可以重复，且元素有序<br><code>unordered_set</code>  ：元素无序且只能出现一次<br><code>unordered_multiset</code> ：  元素无序可以出现多次</p>\n<hr>\n<h2 id=\"8-pair\"><a href=\"#8-pair\" class=\"headerlink\" title=\"8 pair\"></a>8 pair</h2><h3 id=\"8-1-介绍\"><a href=\"#8-1-介绍\" class=\"headerlink\" title=\"8.1 介绍\"></a>8.1 介绍</h3><p>pair只含有两个元素，可以看作是只有两个元素的结构体。<br><strong>应用：</strong></p>\n<ul>\n<li>代替二元结构体</li>\n<li>作为map键值对进行插入（代码如下）</li>\n</ul>\n<pre><code class=\"cpp\">map&lt;string,int&gt;mp;\nmp.insert(pair&lt;string,int&gt;(&quot;xingmaqi&quot;,1));</code></pre>\n<pre><code class=\"cpp\">//头文件\n#include&lt;utility&gt;\n\n//1.初始化定义\npair&lt;string,int&gt; p(&quot;wangyaqi&quot;,1);//带初始值的\npair&lt;string,int&gt; p;//不带初始值的\n\n//2.赋值\np = {&quot;wang&quot;,18};</code></pre>\n<h3 id=\"8-2-访问\"><a href=\"#8-2-访问\" class=\"headerlink\" title=\"8.2 访问\"></a>8.2 访问</h3><pre><code class=\"cpp\">//定义结构体数组\npair&lt;int,int&gt;p[20];\nfor(int i = 0; i &lt; 20; i++)\n{\n    //和结构体类似，first代表第一个元素，second代表第二个元素\n    cout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;\n}</code></pre>\n<hr>\n<h2 id=\"9-string\"><a href=\"#9-string\" class=\"headerlink\" title=\"9 string\"></a>9 string</h2><h3 id=\"9-1-介绍\"><a href=\"#9-1-介绍\" class=\"headerlink\" title=\"9.1 介绍\"></a>9.1 介绍</h3><p>string是一个字符串类，和<code>char</code>型字符串类似。</p>\n<p>可以把string理解为一个字符串类型，像int一样可以定义</p>\n<h3 id=\"9-2-初始化及定义\"><a href=\"#9-2-初始化及定义\" class=\"headerlink\" title=\"9.2 初始化及定义\"></a>9.2 初始化及定义</h3><pre><code class=\"cpp\">//头文件\n#include&lt;string&gt;\n\n//1.\nstring str1; //生成空字符串\n\n//2.\nstring str2(&quot;123456789&quot;); //生成&quot;1234456789&quot;的复制品 \n\n//3.\nstring str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3\n\n//4.\nstring str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5\n\n//5.\nstring str5(5, &#39;2&#39;); //结果为&quot;22222&quot; ,构造5个字符&#39;2&#39;连接而成的字符串\n\n//6.\nstring str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后\n</code></pre>\n<p><strong>简单使用</strong></p>\n<ul>\n<li>访问单个字符：</li>\n</ul>\n<pre><code class=\"cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n    string s = &quot;xing ma qi!!!&quot;;\n    for(int i = 0; i &lt; s.size(); i++)\n        cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;\n    return 0;\n}</code></pre>\n<ul>\n<li>string数组使用：</li>\n</ul>\n<pre><code class=\"cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n    string s[10];\n    for(int i = 1; i &lt; 10; i++)\n    {\n        s[i] = &quot;loading...  &quot; ;\n        cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\\n&quot;;\n    } \n    return 0;\n}</code></pre>\n<p>结果：</p>\n<pre><code>loading...  1\nloading...  2\nloading...  3\nloading...  4\nloading...  5\nloading...  6\nloading...  7\nloading...  8\nloading...  9</code></pre><h3 id=\"9-3-string-特性\"><a href=\"#9-3-string-特性\" class=\"headerlink\" title=\"9.3 string 特性\"></a>9.3 string 特性</h3><ul>\n<li><p>支持<strong>比较</strong>运算符<br>string字符串支持常见的比较操作符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持<code>string</code>与<code>C-string</code>的比较（如 <code>str &lt; &quot;hello&quot;</code>）。<br>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p>\n<p>同时，<code>string (&quot;aaaa&quot;) &lt;string(aaaaa)</code>。</p>\n<ul>\n<li><p>支持<code>+</code><strong>运算</strong>符，代表拼接字符串<br>string字符串可以拼接，通过”+”运算符进行拼接。</p>\n<pre><code class=\"cpp\">string s1 = &quot;123&quot;;\nstring s2 = &quot;456&quot;;\nstring s = s1 + s2;\ncout &lt;&lt; s;   //123456</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9-4-读入详解\"><a href=\"#9-4-读入详解\" class=\"headerlink\" title=\"9.4 读入详解\"></a>9.4 读入详解</h3><p><strong>读入字符串，遇空格，回车结束</strong></p>\n<pre><code class=\"cpp\">string s;\ncin &gt;&gt; s;</code></pre>\n<p> <strong>读入一行字符串（包括空格），遇回车结束</strong></p>\n<pre><code class=\"cpp\">string s;\ngetline(cin, s);</code></pre>\n<p>注意: <code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或<code>cin.get()</code></p>\n<p>错误读取：</p>\n<pre><code class=\"cpp\">int n;\nstring s;\ncin &gt;&gt; n;\ngetline(cin, s); //此时读取相当于读取了前一个回车字符</code></pre>\n<p>正确读取：</p>\n<pre><code class=\"cpp\">int n;\nstring s;\ncin &gt;&gt; n;\ngetchar(); //cin.get()\ngetline(cin, s);//可正确读入下一行的输入</code></pre>\n<blockquote>\n<p><code>cin</code>与<code>cin.getline()</code>混用</p>\n<p>cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致<code>getline()</code>读取回车，结束。<br>需要在cin后面加<code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p>\n</blockquote>\n<p><strong>cin和cout解锁</strong></p>\n<p>代码（写在main函数开头）：</p>\n<pre><code class=\"cpp\">ios::sync_with_stdio(false);\ncin.tie(0),cout.tie(0);</code></pre>\n<blockquote>\n<p>为什么要进行<code>cin</code>和<code>cout</code>的解锁，原因是：</p>\n<p>在一些题目中，读入的<strong>数据量很大</strong>，往往超过了1e5（10^5^）的数据量,而<code>cin</code>和<code>cout</code>的读入输出的速度<strong>很慢</strong>（是因为<code>cin</code>和<code>cout</code>为了兼容C语言的读入输出在性能上做了妥协），远不如<code>scanf</code>和<code>printf</code>的速度，具体原因可以搜索相关的博客进行了解。</p>\n<p><strong>所以</strong>对<code>cin</code>和<code>cout</code>进行解锁使<code>cin</code>和<code>cout</code>的速度几乎接近<code>scanf</code>和<code>printf</code>，避免输入输出超时。</p>\n</blockquote>\n<p><strong>注意</strong>：<code>cin cout</code>解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code>混用，一定要注意，会出错。</p>\n<blockquote>\n<p><strong>string与C语言字符串（C-string）的区别</strong></p>\n<ul>\n<li>string<br>是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为<code>string</code>，字符串结尾没有<code>\\0</code>字符</li>\n<li>C-string<br>C语言中的字符串，用char数组实现，类型为<code>const char *</code>,字符串结尾以<code>\\0</code>结尾</li>\n</ul>\n</blockquote>\n<p>一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法<code>c_str()</code>实现string向char数组的转换。</p>\n<pre><code class=\"cpp\">string s = &quot;xing ma qi&quot;;\nchar s2[] = s.c_str();</code></pre>\n<h3 id=\"9-5-函数方法\"><a href=\"#9-5-函数方法\" class=\"headerlink\" title=\"9.5 函数方法\"></a>9.5 函数方法</h3><ul>\n<li><strong>获取字符串长度</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.size()</code>和<code>s.length()</code></td>\n<td>返回string对象的字符个数，他们执行效果相同。</td>\n</tr>\n<tr>\n<td><code>s.max_size()</code></td>\n<td>返回string对象最多包含的字符数，超出会抛出length_error异常</td>\n</tr>\n<tr>\n<td><code>s.capacity()</code></td>\n<td>重新分配内存之前，string对象能包含的最大字符数</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>插入</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.push_back()</code></td>\n<td>在末尾插入</td>\n</tr>\n<tr>\n<td>例：<code>s.push_back(&#39;a&#39;)</code></td>\n<td>末尾插入一个字符a</td>\n</tr>\n<tr>\n<td><code>s.insert(pos,element)</code></td>\n<td>在pos位置插入element</td>\n</tr>\n<tr>\n<td>例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td>\n<td>在第一个位置插入1字符</td>\n</tr>\n<tr>\n<td><code>s.append(str)</code></td>\n<td>在s字符串结尾添加str字符串</td>\n</tr>\n<tr>\n<td>例：<code>s.append(&quot;abc&quot;)</code></td>\n<td>在s字符串末尾添加字符串“abc”</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>删除</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>erase(iterator p)</code></td>\n<td>删除字符串中p所指的字符</td>\n</tr>\n<tr>\n<td><code>erase(iterator first, iterator last)</code></td>\n<td>删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td>\n</tr>\n<tr>\n<td><code>erase(pos,  len)</code></td>\n<td>删除字符串中从索引位置pos开始的len个字符</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>删除字符串中所有字符</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>字符替换</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.replace(pos,n,str)</code></td>\n<td>把当前字符串从索引pos开始的n个字符替换为str</td>\n</tr>\n<tr>\n<td><code>s.replace(pos,n,n1,c)</code></td>\n<td>把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>\n</tr>\n<tr>\n<td><code>s.replace(it1,it2,str)</code></td>\n<td>把当前字符串<code>[it1,it2)</code>区间替换为str    <strong>it1 ,it2为迭代器哦</strong></td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>大小写转换</strong> </li>\n</ul>\n<p>法一：</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tolower(s[i])</code></td>\n<td>转换为小写</td>\n</tr>\n<tr>\n<td><code>toupper(s[i])</code></td>\n<td>转换为大写</td>\n</tr>\n</tbody></table>\n<p>法二：</p>\n<p>通过stl的transform算法配合tolower 和toupper 实现。<br>有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。</p>\n<pre><code class=\"cpp\">string s;\ntransform(s.begin(),s.end(),s.begin(),::tolower);//转换小写\ntransform(s.begin(),s.end(),s.begin(),::toupper);//转换大写</code></pre>\n<ul>\n<li><strong>分割</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.substr(pos,n)</code></td>\n<td>截取从pos索引开始的n个字符</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>查找</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>s.find (str,  pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>\n</tr>\n<tr>\n<td><code>s.find (c, pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.rfind (str, pos)</code></td>\n<td>在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td>\n</tr>\n<tr>\n<td><code>s.rfind (c,pos)</code></td>\n<td>在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_first_of (str, pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_first_not_of (str,pos)</code></td>\n<td>在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_last_of(str, pos)</code></td>\n<td>在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>\n</tr>\n<tr>\n<td><code>s.find_last_not_of ( str, pos)</code></td>\n<td>在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td>\n</tr>\n</tbody></table>\n<pre><code class=\"cpp\">#include&lt;string&gt;\n#include&lt;iostream&gt;\nint main()\n{\n    string s(&quot;dog bird chicken bird cat&quot;);\n//字符串查找-----找到后返回首字母在字符串中的下标\n// 1. 查找一个字符串\n    cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9\n\n// 2. 从下标为6开始找字符&#39;i&#39;，返回找到的第一个i的下标\n    cout &lt;&lt; s.find(&#39;i&#39;,6) &lt;&lt; endl;// 结果是：11\n\n// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标\n    cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9\n\n// 4. 从字符串的末尾开始查找字符\n    cout &lt;&lt; s.rfind(&#39;i&#39;) &lt;&lt; endl;// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符\n\n// 5. 在该字符串中查找第一个属于字符串s的字符\n    cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b\n\n// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4\n    cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4\n    cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9\n\n// 7. 在该字符串最后中查找第一个属于字符串s的字符\n    cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19\n\n// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21\n    cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21\n}</code></pre>\n<ul>\n<li><strong>排序</strong></li>\n</ul>\n<pre><code class=\"cpp\">sort(s.begin(),s.end());  //按ASCII码排序</code></pre>\n<hr>\n<h2 id=\"10-bitset\"><a href=\"#10-bitset\" class=\"headerlink\" title=\"10 bitset\"></a>10 bitset</h2><h3 id=\"10-1-介绍\"><a href=\"#10-1-介绍\" class=\"headerlink\" title=\"10.1 介绍\"></a>10.1 介绍</h3><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间</p>\n<pre><code class=\"cpp\">//头文件\n#include&lt;bitset&gt;</code></pre>\n<h3 id=\"10-2-初始化定义\"><a href=\"#10-2-初始化定义\" class=\"headerlink\" title=\"10.2 初始化定义\"></a>10.2 初始化定义</h3><p>初始化方法</p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>bitset &lt; n &gt;a</code></td>\n<td>a有n位，每位都为0</td>\n</tr>\n<tr>\n<td><code>bitset &lt; n &gt;a(b)</code></td>\n<td>a是unsigned long型u的一个副本</td>\n</tr>\n<tr>\n<td><code>bitset &lt; n &gt;a(s)</code></td>\n<td>a是string对象s中含有的位串的副本</td>\n</tr>\n<tr>\n<td><code>bitset &lt; n &gt;a(s,pos,n)</code></td>\n<td>a是s中从位置pos开始的n个位的副本</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：<code>n</code>必须为常量表达式</p>\n</blockquote>\n<p>演示代码：</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n{\n    bitset&lt;4&gt; bitset1;　　  //无参构造，长度为４，默认每一位为０\n\n    bitset&lt;9&gt; bitset2(12);　//长度为9，二进制保存，前面用０补充\n\n    string s = &quot;100101&quot;;\n    bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用０补充\n\n    char s2[] = &quot;10101&quot;;\n    bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用０补充\n\n    cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000\n    cout &lt;&lt; bitset2 &lt;&lt; endl;　　//000001100\n    cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101\n    cout &lt;&lt; bitset4 &lt;&lt; endl;　//0000000010101\n    return 0;\n}</code></pre>\n<hr>\n<h3 id=\"10-3-特性\"><a href=\"#10-3-特性\" class=\"headerlink\" title=\"10.3 特性\"></a>10.3 特性</h3><p><code>bitset</code>可以进行<strong>位操作</strong></p>\n<pre><code class=\"cpp\">bitset&lt;4&gt; foo (string(&quot;1001&quot;));\nbitset&lt;4&gt; bar (string(&quot;0011&quot;));\n\ncout &lt;&lt; (foo ^= bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)\n\ncout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;// 0010 (按位与后赋值给foo)\n\ncout &lt;&lt; (foo |= bar) &lt;&lt; endl;// 0011 (按位或后赋值给foo)\n\ncout &lt;&lt; (foo &lt;&lt;= 2) &lt;&lt; endl;// 1100 (左移２位，低位补０，有自身赋值)\n\ncout &lt;&lt; (foo &gt;&gt;= 1) &lt;&lt; endl;// 0110 (右移１位，高位补０，有自身赋值)\n\ncout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)\n\ncout &lt;&lt; (bar &lt;&lt; 1) &lt;&lt; endl;// 0110 (左移，不赋值)\n\ncout &lt;&lt; (bar &gt;&gt; 1) &lt;&lt; endl;// 0001 (右移，不赋值)\n\ncout &lt;&lt; (foo == bar) &lt;&lt; endl;// false (0110==0011为false)\n\ncout &lt;&lt; (foo != bar) &lt;&lt; endl;// true  (0110!=0011为true)\n\ncout &lt;&lt; (foo &amp; bar) &lt;&lt; endl;// 0010 (按位与，不赋值)\n\ncout &lt;&lt; (foo | bar) &lt;&lt; endl;// 0111 (按位或，不赋值)\n\ncout &lt;&lt; (foo ^ bar) &lt;&lt; endl;// 0101 (按位异或，不赋值)</code></pre>\n<p><strong>访问</strong></p>\n<pre><code class=\"cpp\">//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：\nbitset&lt;4&gt; foo (&quot;1011&quot;); \n\ncout &lt;&lt; foo[0] &lt;&lt; endl;　　//1\ncout &lt;&lt; foo[1] &lt;&lt; endl;　　//1\ncout &lt;&lt; foo[2] &lt;&lt; endl;　　//0</code></pre>\n<hr>\n<h3 id=\"10-4-方法函数\"><a href=\"#10-4-方法函数\" class=\"headerlink\" title=\"10.4 方法函数\"></a>10.4 方法函数</h3><table>\n<thead>\n<tr>\n<th align=\"center\">代码</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>b.any()</code></td>\n<td align=\"center\">b中是否存在置为1的二进制位，有 返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.none()</code></td>\n<td align=\"center\">b中是否没有1，没有 返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.count()</code></td>\n<td align=\"center\">b中为1的个数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.size()</code></td>\n<td align=\"center\">b中二进制位的个数</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.test(pos)</code></td>\n<td align=\"center\">测试b在pos位置是否为1，是 返回true</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b[pos]</code></td>\n<td align=\"center\">返回b在pos处的二进制位</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.set()</code></td>\n<td align=\"center\">把b中所有位都置为1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.set(pos)</code></td>\n<td align=\"center\">把b中pos位置置为1</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.reset()</code></td>\n<td align=\"center\">把b中所有位都置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.reset(pos)</code></td>\n<td align=\"center\">把b中pos位置置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.flip()</code></td>\n<td align=\"center\">把b中所有二进制位取反</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.flip(pos)</code></td>\n<td align=\"center\">把b中pos位置取反</td>\n</tr>\n<tr>\n<td align=\"center\"><code>b.to_ulong()</code></td>\n<td align=\"center\">用b中同样的二进制位返回一个unsigned long值</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-array\"><a href=\"#11-array\" class=\"headerlink\" title=\"11 array\"></a>11 array</h2><h3 id=\"11-1-介绍\"><a href=\"#11-1-介绍\" class=\"headerlink\" title=\"11.1 介绍\"></a>11.1 介绍</h3><p>头文件</p>\n<pre><code class=\"cpp\">#include&lt;array&gt;</code></pre>\n<p><code>array</code>是C++11新增的容器，效率与普通数据相差无几，比<code>vector</code>效率要高，自身添加了一些成员函数。</p>\n<p>和其它容器不同，array 容器的大小是<strong>固定</strong>的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p>\n<p><strong>注意：</strong></p>\n<p><code>array</code>的使用要在<code>std</code>命名空间里</p>\n<h3 id=\"11-2-声明与初始化\"><a href=\"#11-2-声明与初始化\" class=\"headerlink\" title=\"11.2 声明与初始化\"></a>11.2 声明与初始化</h3><p><strong>基础数据类型</strong></p>\n<p>声明一个大小为100的<code>int</code>型数组，元素的值不确定</p>\n<pre><code class=\"cpp\">array&lt;int, 100&gt; a;</code></pre>\n<p>声明一个大小为100的<code>int</code>型数组，初始值均为<code>0</code>(初始值与默认元素类型等效)</p>\n<pre><code class=\"cpp\">array&lt;int, 100&gt; a{};</code></pre>\n<p>声明一个大小为100的<code>int</code>型数组，初始化部分值，其余全部为<code>0</code></p>\n<pre><code class=\"cpp\">array&lt;int, 100&gt; a{1, 2, 3};</code></pre>\n<p>或者可以用等号</p>\n<pre><code class=\"cpp\">array&lt;int, 100&gt; a = {1, 2, 3};</code></pre>\n<p><strong>高级数据类型</strong></p>\n<p>不同于数组的是对元素类型不做要求，可以套结构体</p>\n<pre><code class=\"cpp\">array&lt;string, 2&gt; s = {&quot;ha&quot;, string(&quot;haha&quot;)};\narray&lt;node, 2&gt; a;</code></pre>\n<hr>\n<h3 id=\"11-3-存取元素\"><a href=\"#11-3-存取元素\" class=\"headerlink\" title=\"11.3 存取元素\"></a>11.3 存取元素</h3><ul>\n<li>修改元素</li>\n</ul>\n<pre><code class=\"cpp\">array&lt;int, 4&gt; a = {1, 2, 3, 4};\na[0] = 4;</code></pre>\n<ul>\n<li>访问元素</li>\n</ul>\n<p>下标访问</p>\n<pre><code class=\"cpp\">array&lt;int, 4&gt; a = {1, 2, 3, 4};\nfor(int i = 0; i &lt; 4; i++) \n    cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];</code></pre>\n<p>利用<code>auto</code>访问</p>\n<pre><code class=\"cpp\">for(auto i : a)\n    cout &lt;&lt; i &lt;&lt; &quot; &quot;;</code></pre>\n<p>迭代器访问</p>\n<pre><code class=\"cpp\">auto it = a.begin();\nfor(; it != a.end(); it++) \n    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</code></pre>\n<p> <code>at()</code>函数访问</p>\n<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>\n<pre><code class=\"cpp\">array&lt;int, 4&gt; a = {1, 2, 3, 4};\nint res = a.at(1) + a.at(2);\ncout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;</code></pre>\n<p> <code>get</code>方法访问</p>\n<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>\n<p>注意：获取的下标只能写数字，不能填变量</p>\n<pre><code class=\"cpp\">get&lt;1&gt;(a) = x;</code></pre>\n<hr>\n<h3 id=\"11-4-成员函数\"><a href=\"#11-4-成员函数\" class=\"headerlink\" title=\"11.4 成员函数\"></a>11.4 成员函数</h3><table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>begin()</code></td>\n<td>返回容器中第一个元素的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>end()</code></td>\n<td>返回容器最后一个元素之后一个位置的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>rbegin()</code></td>\n<td>返回最后一个元素的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>rend()</code></td>\n<td>返回第一个元素之前一个位置的访问迭代器（地址）</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数<code>N</code></td>\n</tr>\n<tr>\n<td><code>max_size()</code></td>\n<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>\n</tr>\n<tr>\n<td><code>empty()</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>at(n)</code></td>\n<td>返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td>\n</tr>\n<tr>\n<td><code>front()</code></td>\n<td>返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td>\n</tr>\n<tr>\n<td><code>back()</code></td>\n<td>返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td>\n</tr>\n<tr>\n<td><code>data()</code></td>\n<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td>\n</tr>\n<tr>\n<td><code>fill(x)</code></td>\n<td>将 <code>x</code> 这个值赋值给容器中的每个元素,相当于初始化</td>\n</tr>\n<tr>\n<td><code>array1.swap(array2)</code></td>\n<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"11-5-部分用法示例\"><a href=\"#11-5-部分用法示例\" class=\"headerlink\" title=\"11.5 部分用法示例\"></a>11.5 部分用法示例</h3><p><code>data()</code></p>\n<p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p>\n<p><code>at()</code></p>\n<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>\n<pre><code class=\"cpp\">array&lt;int, 4&gt; a = {1, 2, 3, 4};\nint res = a.at(1) + a.at(2);\ncout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;</code></pre>\n<p><code>fill()</code></p>\n<p>array的<code>fill()</code>函数，将<code>a</code>数组全部元素值变为<code>x</code></p>\n<pre><code class=\"cpp\">a.fill(x);</code></pre>\n<p>另外还有其它的<code>fill()</code>函数:将<code>a</code>数组$[begin,end)$全部值变为<code>x</code></p>\n<pre><code class=\"cpp\">fill(a.begin(), a.end(), x);</code></pre>\n<p><strong>get方法获取元素值</strong></p>\n<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>\n<p>注意:获取的下标只能写数字，不能填变量</p>\n<pre><code class=\"cpp\">get&lt;1&gt;(a) = x;</code></pre>\n<p><strong>排序</strong></p>\n<pre><code class=\"cpp\">sort(a.begin(), a.end());</code></pre>\n<hr>\n<h2 id=\"12-tuple\"><a href=\"#12-tuple\" class=\"headerlink\" title=\"12 tuple\"></a>12 tuple</h2><h3 id=\"12-1-介绍\"><a href=\"#12-1-介绍\" class=\"headerlink\" title=\"12.1 介绍\"></a>12.1 介绍</h3><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p>\n<p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p>\n<p>tuple可以等价为<strong>结构体</strong>使用</p>\n<p><strong>头文件</strong></p>\n<pre><code class=\"cpp\">#include &lt;tuple&gt;</code></pre>\n<h3 id=\"12-2-声明初始化\"><a href=\"#12-2-声明初始化\" class=\"headerlink\" title=\"12.2 声明初始化\"></a>12.2 声明初始化</h3><p>声明一个空的<code>tuple</code>三元组</p>\n<pre><code class=\"cpp\">tuple&lt;int, int, string&gt; t1;</code></pre>\n<p>赋值</p>\n<pre><code class=\"cpp\">t1 = make_tuple(1, 1, &quot;hahaha&quot;);</code></pre>\n<p>创建的同时初始化</p>\n<pre><code class=\"cpp\">tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);</code></pre>\n<p>可以使用pair对象构造tuple对象，但tuple对象必须是两个元素</p>\n<pre><code class=\"cpp\">auto p = make_pair(&quot;wang&quot;, 1);\ntuple&lt;string, int&gt; t3 {p}; //将pair对象赋给tuple对象</code></pre>\n<h3 id=\"12-3-元素操作\"><a href=\"#12-3-元素操作\" class=\"headerlink\" title=\"12.3 元素操作\"></a>12.3 元素操作</h3><p>获取tuple对象<code>t</code>的第一个元素</p>\n<pre><code class=\"cpp\">int first = get&lt;0&gt;(t);</code></pre>\n<p>修改tuple对象<code>t</code>的第一个元素</p>\n<pre><code class=\"cpp\">get&lt;0&gt;(t) = 1;</code></pre>\n<h3 id=\"12-4-函数操作\"><a href=\"#12-4-函数操作\" class=\"headerlink\" title=\"12.4 函数操作\"></a>12.4 函数操作</h3><ul>\n<li>获取元素个数</li>\n</ul>\n<pre><code class=\"cpp\">tuple&lt;int, int, int&gt; t(1, 2, 3);\ncout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3</code></pre>\n<ul>\n<li>获取对应元素的值</li>\n</ul>\n<p>通过<code>get&lt;n&gt;(obj)</code>方法获取,<code>n</code>必须为数字不能是变量</p>\n<pre><code class=\"cpp\">tuple&lt;int, int, int&gt; t(1, 2, 3);\ncout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; &#39;\\n&#39;; // 1\ncout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; &#39;\\n&#39;; // 2\ncout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; &#39;\\n&#39;; // 3</code></pre>\n<ul>\n<li>通过<code>tie</code>解包 获取元素值</li>\n</ul>\n<p><code>tie</code>可以让tuple变量中的三个值依次赋到tie中的三个变量中</p>\n<pre><code class=\"cpp\">int one, three;\nstring two; \ntuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);\ntie(one, two, three) = t;\ncout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3</code></pre>\n<hr>\n<h1 id=\"STL函数\"><a href=\"#STL函数\" class=\"headerlink\" title=\"STL函数\"></a>STL函数</h1><h2 id=\"accumulate\"><a href=\"#accumulate\" class=\"headerlink\" title=\"accumulate\"></a>accumulate</h2><pre><code>accumulate(beg, end, init)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>作用：对一个序列的元素求和</p>\n</blockquote>\n<p><code>init</code>为对序列元素求和的<strong>初始值</strong></p>\n<p>返回值类型：与<code>init</code></p>\n<ul>\n<li><strong>基础累加求和：</strong></li>\n</ul>\n<pre><code class=\"cpp\">int a[]={1,3,5,9,10};\n\n//对[0,2]区间求和，初始值为0，结果为0+1+3+5=9\nint res1 = accumulate(a, a + 3, 0);\n\n//对[0,3]区间求和，初始值为5，结果为5+1+3+5+9=23\nint res2 = accumulate(a, a + 4, 5);</code></pre>\n<ul>\n<li><strong>自定义二元对象求和：</strong></li>\n</ul>\n<p>使用<strong>lamda表达式</strong></p>\n<pre><code class=\"cpp\">typedef long long ll;\nstruct node\n{\n    ll num;\n}st[10];\n\nfor(int i = 1; i &lt;= n; i++)\n    st[i].num = i + 10000000000;\n//返回值类型与init一致，同时注意参数类型（a）也要一样\n//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007\nll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b){\n    return a + b.num;\n});\n</code></pre>\n<h2 id=\"atoi\"><a href=\"#atoi\" class=\"headerlink\" title=\"atoi\"></a>atoi</h2><pre><code>atoi(const char *)</code></pre><blockquote>\n<p>将字符串转换为<code>int</code>类型</p>\n</blockquote>\n<p>注意参数为<code>char</code>型数组，如果需要将string类型转换为int类型，可以使用<code>stoi</code>函数（参考下文），或者将<code>string</code>类型转换为<code>const char *</code>类型。</p>\n<p>关于输出数字的范围：<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p>\n<pre><code class=\"cpp\">string s = &quot;1234&quot;;\nint a = atoi(s.c_str());\ncout &lt;&lt; a &lt;&lt; &quot;\\n&quot;; // 1234</code></pre>\n<p>或者</p>\n<pre><code class=\"cpp\">char s[] = &quot;1234&quot;;\nint a = atoi(s);\ncout &lt;&lt; a &lt;&lt; &quot;\\n&quot;;</code></pre>\n<h2 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h2><pre><code>fill(beg,end,num)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>对一个序列进行初始化赋值</p>\n</blockquote>\n<pre><code class=\"cpp\">//对a数组的所有元素赋1\nint a[5];\nfill(a,a+5,1);\nfor(int i=0;i&lt;5;i++)\n    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n//1 1 1 1 1</code></pre>\n<p>注意区分memset：</p>\n<p><code>memset()</code>是按<strong>字节</strong>进行赋值，对于初始化赋<code>0</code>或<code>-1</code>有比较好的效果.</p>\n<p>如果赋某个特定的数会<strong>出错</strong>，赋值特定的数建议使用<code>fill()</code></p>\n<h2 id=\"is-sorted\"><a href=\"#is-sorted\" class=\"headerlink\" title=\"is_sorted\"></a>is_sorted</h2><pre><code>is_sorted(beg,end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>判断序列是否有序（升序），返回<code>bool</code>值</p>\n</blockquote>\n<pre><code class=\"cpp\">//如果序列有序，输出YES\nif(is_sorted(a,a+n))\n    cout&lt;&lt;&quot;YES\\n&quot;;</code></pre>\n<h2 id=\"iota\"><a href=\"#iota\" class=\"headerlink\" title=\"iota\"></a>iota</h2><pre><code>iota(beg, end)</code></pre><blockquote>\n<p>让序列递增赋值</p>\n</blockquote>\n<pre><code class=\"cpp\">vector&lt;int&gt; a(10);\niota(a.begin(), a.end(), 0);\nfor(auto i : a)\n    cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n// 0 1 2 3 4 5 6 7 8 9</code></pre>\n<h2 id=\"lower-bound-upper-bound\"><a href=\"#lower-bound-upper-bound\" class=\"headerlink\" title=\"lower_bound + upper_bound\"></a>lower_bound + upper_bound</h2><p><strong>复杂度：</strong> $O(logN)$</p>\n<blockquote>\n<p>作用：二分查找</p>\n</blockquote>\n<pre><code class=\"cpp\">//在a数组中查找第一个大于等于x的元素，返回该元素的地址\nlower_bound(a, a + n, x);\n//在a数组中查找第一个大于x的元素，返回该元素的地址\nupper_bound(a, a + n, x);\n\n//如果未找到，返回尾地址的下一个位置的地址</code></pre>\n<h2 id=\"max-element-min-element\"><a href=\"#max-element-min-element\" class=\"headerlink\" title=\"max_element+min_element\"></a>max_element+min_element</h2><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>找最大最小值</p>\n</blockquote>\n<pre><code class=\"cpp\">//函数都是返回地址，需要加*取值\nint mx = *max_element(a, a + n);\nint mn = *min_element(a, a + n);</code></pre>\n<h2 id=\"max-min\"><a href=\"#max-min\" class=\"headerlink\" title=\"max+min\"></a>max+min</h2><p><strong>复杂度：</strong> $O(1)$</p>\n<blockquote>\n<p>找多个元素的最大值和最小值</p>\n</blockquote>\n<pre><code class=\"cpp\">//找a，b的最大值和最小值\nmx = max(a, b);\nmn = min(a, b);</code></pre>\n<pre><code class=\"cpp\">//找到a,b,c,d的最大值和最小值\nmx = max({a, b, c, d});\nmn = min({a, b, c, d});</code></pre>\n<h2 id=\"minmax\"><a href=\"#minmax\" class=\"headerlink\" title=\"minmax\"></a>minmax</h2><pre><code>minmax(a, b)</code></pre><p><strong>复杂度：</strong> $O(1)$</p>\n<blockquote>\n<p>返回一个<code>pair</code>类型，第一个元素是<code>min(a, b)</code>， 第二个元素是<code>max(a, b)</code></p>\n</blockquote>\n<pre><code class=\"cpp\">pair&lt;int, int&gt; t = minmax(4, 2);\n// t.first = 2, t.second = 4</code></pre>\n<h2 id=\"minmax-element\"><a href=\"#minmax-element\" class=\"headerlink\" title=\"minmax_element\"></a>minmax_element</h2><pre><code>minmax_element(beg, end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>返回序列中的最小和最大值组成pair的对应的地址，返回类型为<code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p>\n</blockquote>\n<pre><code class=\"cpp\">int n = 10;\nvector&lt;int&gt; a(n);\niota(a.begin(), a.end(), 1);\nauto t = minmax_element(a.begin(), a.end()); // 返回的是最小值和最大值对应的地址\n// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针</code></pre>\n<h2 id=\"nth-element\"><a href=\"#nth-element\" class=\"headerlink\" title=\"nth_element\"></a>nth_element</h2><pre><code>nth_element(beg, nth, end)</code></pre><p><strong>复杂度：</strong> 平均$O(N)$</p>\n<blockquote>\n<p>寻找第序列第n小的值</p>\n</blockquote>\n<p><code>nth</code>为一个迭代器，指向序列中的一个元素。第n小的值恰好在<code>nth</code>位置上。</p>\n<p>执行<code>nth_element()</code>之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p>\n<p><strong>实例：求序列中的第3小的元素</strong></p>\n<pre><code class=\"cpp\">nth_element(a, a + 2, a + n);\ncout &lt;&lt; a[2] &lt;&lt; &#39;\\n&#39;;</code></pre>\n<h2 id=\"next-permutation\"><a href=\"#next-permutation\" class=\"headerlink\" title=\"next_permutation\"></a>next_permutation</h2><pre><code>next_permutation(beg, end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>求序列的下一个排列，下一个排列是字典序大一号的排列</p>\n</blockquote>\n<p>返回<code>true</code>或<code>false</code></p>\n<ul>\n<li><p><code>next_permutation(beg,end)</code></p>\n<p>如果是最后一个排列，返回<code>false</code>,否则求出下一个序列后，返回<code>true</code></p>\n</li>\n</ul>\n<pre><code class=\"cpp\">//对a序列进行重排\nnext_permutation(a, a + n);</code></pre>\n<p><strong>应用：求所有的排列</strong></p>\n<p>输出<code>a</code>的所有排列</p>\n<pre><code class=\"cpp\">//数组a不一定是最小字典序序列，所以将它排序\nsort(a, a + n);\ndo\n{\n     for(int i = 0; i &lt; n; i++)\n        printf(&quot;%d &quot;, a[i]);\n}while(next_permutation(a, a + n));</code></pre>\n<ul>\n<li><code>prev_permutation(beg,end)</code></li>\n</ul>\n<blockquote>\n<p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false</p>\n</blockquote>\n<h2 id=\"partial-sort\"><a href=\"#partial-sort\" class=\"headerlink\" title=\"partial_sort\"></a>partial_sort</h2><pre><code>partial_sort(beg, mid, end)</code></pre><p><strong>复杂度：</strong> 大概$O(N logM)$ <code>M</code>为距离</p>\n<blockquote>\n<p>部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置</p>\n<p>从beg到mid<strong>前</strong>的元素都排好序</p>\n</blockquote>\n<p>对a数组前5个元素排序按从小到大排序</p>\n<pre><code class=\"cpp\">int a[] = {1,2,5,4,7,9,8,10,6,3};\npartial_sort(a, a + 5, a + 10);\nfor(int i = 0; i &lt; 10; i++) \n    cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n//1 2 3 4 5 9 8 10 7 6\n//前五个元素都有序</code></pre>\n<p>也可以添加自定义排序规则：</p>\n<p> <code>partial_sort(beg,mid,end,cmp)</code></p>\n<p>对a的前五个元素都是降序排列</p>\n<pre><code class=\"cpp\">int a[] = {1,2,5,4,7,9,8,10,6,3};\npartial_sort(a, a + 5, a + 10, greater&lt;int&gt;());\nfor(int i = 0; i &lt; 10; i++) \n    cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;\n//10 9 8 7 6 1 2 4 5 3\n//前五个元素降序有序</code></pre>\n<h2 id=\"random-shuffle\"><a href=\"#random-shuffle\" class=\"headerlink\" title=\"random_shuffle\"></a>random_shuffle</h2><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<ol>\n<li>随机打乱序列的顺序</li>\n<li>在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11之后应尽量使用<code>shuffle</code>来代替。</li>\n</ol>\n</blockquote>\n<pre><code class=\"cpp\">vector&lt;int&gt; b(n);\niota(b.begin(), b.end(), 1);// 序列b递增赋值 1, 2, 3, 4,...\n//对a数组随机重排\nrandom_shuffle(a, a + n);\n// C++11之后尽量使用shuffle\nshuffle(b.begin(), b.end());</code></pre>\n<h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h2><pre><code>reverse(beg,end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>对序列进行翻转</p>\n</blockquote>\n<pre><code class=\"cpp\">string s = &quot;abcde&quot;;\nreverse(s.begin(), s.end());//对s进行翻转\ncout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;//edcba\n\n//对a数组进行翻转\nint a[] = {1, 2, 3, 4};\nreverse(a, a + 4);\ncout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];//4321</code></pre>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><p><strong>复杂度：</strong> $O(N logN)$</p>\n<blockquote>\n<p>作用：对一个序列进行排序</p>\n</blockquote>\n<pre><code class=\"cpp\">//原型：\nsort(beg, end);\nsort(beg, end, cmp);</code></pre>\n<pre><code class=\"cpp\">//对a数组的[1,n]位置进行从小到大排序\nsort(a + 1, a + 1 + n);\n\n//对a数组的[0,n-1]位置从大到小排序\nsort(a, a + n, greater&lt;int&gt;());\n//对a数组的[0,n-1]位置从小到大排序\nsort(a, a + n, less&lt;int&gt;());\n\n//自定义排序，定义比较函数\nbool cmp(node a,node b)\n{\n    //按结构体里面的x值降序排列\n    return a.x &gt; b.x;\n}\nsort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</code></pre>\n<h2 id=\"stable-sort\"><a href=\"#stable-sort\" class=\"headerlink\" title=\"stable_sort\"></a>stable_sort</h2><p><strong>复杂度：</strong> $O(N logN)$</p>\n<blockquote>\n<p>功能和sort()基本一样</p>\n<p>区别在于<code>stable_sort()</code>能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置</p>\n</blockquote>\n<p>使用用法和<code>sort()</code>一样,见上</p>\n<h2 id=\"stoi\"><a href=\"#stoi\" class=\"headerlink\" title=\"stoi\"></a>stoi</h2><pre><code>stoi(const string*)</code></pre><blockquote>\n<p>将对应string类型字符串转换为数字</p>\n</blockquote>\n<p>注意参数为<code>string</code>字符串类型。</p>\n<p>关于输出数字的范围：<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。</p>\n<pre><code class=\"cpp\">string s = &quot;1234&quot;;\nint a = atoi(s);\ncout &lt;&lt; a &lt;&lt; &quot;\\n&quot;; // 1234</code></pre>\n<h2 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h2><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>作用：使用给定操作，将结果写到dest中</p>\n</blockquote>\n<pre><code class=\"cpp\">//原型：\ntransform(beg, end, dest, unaryOp);</code></pre>\n<pre><code class=\"cpp\">//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中\ntransform(beg, end, dest, ::tolower);\ntransform(beg, end, dest, ::toupper);</code></pre>\n<h2 id=\"to-string\"><a href=\"#to-string\" class=\"headerlink\" title=\"to_string\"></a>to_string</h2><blockquote>\n<p>将数字转化为字符串,支持小数（double）</p>\n</blockquote>\n<pre><code class=\"cpp\">int a = 12345678;\ncout &lt;&lt; to_string(a) &lt;&lt; &#39;\\n&#39;;</code></pre>\n<h2 id=\"unique\"><a href=\"#unique\" class=\"headerlink\" title=\"unique\"></a>unique</h2><pre><code>unique(beg, end)</code></pre><p><strong>复杂度：</strong> $O(N)$</p>\n<blockquote>\n<p>消除重复元素，返回消除完重复元素的下一个位置的地址</p>\n<p>如：<code>a[] = {1,2,3,3,4 }</code>;</p>\n<p>unique之后a数组为<code>{1,2,3,4,3}</code>前面为无重复元素的数组，后面则是重复元素移到后面，返回<code>a[4]</code>位置的地址（不重复元素的尾后地址）</p>\n</blockquote>\n<p>消除重复元素一般需要原序列是<strong>有序序列</strong></p>\n<p><strong>运用：离散化</strong></p>\n<pre><code class=\"cpp\">for(int i = 0; i &lt; n; i++)\n{\n    cin &gt;&gt; a[i];\n    b[i] = a[i];//将a数组复制到b数组\n}\nsort(b, b + n);//对b数组排序\nunique(b, b + n);//消除b重复元素\nfor(int i = 0; i &lt; n; i++)\n{\n    //因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）\n    int pos = lower_bound(b, b + n, a[i]) - b;//在b数组中二分查找第一个大于等于a[i]的下标\n    a[i] = pos;//赋值\n}</code></pre>\n<h2 id=\"gcd\"><a href=\"#gcd\" class=\"headerlink\" title=\"__gcd\"></a>__gcd</h2><pre><code>__gcd(a,b)</code></pre><blockquote>\n<p>求a和b的最大公约数</p>\n</blockquote>\n<p><code>__gcd(12,15) = 3</code></p>\n<p><code>__gcd(21,0) = 21</code></p>\n<h2 id=\"lg\"><a href=\"#lg\" class=\"headerlink\" title=\"__lg\"></a>__lg</h2><pre><code>__lg(a)</code></pre><blockquote>\n<ol>\n<li>求一个数二进制下最高位位于第几位（从<strong>第0位</strong>开始）（或二进制数下有几位）</li>\n<li><code>__lg(x)</code>相当于返回$\\lfloor log_2 x \\rfloor$</li>\n<li>复杂度$O(1)$</li>\n</ol>\n</blockquote>\n<p><code>__lg(8) = 3</code></p>\n<p><code>__lg(15) = 3</code></p>\n<h2 id=\"builtin-内置位运算函数\"><a href=\"#builtin-内置位运算函数\" class=\"headerlink\" title=\"__builtin_ 内置位运算函数\"></a>__builtin_ 内置位运算函数</h2><p>内置函数有相应的<code>unsigned lnt</code>和<code>unsigned long long</code>版本，<code>unsigned long long</code>只需要在函数名后面加上<code>ll</code>就可以了，比如<code>__builtin_clzll(x)</code>,默认是32位<code>unsigned int</code></p>\n<h3 id=\"builtin-ffs\"><a href=\"#builtin-ffs\" class=\"headerlink\" title=\"__builtin_ffs\"></a>__builtin_ffs</h3><pre><code>__builtin_ffs(x)</code></pre><blockquote>\n<p>二进制中对应最后一位<code>1</code>的位数，比如<code>4</code>会返回<code>3</code>（100）</p>\n</blockquote>\n<h3 id=\"builtin-popcount\"><a href=\"#builtin-popcount\" class=\"headerlink\" title=\"__builtin_popcount\"></a>__builtin_popcount</h3><pre><code>__builtin_popcount(x)</code></pre><blockquote>\n<p><code>x</code>中<code>1</code>的个数</p>\n</blockquote>\n<h3 id=\"builtin-ctz\"><a href=\"#builtin-ctz\" class=\"headerlink\" title=\"__builtin_ctz\"></a>__builtin_ctz</h3><pre><code>__builtin_ctz(x)</code></pre><blockquote>\n<p><code>x</code>末尾<code>0</code>的个数（<code>count tail zero</code>）</p>\n</blockquote>\n<h3 id=\"builtin-clz\"><a href=\"#builtin-clz\" class=\"headerlink\" title=\"__builtin_clz\"></a>__builtin_clz</h3><pre><code>__builtin_clz(x)</code></pre><blockquote>\n<p><code>x</code>前导<code>0</code>的个数（<code>count leading zero</code>）</p>\n</blockquote>\n<pre><code class=\"cpp\">cout &lt;&lt; __builtin_clz(32); // 26\n//因为共有6位,默认数据范围为32位，32 - 6 = 26</code></pre>\n<h3 id=\"builtin-parity\"><a href=\"#builtin-parity\" class=\"headerlink\" title=\"__builtin_parity\"></a>__builtin_parity</h3><pre><code>__builtin_parity(x)</code></pre><blockquote>\n<p><code>x</code>中1的个数的奇偶性， 奇数输出<code>1</code>，偶数输出<code>0</code></p>\n</blockquote>\n<blockquote>\n<p>可参考链接：</p>\n<ol>\n<li><a href=\"https://www.luogu.com.cn/blog/AccRobin/grammar-candies\" target=\"_blank\" rel=\"noopener\">C++语法糖</a> <a href=\"https://www.luogu.com.cn/blog/AccRobin/grammar-candies\" target=\"_blank\" rel=\"noopener\">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li>\n</ol>\n</blockquote>\n<p>可能有些人需要PDF文件，公众号【行码棋】回复 STL 获取，抱歉😭</p>\n<p><img src=\"https://wyqz.top/medias/gzh.jpg\" alt></p>\n"},{"title":"机器学习基础知识总结","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":808139430,"date":"2022-12-27T09:04:31.000Z","password":null,"summary":null,"_content":"\n# 机器学习基础概念知识总结\n\n# 机器学习环境搭建\n\n- 一般使用anaconda搭建python虚拟环境（miniconda占的空间应该小一点，这个也可以）\n- 使用工具库一般有科学计算库numpy，数据处理库pandas，绘图matplotlib等，需要了解相关用法\n\n- ......\n\n# 线性回归 Linear Regression\n\n## 1 概述\n\n线性回归类似高中的**线性规划**题目。线性回归要做的是就是找到一个数学公式能相对较完美地把所有自变量组合（加减乘除）起来，得到的结果和目标接近。\n\n线性回归分为一元线性回归和多元线性回归。\n\n## 2 一元线性回归\n\n### 2.1 构造回归方程\n\n有n组数据，自变量（特征值） $x(x_1,x_2,...,x_n)$ 与因变量（目标值） $y(y_1,y_2,...,y_n)$ ，我们需要找到一个线性关系，使他们之间尽可能满足： $f(x) =ax+b$ ，这个就是构建的一元线性方程。\n\n![一元线性回归](808139430/1.jpg)\n\n线性回归的目标就是让 $f(X)$ 与 $y$ 之间的差距最小，也就是权重$a$和偏置$b$取什么值的时候$f(X)$和$y$最接近。\n\n### 2.2 构造损失函数\n\n损失函数是来度量模型预测值与真实值不一样的程度的，或者说度量预测错误的程度，损失函数值越小，模型就越好。\n\n在回归问题中，误差平方和是回归任务中最常用的性能度量。这里就可以令损失函数$L(a,b)$等于误差平方和。\n\n则损失函数为: $L(a, b) = \\sum \\limits_{i = 1}^{n}(f(x_i) - y_i)^2$\n\n### 2.3 确定参数\n\n我们需要通过最小的损失函数得到最佳的参数 $a$ 和 $b$ 。一般使用**最小二乘法**。\n$$\na = \\frac{\\sum \\limits_{i=1}^{n}x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^{n}x_i^2 - n \\overline x ^ 2}\n\\\\\\\nb = \\overline y - a \\overline x\n$$\n\n\n## 3 多元线性回归\n\n多元线性回归类似一元\n\n回归方程： $y = a_1 x_1 + a_2 x_2 + a_3 x_3 + ... + a_n x_n + b$\n\n对所有的数据统一用矩阵形式表示：\n$$\ny^{(i)} = \\theta ^ T x ^ {(i)} + \\varepsilon^{(i)} \\ (1)\n$$\n\n> $\\varepsilon$ 误差代表真实值和预测值之间的差异\n>\n> 误差 $\\varepsilon ^{(i)}$ 是独立并具有相同的分布，服从均值为 0 方差为 $\\theta ^ 2$ 的高斯分布\n\n损失函数：$L(a_1, a_2, ..., a_n, b) = \\sum_{i = 1}^{n}(f(x_i) - y_i)^2$\n\n高斯分布的概率函数：\n$$\np(x) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{x^2}{2 \\sigma ^ 2})} \\  (2)\n$$\n将`(1)`带入`(2)`得到**预测值成为真实值的概率**函数： \n$$\np(y ^ {(i)} | x ^ {(i)}; \\theta) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}\n$$\n似然函数：（什么样的参数计算出来的误差最小，即与实际值最接近）\n$$\nL(\\theta) = \\prod \\limits_{i = 1}^{m} p(y ^ {(i)} | x ^ {(i)}; \\theta) = \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}\n$$\n对数似然法：（将乘法转化为加法），之后需要用极大似然估计方法求解\n$$\nln L(\\theta) = ln \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}\n$$\n展开化简：\n$$\nln L(\\theta) = \\sum \\limits_{i = 1}^{m}ln \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})} \n\\\\\\\n= mln \\frac{1}{\\sqrt {2 \\pi} \\sigma} - \\frac{1}{\\sigma^2} \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2\n$$\n\n目标：让似然函数越大越好（极大似然估计），即让$J(\\theta)$越小越好（可以使用**最小二乘法**求解）\n$$\nJ(\\theta) = \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2\n$$\n![最小二乘法分析](808139430/image-20221227173603912.png)\n\n![评估方法](808139430/image-20221227173755095.png)\n\n## 4 梯度下降\n\n梯度下降法（gradient descent）是一种常用的一阶（first-order）优化方法。主要解决求最小值问题，其基本思想在于不断地逼近最优点，每一步的优化方向就是梯度的方向。\n\n### 4.1 梯度下降方法\n\n- 批量梯度下降\n\n容易得到最优解，但是由于每次考虑所有样本，速度很慢。\n\n- 随机梯度下降\n\n每次找一个样本，迭代速度很快，但不一定每次都朝着收敛的方向。\n\n- 小批量梯度下降\n\n每次更新一小部分数据来算，因为在整个训练集上算梯度资源消耗太大，我们可以随机采取$b$个样本$i_1, i_2, \\cdots, i_b$来近似损失，$e$是损失函数，$b$是批量大小。\n$$\n\\frac{1}{b} \\sum \\limits_{i \\in I_b} \\mathcal{e}(\\mathbf{x_i}, y_i, \\mathbf{w})\n$$\n\n\n### 4.2 其他参数\n\n- 学习率：更新的步长\n\n![学习率的影响](808139430/image-20221228161134519.png)\n\n- 批处理数量\n\n一般`batch_size`选择32，64，128等，有时候会考虑内存和效率。\n\n# 逻辑回归\n\n逻辑回归是一个经典的二分类算法。\n\n## 1 sigmoid函数\n\n$$\ng(z) = \\frac{1}{1 + e ^ {-z}}, z \\in R\n$$\n\n![sigmoid函数图像](808139430/image-20221228161724190.png)\n\n> 将任意的输入映射到了$[0, 1]$区间中，在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就可以完成由值到概率的转换，这就是分类任务。\n\n## 2 逻辑回归求解\n\n预测函数：\n$$\nh_{\\theta}(x) = g(\\theta ^ T x) = \\frac{1}{1 + e ^ {-\\theta^T x}} \\\\\\\n其中 \\theta_0 + \\theta_1 x_1 + ... + \\theta_n x_n = \\sum \\limits_{i = 1}^n \\theta_i x_i = \\theta ^ T x\n$$\n分类任务：\n$$\n\\begin{cases}\nP(y = 1|x; \\theta) = h_\\theta(x) \\\\\\\nP(y = 0|x; \\theta) = 1 - h_\\theta(x)\n\\end{cases}\n\\Rightarrow\nP(y | x; \\theta) = (h_\\theta(x)) ^ y (1 - h_\\theta(x)) ^ {1 - y}\n$$\n对于二分类任务（0， 1），整合后，`y`取0只保留$(1 - h_\\theta(x)) ^ {1 - y}$ ，`y`取1只保留 $(h_\\theta(x)) ^ y$ 。\n\n似然函数：\n$$\nL(\\theta) = \\prod \\limits_{i = 1}^m P(y_i | x_i; \\theta) = \\prod \\limits_{i = 1}^m (h_\\theta(x_i)) ^ y_i (1 - h_\\theta(x_i)) ^ {1 - y_i}\n$$\n对数似然法，即求$l(\\theta)$ 的最大值：\n$$\nl(\\theta) = logL(\\theta) = \\sum \\limits_{i = 1} ^m (y_i log h_\\theta(x_i) + (1 - y_i) log (1 - h_\\theta(x_i)))\n$$\n将上述函数转化为求最小值，同时系数乘上一个常数，即求$J(\\theta) = -\\frac{1}{m}l(\\theta)$ 的最小值，转化为梯度下降问题：\n$$\nJ(\\theta) = -\\frac{1}{m}l(\\theta)\n$$\n![求导过程](808139430/image-20221228164952743.png)\n\n上述过程即求出了偏导的方向，有了更新方向就可以进行参数更新： $\\alpha$代表学习率\n$$\n\\theta_j = \\theta_j - \\alpha \\frac{1}{m} \\sum \\limits_{i = 1} ^ m (h_\\theta(x_i) - y_i)x_i^j\n$$\n\n> 减法是代表用的梯度下降，整体除以`m`是考虑了所有的m个样本。\n\n多分类问题：\n\n![多分类](808139430/image-20221228171310763.png)\n\n> Softmax回归是逻辑回归的一般化，相关对比参考 https://zhuanlan.zhihu.com/p/98061179\n\n# 模型评估标准\n\n## 1 回归模型评估\n\n### 1.1 平均绝对误差（Mean Absolute Error，MAE）\n\n平均绝对误差就是指预测值与真实值之间平均相差多大\n$$\nMAE = \\frac{1}{m}\\sum \\limits _{i = 1}^m \\lvert f_i - y_i \\rvert\n$$\n\n### 1.2 均方误差（Mean Squared Error，MSE）\n\n观测值与真值偏差的平方和与观测次数的比值\n$$\nMSE = \\frac{1}{m} \\sum \\limits_{i = 1}^m(f_i - y_i)^2\n$$\n这也是线性回归中最常用的损失函数，线性回归过程中尽量让该损失函数最小。那么模型之间的对比也可以用它来比较。\n\nMSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。\n\n### 1.3 R-square（决定系数）\n\n$$\nR^2 = 1 - \\frac{\\sum(Y_{actual} - Y_{predict})^2}{\\sum(Y_{actual} - Y_{mean})^2}\n$$\n\n### 1.4 Adjusted R-Square（校正决定系数）\n\n$$\nR^2_{adjusted} = 1 - \\frac{(1 - R^2)(n - 1)}{n - p - 1}\n$$\n\n\n\nn为样本数量，p为特征数量\n\n消除了样本数量和特征数量的影响\n\n### 1.5 交叉验证\n\n我们有一个总的数据集，将总数据集切分，例如，将数据分为训练集（80%）和测试集（20%），训练集用来训练model，测试集用来最终的测试。\n\n训练集还再平均进行切分为3份（标号为1、2、3）。\n\n> 测试集和训练集的比例自己定。\n\n交叉验证就是在训练集中，采用2份数据来训练，用另一份数据来验证训练出的模型的参数，进行3次。\n\n即：1 + 2来训练，3验证；2 + 3来训练，1来验证；1 + 3来训练，2来验证。\n\n为了让模型的评估效果比较好，最后将3次的参数取平均值。\n\n> 无论分类还是回归模型，都可以利用交叉验证，进行模型评估\n>\n> sklearn模块中有交叉验证函数，例如`sklearn.cross_validation` 中的 `train_testsplit` 函数\n\n交叉验证主要是为了防止某一部分数据比较简单，导致模型的效果比较高。\n\n## 2 分类模型评估\n\n### 2.1 准确率、精确率、召回率、f1_score\n\n- 准确率（Accuracy）的定义是：对于给定的测试集，分类模型正确分类的样本数与总样本数之比；\n\n- 精确率（Precision）的定义是：对于给定测试集的某一个类别，分类模型预测正确的比例，或者说：分类模型预测的正样本中有多少是真正的正样本；\n\n- 召回率（Recall）的定义为：对于给定测试集的某一个类别，样本中的正类有多少被分类模型预测正确；\n\n  > 假设有1000个人，其中990个人正常，有10个人患有癌症，模型旨在预测哪些人是患有癌症的。\n  >\n  > 如果模型预测1000个人中都是正常的，没有癌症患者，那么可以说模型的精度是$\\frac{990}{1000}=0.99$。虽然精度很高，但是都是正样本，没有负样本，模型是无用的，因为一个患者都没有找到。因此无法用精度来评估模型，而是使用recall召回率来评估。\n\n- F1_score，在理想情况下，我们希望模型的精确率越高越好，同时召回率也越高越高，但是，现实情况往往事与愿违，在现实情况下，精确率和召回率像是坐在跷跷板上一样，往往出现一个值升高，另一个值降低，那么，有没有一个指标来综合考虑精确率和召回率了，这个指标就是F值。F值的计算公式为：\n  $$\n  F = \\frac{(a ^ 2 + 1) \\times P \\times R}{a ^ 2 \\times (P + R)}\n  $$\n\n  > P: Precision， R: Recall, a：权重因子\n  >\n  > 当a=1时，F值便是F1值，代表精确率和召回率的权重是一样的，是最常用的一种评价指标。\n  >\n  > F1的计算公式为：$F1 = \\frac{2 \\times P \\times R}{P + R}$\n\n### 2.2 混淆矩阵\n\n混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。\n\n具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。\n\n下面是一个混淆矩阵，`Actual`代表真实值，`Predicted`代表预测值，预测的是标签号（因为是分类任务，主要对标签进行分类）。\n\n> 下面是我对TP、TN、FP、FN四个值的理解（助记）\n>\n> TP：预测正确，预测成1\n>\n> TN：预测正确，预测成0\n>\n> FP：预测错误，预测成1\n>\n> FN：预测错误，预测成0\n\n![混淆矩阵](808139430/image-20221230142020907.png)\n\n可以通过上面四个值计算相应的评估值，见下图。\n\n![混淆矩阵计算评估指标](808139430/image-20221230143921870.png)\n\n# 回归模型相关技巧\n\n## 1 下采样和上采样\n\n在分类问题的数据中，很容易出现正反数据集数量存在极大的差距，这类数据直接用于训练不利于模型的构架，所以我们需要对数据进行些许处理。\n\n很容易想到，合理的数据集应该是正反数据集数量应接近，那就存在两种策略：\n\n下采样策略：把数量多的减少到与数量少的相近\n\n上（过）采样策略：把数量少的增加到与数量多的相近\n\n- 下采样：\n\n![img](808139430/2.png)\n\n- 上采样：SMOTE算法\n\n**步骤：**\n\n（1）对于少数类中每一个样本x，以**欧氏距离（两点之间距离）**为标准计算它到少数类样本集中所有样本的距离，得到其`k`近邻（所有距离排序后前`k`小的距离）\n\n（2）根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn\n\n（3）对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本。\n$$\nx_{new} = x + rand(0, 1) \\times (\\widetilde x - x)\n$$\n\n> $(\\widetilde x - x)$ 相当于距离 $d_i$ （欧几里得距离），那么每个 $d_i$ 都可以生成一个新的数据。\n\n![SMOTE算法原理图](808139430/image-20221230161807567.png)\n\n## 2 正则化惩罚\n\n加上了正则化项能在一定程度上避免过拟合\n\n# 决策树\n\n## 1 概述\n\n### 1.1 定义\n\n决策树是一种解决分类问题的算法，决策树算法采用树形结构，使用层层推理来实现最终的分类。\n\n决策树即可以做分类，也可以做回归。它主要分为两种：**分类树** 和 **回归树**。\n\n### 1.2 决策树算法\n\n- 第一个决策树算法: CLS （Concept Learning System）\n- 使决策树受到关注、成为机器学习主流技术的算法: ID3\n- 最常用的决策树算法: C4.5\n- 可以用于回归任务的决策树算法: CART （Classification and Regression Tree）\n- 基于决策树的最强大算法: RF （Random Forest）\n\n### 1.3 结构\n\n决策树由下面几种元素构成：\n\n- 根节点：包含样本的全集（全部训练数据）\n- 内部节点：对应特征属性测试\n- 叶节点：代表决策的结果\n\n![决策树结构](808139430/image-20221230164038527.png)\n\n决策树学习的**目的**是为了产生一棵泛化能力强的决策树\n\n## 2 决策树构建\n\n### 2.1 构建过程\n\n整体策略：自上而下分而治之\n\n决策树的构建过程就是一个**自根至叶的递归过程**， 在每个中间结点寻找一个**划分**属性。\n\n大致过程：\n\n- 开始：构建根节点，所有训练数据都放在根节点，选择x个最优特征，按着这一特征将训练数据集分割成子集，进入子节点。\n- 所有子集按内部节点的属性递归地进行分割。\n- 如果这些子集已经能够被基本正确分类，那么构建叶节点，并将这些子集分到所对应的叶节点去。\n- 每个子集都被分到叶节点上，即都有了明确的类，这样就生成了一颗决策树。\n\n递归的三种停止条件：\n\n- 当前结点包含的样本全属于同一类别，无需划分；\n- 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分;\n- 当前结点包含的样本集合为空，不能划分。\n\n### 2.2 特征选择\n\n**信息熵**：随机变量的不确定性。\n$$\nH(X) = - \\sum p_i log_2 p_i \\hspace{2em} \\text{i = 1, 2, ..., n}\n$$\n\n> 例：\n>\n> A集合 $[1, 1, 1, 1, 1, 1, 1, 1, 2, 2]$\n>\n> B集合$[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]$\n>\n> A集合熵值低于B集合熵值，因为A集合中只有两种类别，B集合中类别比较多（结构比较乱），熵值就会比较大\n\n**信息增益：** 表示特征X使得类Y的不确定性减少的程度（熵值减少），即当前划分对信息熵所造成的变化。\n\n信息增益越大，表示特征a来划分所减少的熵最大，即提升最大，应当作为根节点。\n\n## 3 决策树算法\n\n### 3.1 ID3（信息增益）\n\n下面是基于信息增益的ID3算法的实例：\n\n我们有14天的数据，4个特征条件：**天气，温度，湿度，是否有风**。最终结果是去玩不玩。\n\n![数据](808139430/image-20221231110826312.png)\n\n![划分方式](808139430/image-20221231110929844.png)\n\n上面有四种划分方式，我们需要判断谁来当根节点，根据的主要就是信息增益这个指标。下面计算信息增益来判断根节点。\n\n本例暂且以`ent(a, b)`代表以下含义：（只有两种结果的时候的熵值计算）\n\n```python\nfrom math import log2\ndef ent(a, b):\n    tot = a + b\n    x, y = a / tot, b / tot\n    return -(x * log2(x) + y * log2(y))\n```\n\n总的数据中，9天玩，5天不玩，熵值为：\n$$\n-\\frac{9}{14}log_2 \\frac{9}{14} - \\frac{5}{14}log_2 \\frac{5}{14} = 0.940\n$$\n然后对4个特征逐个分析：\n\n- outlook\n\n  - `outlook = sunny`时，熵值为0.971，取值为sunny的概率为 $\\frac{5}{14}$\n  - `outlook = overcast`时，熵值为0，取值为overcast的概率为 $\\frac{4}{14}$\n  - `outlook = rainy`时，熵值为0.971，取值为rainy的概率为 $\\frac{5}{14}$\n\n  熵值为：\n  $$\n  \\frac{5}{14} \\times 0.971 + \\frac{4}{14} \\times 0 + \\frac{5}{14} \\times 0.971 = 0.693\n  $$\n  信息增益：系统熵值从0.940下降到0.693，增益为0.247。\n\n- temperture\n\n  - `temperture = hot`时，熵值为1.0（`ent(2, 2)`），取值为hot的概率为$\\frac{4}{14}$\n  - `temperture = mild`时，熵值为0.918（`ent(4, 2)`），取值为mild的概率为$\\frac{6}{14}$\n  - `temperture = cool`时，熵值为0.81（`ent(3,1)`），取值为cool的概率为$\\frac{4}{14}$\n\n  熵值为：\n  $$\n  \\frac{4}{14} \\times 1.0 + \\frac{6}{14} \\times 0.918 + \\frac{4}{14} \\times 0.81 = 0.911\n  $$\n  信息增益：$Gain(S, temperture) = 0.940 - 0.911 = 0.029$\n\n- 其他特征按照相同方法来做得到：\n\n$$\nGain(S，Outlook)=0.247  \\\\\nGain(S, Humidity)=0.151  \\\\\nGain(S, Wind)=0 .048 \\\\\nGain(S,Temperature)=0 .029\n$$\n\n\n\n计算出所有的信息增益之后，选择**有最大的信息增益的特征**作为根节点。\n\n下面找Sunny分支的决策树划分：\n\n总的熵值\n$$\n-\\frac{2}{5} \\times log_2(\\frac{2}{5}) - \\frac{3}{5}log_2(\\frac{3}{5}) = 0.97\n$$\n以剩下的三个特征进行分析：\n\n- temperture\n\n  - temperture=hot，熵值为0，概率为$\\frac{2}{5}$\n  - temperture=mild，熵值为1.0，概率为$\\frac{2}{5}$\n  - temperture=cool，熵值为0，概率为$\\frac{1}{5}$\n\n  熵值为$\\frac{2}{5}$\n\n  信息增益：$0.97-0.4 = 0.57$\n\n- humidy\n\n  - high，熵值为0，概率为$\\frac{3}{5}$\n  - normal，熵值为1，概率为$\\frac{2}{5}$\n\n  熵值为$\\frac{2}{5}$\n\n  信息增益：$0.97 - 0.4 = 0.57$\n\n- windy\n\n  - false，熵值为0.918，概率为$\\frac{3}{5}$\n  - true，熵值为1，概率为$\\frac{2}{5}$\n\n  熵值为$0.951$\n\n  信息增益：$0.97 - 0.95 = 0.02$\n\n故选择humidy或wind划分\n\n剩下的划分同理，最终决策树为\n\n![最终决策树](808139430/image-20230208111655893.png)\n\n### 3.2 C4.5（信息增益率）\n\n> 基于信息增益的决策树算法会有哪些问题：\n>\n> 如果有一个特征：id，代表样本的编号，以上述数据为例，id为从1到14，如果计算id特征的根节点，发现信息增益是最大的，因为每一个子节点的信息熵值都为0。\n\n信息增益率：（解决了ID3的问题，考虑自身熵，信息增益除以自身熵）\n$$\n\\frac{G}{H(x)} \\hspace{2em} \\text{G:信息增益, H(x):熵值}\n$$\n\n### 3.3 CART（GINI系数） \n\n使用基尼系数作为衡量标准。\n$$\nGini(p) = \\sum \\limits _{k = 1}^K p_k (1 - p_k) = 1 - \\sum \\limits _{k = 1}^K p_k^2\n$$\n\n\n## 3 决策树剪枝\n\n### 3.1 预剪枝\n\n在建立决策树边的时候进行剪枝的操作，比较使用实用。\n\n剪枝策略：\n\n- 限制深度\n- 限制叶子结点个数\n- 限制叶子结点样本数\n- 限制信息增益量等。\n\n### 3.2 后剪枝\n\n建立完决策树后进行剪枝操作。\n\n## 4 连续值和缺失值处理\n\n- 连续值属性可取数值不是有限的，不能根据连续树形的可取值对节点进行划分。常见做法是：**二分法**对其进行离散化。\n\n- 现实应用中，经常会遇到属性值`缺失`现象仅使用无缺失的样例，这是对数据的极大浪费使用带缺失值的样例，需解决：\n\n  - 如何进行划分属性选择?\n  - 给定划分属性，若样本在该属性上的值缺失，如何进行划分?\n\n  基本思路：**样本赋权，权重划分**\n\n# 集成算法\n\n## 1 概述\n\n集成算法：Ensemble Learning\n\nBagging：训练多个分类器取平均 \n$$\nf(x) = \\frac{1}{M} \\sum \\limits_{m = 1}^M f_m(x)\n$$\nBoosting：从弱学习器开始加强，通过加权来训练。\n$$\nF_m(x) = F_{m - 1}(x) + argmin_h \\sum \\limits_{i = 1}^n L(y_i, F_{m - 1}(x_i) + h(x_i))\n$$\nStacking：聚合多个分类或回归模型。\n\n## 2 Bagging模型-随机森林\n\n其实就是并行训练一堆分类器（每个分类器互相独立）。典型代表为随机森林（多个决策树并行放在一起）。\n\n> 随机指的是：数据随机采样，特征随机选择\n>\n> 每个分类器喂的数据随机，数据的特征数随机。二重随机性，会让每个树基本都不一样，最终的结果也不一样。\n\n随机森林优势：\n\n- 可以处理高维度（feature多）数据，不用做特征选择\n- 训练完之后，可以给出那些feature比较重要\n- 容易做成并行化方法，速度快\n- 可以进行可视化展示，便于分析\n\n## 3 Boosting模型\n\n提升模型典型代表：AdaBoost，XgBoost\n\nAdaBoost：会根据前一次的分类效果调整数据权重\n\n## 4 Stacking模型\n\n堆叠模型：可以堆叠各种各样的分类器（KNN，SVM，RF等）\n\n分阶段进行：第一阶段得出各自的结果，第二阶段再利用前一阶段结果进行训练。\n\n# 贝叶斯算法\n\n贝叶斯公式：\n$$\nP(A | B) = \\frac{P(B|A)P(A)}{P(B)}\n$$\n\n## 1.1 实例：拼写纠正\n\n用户输入一个不在词典中的单词，需要猜测用户真正想输入的单词。\n\n我们要求的是`P(我们猜测用户想输入的单词|用户实际输入的单词)`\n\n假设用户实际输入的单词为`D`（Data）\n\n我们有多个猜测：`P(h1 | D), P(h2 | D)`， 方便后续计算，统一为`P(h | D)`\n$$\nP(h | D) = \\frac{P(h) P(D | h)}{P(D)}\n$$\n\n> $P(h)$为单词在语料库中出现的概率（出现次数 / 总次数），我们叫做**先验概率**，这个概率可以算出来。\n>\n> $P(D|h)$ 为我们将一个正确的词输入错误的概率。\n\n对于所有的猜测，$P(D)$ 都是一样的，所以可以忽略这个常数。\n\n则\n$$\nP(h|D) \\varpropto P(h)P(D|h)\n$$\n\n>$P(D|h)$可以根据某种指标来判定，可以看键盘上字母的编辑距离来算概率等等。\n\n如果计算出来多个结果预测概率是一样的，那么就可以使用**先验概率**来进行判断谁最优先。\n\n## 1.2 拼写检查器实现\n\n原理：\n$$\nargmaxc \\ P(A|B) = argmaxc \\  \\frac{P(B|A) P(A)}{P(B)}\n$$\n\n\n\n\n$P(A|B)$：待求值，用户本想输入B的前提下，错输成A的概率\n\n$P(A)$：文章中出现正确单词A的概率\n\n$P(B|A)$：用户本想输入A的前提下，错输成B的概率\n\n$P(B)$：文章中出现正确单词B的概率\n\n$argmaxc$：用来枚举所有可能的A，并选取概率最大的那个\n\n拼写检查器就是，输入一个单词，先判断这个单词是否存在于语料库中（是否正确），如果不在（可能语料库中没有，或者拼写错误），则需要根据编辑距离进行检查修正。\n\n`big.txt`文件：https://wwwi.lanzouo.com/i9s8t0ju5qzg\n\n```python\nimport re, collections\n\n#  将所有大写字母转化为小写，并且去掉特殊字符\ndef words(text): return re.findall('[a-z]+', text.lower())\n\ndef train(features):\n    # 遇到从来没有见过的新词但语料库中未包含，概率模型中希望返回一个很小的概率，故出现次数设置为1\n    model = collections.defaultdict(lambda: 1)\n    for f in features:\n        model[f] += 1\n    return model\n\n\nNWORDS = train(words(open('big.txt').read()))  # 词频\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n# 编辑距离为1的单词\ndef edits1(word):\n    n = len(word)\n    return set([word[0: i] + word[i + 1:] for i in range(n)] +   # deletion\n               [word[0: i] + word[i + 1] + word[i] + word[i + 2:] for i in range(n - 1)] +  # transportation\n               [word[0: i] + c + word[i + 1: ] for i in range(n) for c in alphabet] +  # alteration\n               [word[0: i] + c + word[i: ] for i in range(n + 1) for c in alphabet])  # insertion\n\n\n# 编辑距离为2 的单词\ndef edits2(word):\n    return set(e2 for e1 in edits1(word) for e2 in edits1(e1))\n\n\n# 将那些正确的词作为候选词\ndef known(words):\n    return set(w for w in words if w in NWORDS)\n\n\n# 检查器函数，先判断是不是正确的拼写形式，如果不是则选出编辑距离为1的单词……\ndef correct(word):\n    candidates = known([word]) or known(edits1(word)) or known(edits2(word)) or [word]\n    return max(candidates, key=lambda w: NWORDS[w])\n\n\nprint(correct('mach'))\n```\n\n## 1.3 新闻分类\n\n之后用到了再补，短时间不会写。\n\n# SVM支持向量机\n\n## 1 概述\n\nSupport Vector Machine是一种二分类模型，它的基本模型是定义在特征空间上的**间隔最大的线性分类器**\n\nSVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $wx+b=0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。\n\n![支持向量机](808139430/image-20230102144808362.png)\n\n## 2 推导\n\n### 2.1 距离\n\n正常三维条件下点$(x_0, y_0, z_0)$到平面$Ax + By + Cz + D = 0$的距离公式（高中知识）：\n$$\n\\frac{\\vert Ax_0 + By_0 + Cz_0 + D \\vert}{\\sqrt{A^2 + B^2 + C^2}}\n$$\n推导分析过程：\n\n平面方程： $ax + by + cz = d$ ，平面外一点$P(x_0, y_0, z_0)$\n\n![示意图](808139430/image-20230102153203878.png)\n\nPQ垂直平面，即为求PQ的长度，但不知Q点的具体数据。\n\n故构造一个平面上的点$P^{'}(x_1, y_1, z_1)$，问题即转化为求$\\overrightarrow {P^{'}P}$ 在法向量N上面的分量，即$\\overrightarrow {P^{'}P}$ 与N相同方向的单位向量的点积。\n\n![示意图](808139430/image-20230102153230935.png)\n\n设距离为D。\n\n![距离公式推导](808139430/1203675-20180109152428254-718844217.png)\n\n现在考虑一般情况：\n\n求平面外一点 $x$ 到平面$w^T x + b = 0$ 的距离：\n\n> 结论：平面$Ax + By + Cz + D = 0$的法向量为$(A, B, C)$\n\n![示意图](808139430/image-20230102154354917.png)\n\n同上述原理：\n\n距离就为\n$$\ndistance(x, b, w) = \\vert \\frac{w^T}{\\vert w \\vert}(x - x^{'}) \\vert = \\frac{1}{\\vert w \\vert} \\vert w^Tx + b \\vert\n$$\n\n> 上述公式进行了代入，将$x^{'}$代入平面方程得$w^Tx^{'} = -b$\n\n### 2.2 数据\n\n数据集：$(x_1, y_1)(x_2, y_2)...(x_n, y_n)$\n\n$Y$ 为样本的类别：当$X$ 为正例时，$Y = +1$，当$X$为负例时，$Y = -1$\n\n决策方程：$y(x) = w^T \\Phi(x) + b$ （其中$\\Phi(x)$是对数据做了变换）\n$$\n\\begin{cases}\ny(x_i) > 0 \\Leftrightarrow y_i = +1 \\\\\\\ny(x_i) < 0 \\Leftrightarrow y_i = -1\n\\end{cases}\n\\Longrightarrow\ny_i y(x_i) > 0\n$$\n\n### 2.3 目标函数求解\n\n将点到直线距离进行转化（化简）：\n$$\n\\frac{y_i \\cdot (w^T \\cdot \\Phi(x) + b)}{\\vert w \\vert}\n$$\n\n> $y_i y(x_i) > 0$ 直接乘上$y_i$ 将绝对值去掉，$|y_i| = 1$，并不影响值大小\n\n放缩变换：对于决策方程（w, b）可以通过放缩变换是的其结果值$|Y| \\geq 1$ ，则\n$$\ny_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1\n$$\n\n> 缩放之前w和b有无数组解，缩放之后w和b只有一组解。\n\n优化目标：\n$$\n\\mathop{arg\\  max} \\limits_{w, b} \\bigg\\{ \\frac{1}{|w|} \\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b)\\Big \\} \\bigg\\}\n$$\n\n> $\\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\Big \\}$ 是求所有样本点到平面的最小距离的那个点\n>\n> $arg\\ max$ 是**最大化到平面最小距离的点的距离**\n>\n> 由于$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$， 故最小值为1，只需要考虑 $\\mathop{arg\\  max} \\limits_{w, b} \\frac{1}{|w|}$\n\n当前目标变为：$\\mathop{max} \\limits_{w, b} \\frac{1}{|w|}$，即求$|w|$的最小值，但有约束条件 $y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$\n\n将求极大值转化为求极小值的问题，求$\\frac{1}{2}w^2$ 的最小值。\n\n需要使用**拉格朗日乘子法**：（此处不做证明，直接给出结论，我还不知道$\\alpha$的作用，呜呜呜）\n$$\nL(w, b, \\alpha) = \\frac{1}{2}|w|^2 - \\sum \\limits_{i = 1}^n \\alpha_i (y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) - 1)\n$$\n\n> 上式需要满足约束条件：$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$\n\n![求解过程](808139430/image-20230102224841617.png)\n\n![求解过程](808139430/image-20230102225344026.png)\n\n![求解过程](808139430/image-20230102225422893.png)\n\n## 3 SVM实例\n\n有三个数据：3个点，正例$x_1(3, 3), x_2(4, 3)$， 负例$x_3(1, 1)$，（数据是二维数据）对其进行二分类。\n\n首先需要求解下式的最小值：\n$$\n\\frac{1}{2}\\sum \\limits_{i = 1}^n \\sum \\limits _{j = 1}^n \\alpha_i \\alpha_j y_i y_j (x_i \\cdot x_j) - \\sum \\limits_{i = 1}^n\\alpha_i \\hspace{3em} (1)\n$$\n\n> 注意：$x_i \\cdot x_j$ 的运算是点积运算。\n>\n> 约束条件：\n> $$\n> \\alpha_1 + \\alpha_2 - \\alpha_3 = 0 \\\\\\\n> \\alpha_i \\geq 0, \\hspace{2em} i = 1, 2, 3\n> $$\n\n![图像示意](808139430/image-20230103144319179.png)\n\n将对应的数据带入（1）式，得：\n$$\n\\frac{1}{2} \\Big( 18 \\alpha_1^2 + 25\\alpha_2^2 + 2 \\alpha_3^2 + 42\\alpha_1\\alpha_2 - 12\\alpha_1\\alpha_3 - 14\\alpha_2\\alpha_3 \\Big) - \\alpha_1 - \\alpha_2 - \\alpha_3\n$$\n由于$\\alpha_1 + \\alpha_2 = \\alpha_3$，化简得：\n$$\n4 \\alpha_1 ^ 2 + \\frac{13}{2} \\alpha_2^2 + 10\\alpha_1\\alpha_2 - 2\\alpha_1 - 2\\alpha_2\n$$\n分别对$\\alpha_1,\\alpha_2$求偏导，偏导等于0得\n$$\n\\begin{cases}\n\\alpha_1 = 1.5 \\\\\\\n\\alpha_2 = -1\n\\end{cases}\n$$\n发现不满足约束条件$\\alpha_i \\geq 0$，故解应在边界上。分别让两个值等于0求解\n$$\n\\begin{cases}\n\\alpha_1 = 0 \\\\\\\n\\alpha_2 = -\\frac{2}{13}\n\\end{cases}\n(\\times)\n\\hspace{4em}\n\\begin{cases}\n\\alpha_1 = 0.25 \\\\\\\n\\alpha_2 = 0\n\\end{cases}\n(\\checkmark)\n$$\n第一组解不满足，故最小值在$(0.25, 0.25)$处取得。\n\n将$\\alpha$结果带求解$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$，$\\Phi(x_i)$以$x_i$来代替\n$$\nw = \\frac{1}{4} \\times 1 \\times (3,3) + \\frac{1}{4} \\times (-1) \\times(1,1) = (\\frac{1}{2}, \\frac{1}{2}) \n\\\\\\\nb = y_i - \\sum \\limits_{i = 1}^n a_i y_i (x_i x_j) = 1 - (\\frac{1}{4} \\times 1 \\times 18  + \\frac{1}{4} \\times (-1) \\times 6) = -2 \n$$\n故平面方程为：\n$$\n0.5 x_1 + 0.5 x_2 - 2 = 0\n$$\n\n> 因为$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$\n>\n> 支持向量的$\\alpha$值不等于0，$\\alpha = 0$的向量不是支持向量，对最终结果没有影响。\n>\n> 支持向量就是那些对最终结果起作用的向量，也可以当做是边界上的向量。\n\n## 4 软间隔\n\n数据中有时候会有一些噪音点，如果考虑它们结果可能不会很好。\n\n为解决该问题，引入松弛因子：$y_i(w \\cdot x_i + b) \\geq 1 - \\xi_i$\n\n新的目标函数：\n$$\nmin \\frac{1}{2} |w|^2 + C \\sum \\limits _{i = 1}^n \\xi_i\n$$\n\n> C是我们需要指定的一个参数\n>\n> 当C趋近于很大时：意味着分类严格不能有错误\n>\n> 当C趋近于很小时：意味着可以由更大的错误容忍\n\n解法基本一样：\n\n![解法](808139430/image-20230103153918323.png)\n\n## 5 SVM核变换\n\n将低维不可分映射到高维，找到一种变换方法，即为$\\phi(x)$\n\n高斯核函数：\n$$\nK(X, Y) =  exp \\bigg\\{ -\\frac{||X-Y||^2}{2\\sigma^2} \\bigg\\}\n$$\n\n## 6 基于sklearn求解SVM\n\n参考 https://blog.csdn.net/weixin_42600072/article/details/88644229\n\n# K-MEANS算法\n\n## 1 概述\n\n聚类概念：这是个无监督问题（没有标签数据），目的是将相似的东西分到一组。\n\n通常使用的算法是K-MEANS算法\n\n> K-MEANS算法：\n>\n> - 需要指定簇的个数，即K值\n> - 质心：数据的均值，即向量各维取平均即可\n> - 距离的度量：常用欧几里得距离和余弦相似度（先标准化，让数据基本都是在一个比较小的范围内浮动）\n> - 优化目标：$min\\sum \\limits_{i = 1}^K \\sum \\limits_{x \\in C_i} dist(c_i, x)^2$ （对于每一个簇让每一个样本到中心点的距离越小越好，$c_i$代表中心点）\n\n## 2 K-MEANS流程\n\n假设平面上有一系列样本点，现在需要将其进行分组。\n\n选定`K=2`，即将这些数据点分成两个组别。\n\n- 随机选择两个质心（分别代表两个簇），计算所有样本点到两个质心的距离。每个样本点会计算出到两个质心的距离，那么选择最小的距离，这个样本点就归属于哪个簇。\n- 然后对于两个簇的所有样本点分别算出对应的质心（这两个质心便充当新的质心），再对所有样本点计算到两个新的质心的距离，还是选择最小的距离，那么这个样本点就归属于哪个簇。\n- 最终直到两个簇所属的样本点不在发生变化。\n\n> [K-MEANS工作流程视频参考](https://www.bilibili.com/video/BV1bt411i77G?p=101&vd_source=bb4ca29d8dfb2e3c28c10bb09f4b962e)\n\n## 3 优缺点\n\n优点：\n\n- 简单快速，适合常规数据集\n\n缺点：\n\n- K值难以确定\n- 复杂度与样本呈线性关系\n- 很难发现任意形状的簇\n- 初始的点影响很大\n\n>  [K-MEANS可视化演示](https://www.naftaliharris.com/blog/visualizing-k-means-clustering/)\n\n## 4 K-MEANS进行图像压缩\n\n```python\nfrom skimage import io\nfrom sklearn.cluster import KMeans\nimport numpy as np\n\nimage = io.imread(\"1.jpg\")\nio.imshow(image)\n# io.show()  # 显示图片\n\nrows = image.shape[0]\ncols = image.shape[1]\nprint(image.shape)\n\nimage = image.reshape(rows * cols, 3)\nkmeans = KMeans(n_clusters=128, n_init=10, max_iter=100)  # 簇128, 最大迭代次数100\nkmeans.fit(image)\n\nclusters = np.asarray(kmeans.cluster_centers_, dtype=np.uint8)\nlabels = np.asarray(kmeans.labels_, dtype=np.uint8)\nlabels = labels.reshape(rows, cols)\n\nprint(clusters.shape)\nnp.save('test.npy', clusters)\nio.imsave('compressed.jpg', labels)\n```\n\n# DBSCAN算法\n\n## 1 概述\n\nDBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种**基于密度的空间聚类算法**。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间[数据库](https://cloud.tencent.com/solution/database?from=10680)中发现任意形状的簇，DBSCAN算法将`簇`定义为密度相连的点的最大集合。\n\n核心对象：若某个点的密度达到算法设定的阈值则称其为核心点。（即`r`邻域内的点的数量不小于`minPts`）\n\n基于以上密度的定义，我们可以将样本集中的点划分为以下三类：\n\n- **核心点**：在半径r区域内，含有超过MinPts数目（最小数目）的点，称为核心点；\n- **边界点**：在半径r区域内，点的数量小于MinPts数目，但是是核心点的直接邻居；\n- **噪声点**：既不是核心点也不是边界点的点\n\n> 噪声点是不会被聚类纳入的点，边界点与核心点组成聚类的“簇”。\n\n一些概念：\n\n- **直接密度可达**：在给定一个对象集合D，如果p在q的r领域内，且**q是一个核心点对象**，则称对象p从对象q出发时是直接密度可达的\n- **密度可达**：在给定对象集合D中，如果存在一个对象链q–>e–>a–>k–>l–>p，任意相邻两个对象间都是直接密度可达的，则称对象p是对象q关于r邻域内、MinPts数目下，是密度可达的；\n- **密度相连**：如果在对象集合D中存在一个对象O，使得对象p和q都是从O关于r邻域内、MinPts数目下，是密度相连的。\n\n> 核心点能够连通（密度可达），它们构成的以r为半径的圆形邻域相互连接或重叠，这些连通的核心点及其所处的邻域内的全部点构成一个簇。\n\n## 2 原理\n\n1. DBSCAN通过检查数据集中每个点的r邻域来搜索簇，如果点p的r邻域包含多于MinPts个点，则创建一个以p为核心对象的簇；\n2. 然后， DBSCAN迭代的聚集从这些核心对象直接密度可达的对象，这个过程可能涉及一些密度可达簇的合并；\n3. 当没有新的带你添加到任何簇时，迭代过程结束。\n\n优缺点：\n\n- 优点：基于密度定义，可以对抗噪声，能处理任意形状和大小的簇\n\n- 缺点：当簇的密度变化太大时候，聚类得到的结果会不理想；对于高维问题，密度定义也是一个比较麻烦的问题。\n\n## 3 实现\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\nimport matplotlib.colors\n\n# 创建Figure\nfig = plt.figure()\n# 用来正常显示中文标签\nmatplotlib.rcParams['font.sans-serif'] = [u'SimHei']\n# 用来正常显示负号\nmatplotlib.rcParams['axes.unicode_minus'] = False\n\nX1, y1 = datasets.make_circles(n_samples=5000, factor=.6,\n                                      noise=.05)\nX2, y2 = datasets.make_blobs(n_samples=1000, n_features=2,\n                             centers=[[1.2,1.2]], cluster_std=[[.1]],random_state=9)\n\n# 原始点的分布\nax1 = fig.add_subplot(311)\nX = np.concatenate((X1, X2))\nplt.scatter(X[:, 0], X[:, 1], marker='o')\nplt.title(u'原始数据分布')\nplt.sca(ax1)\n\n# K-means聚类\nfrom sklearn.cluster import KMeans\nax2 = fig.add_subplot(312)\ny_pred = KMeans(n_clusters=3, random_state=9).fit_predict(X)\nplt.scatter(X[:, 0], X[:, 1], c=y_pred)\nplt.title(u'K-means聚类')\nplt.sca(ax2)\n\n# DBSCAN聚类\nfrom sklearn.cluster import DBSCAN\nax3 = fig.add_subplot(313)\ny_pred = DBSCAN(eps = 0.1, min_samples = 10).fit_predict(X)\nplt.scatter(X[:, 0], X[:, 1], c=y_pred)\nplt.title(u'DBSCAN聚类')\nplt.sca(ax3)\n\nplt.show()\n```\n\n# PCA主成分分析\n\nPrincipal Component Analysis：降维中最常用的一种手段\n\n## 1 基变换\n\n目标：提取最有价值的信息（基于方差）\n\n- 基概念：例如在二维坐标系中，向量（3，4）也可表示为线性组合$x(1, 0) + y(0, 1)$，而$(0,1)(1,0)$叫做二维空间的一组基。\n\n- 基变换\n\n  - 要求：基是正交的（内积/点积为0，或者说互相垂直，线性无关）\n\n  - 变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量；数据与第二个基做内积运算，结果作为第二个新的坐标分量。\n\n比如$(3,2)$映射到基的坐标：\n$$\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} \\\\\\\n-\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n\\begin{pmatrix}\n3 \\\\\\\n2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{5}{\\sqrt 2} \\\\\\\n-\\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n$$\n\n- 基变换一般公式：\n\n$$\n\\begin{pmatrix}\np_1 \\\\\\\np_2 \\\\\\\n\\vdots \\\\\\\np_n\n\\end{pmatrix}\n\\begin{pmatrix}\na_1 & a_2 & \\cdots &a_m\n\\end{pmatrix}\n=\n\\begin{pmatrix}\np_1a_1 & p_1a_2 & \\cdots & p_1a_m \\\\\\\np_2a_1 & p_2a_2 & \\cdots & p_2a_m \\\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\\\np_na_1 & p_na_2 & \\cdots & p_na_m \\\\\\\n\\end{pmatrix}\n$$\n\n> 等式左边的两个矩阵中，左边是基，右边是数据。\n>\n> 两个矩阵相乘的意义是将右边的矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。\n\n## 2 协方差矩阵\n\n我们希望选择一个方向（基）：数据能够保留更多的原始信息，也可以说希望经过某个基投影后的投影值尽可能分散。（雾\n\n方差：\n$$\nVar(a) = \\frac{1}{m} \\sum \\limits_{i = 1}^m (a_i - \\mu)^2\n$$\n寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，**方差值最大**（分散）。\n\n协方差：（假设均值为0时）（对于标签$a_i, b_i$，如果两个相似度越大，协方差越大）\n$$\nCov(a, b) = \\frac{1}{m} \\sum \\limits_{i = 1}^m a_ib_i\n$$\n\n> 如果单纯选择方差最大的方向，后续方向应该会和方差最大的方向接近重合。\n>\n> 解决方案：为了让两个子段尽可能表示更多的原始信息，我们是不希望他们之间存在（线性）相关性的。\n>\n> 可以用两个字段的协方差表示相关性，当协方差为0时，代表两个字段是相互独立的。\n\n题意：将一组N维向量降为K维，目标是选择K个单位的正交基，使原始数据变换到这组基上面后，各字段两两之间协方差为0，字段方差尽可能大。\n\n\n$$\n\\text{特征数据}X = \n\\begin{pmatrix}\na_1 & a_2 & \\cdots & a_m \\\\\\\nb_1 & b_2 & \\cdots & b_m\n\\end{pmatrix}\n$$\n协方差矩阵：\n$$\n\\frac{1}{m}XX^T = \n\\begin{pmatrix}\n\\frac{1}{m}\\sum \\limits_{i = 1}^m a_i^2  & \\frac{1}{m}\\sum \\limits_{i = 1}^ma_ib_i \\\\\\\n\\frac{1}{m}\\sum \\limits_{i = 1}^m a_ib_i & \\frac{1}{m}\\sum \\limits_{i = 1}^mb_i^2\n\\end{pmatrix}\n$$\n\n> 矩阵对角线上的两个元素分别为两个字段的方差（假设均值为0），而其他元素是a和b的协方差。\n\n## 3 优化\n\n接下来就是希望让协方差矩阵的除对角线位置的元素为0（协方差为0），就是进行对角化操作。\n\n协方差矩阵对角化：\n$$\nPCP^T = \\Lambda = \n\\begin{pmatrix}\n\\lambda_1 \\\\\\\n& \\lambda_2 \\\\\\\n& & \\ddots \\\\\\\n& & & \\lambda_n\n\\end{pmatrix}\n$$\n\n> 结论：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量\n> $$\n> E = \\begin{pmatrix} e_1 & e_2 & \\cdots & e_n\\end{pmatrix}\n> $$\n> 实对称矩阵可以进行对角化：\n> $$\n> ECE^T = \\Lambda = \n> \\begin{pmatrix}\n> \\lambda_1 \\\\\\\n> & \\lambda_2 \\\\\\\n> & & \\ddots \\\\\\\n> & & & \\lambda_n\n> \\end{pmatrix}\n> $$\n\n将特征值从大到小排列，用前K行组成的矩阵乘原始数据矩阵X，就得到降维后的数据矩阵Y。\n\n## 4 示例\n\n数据（共5个数据，每个数据2个特征点）\n$$\n\\begin{pmatrix}\n-1 & -1 & 0 & 2 & 0 \\\\\\\n-2 & 0 & 0 & 1 & 1\n\\end{pmatrix}\n$$\n协方差矩阵\n$$\nC = \\frac{1}{5}\n\\begin{pmatrix}\n-1 & -1 & 0 & 2 & 0 \\\\\\\n-2 & 0 & 0 & 1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n-1 & -2 \\\\\\\n-1 & 0 \\\\\\\n0 & 0 \\\\\\\n2 & 1 \\\\\\\n0 & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{6}{5} & \\frac{4}{5} \\\\\\\n\\frac{4}{5} & \\frac{6}{5}\n\\end{pmatrix}\n$$\n特征值\n$$\n\\lambda_1 = 2, \\lambda_2 = \\frac{2}{5}\n$$\n特征向量\n$$\nc_1\n\\begin{pmatrix}\n1 \\\\\\\n1\n\\end{pmatrix} ,\nc_2\n\\begin{pmatrix}\n-1 \\\\\\\n1\n\\end{pmatrix}\n$$\n对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量$c_1$这个\n$$\nPCP^T = \n\\begin{pmatrix}\n\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2} \\\\\\\n-\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{6}{5} & \\frac{4}{5} \\\\\\\n\\frac{4}{5} & \\frac{6}{5}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{1}{\\sqrt 2} & -\\frac{1}{\\sqrt 2} \\\\\\\n\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2 & 0 \\\\\\\n0 & \\frac{2}{5}\n\\end{pmatrix}\n$$\n降维\n$$\nY = \n\\begin{pmatrix}\n\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n\\begin{pmatrix}\n-1 & -1 & 0 & 2 & 0 \\\\\\\n-2 & 0 & 0 & 1 & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\frac{3}{\\sqrt 2} & -\\frac{1}{\\sqrt 2} & 0 & \\frac{3}{\\sqrt 2} & -\\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n$$\n\n\n\n\n\n\n\n> 机器学习实战参考：https://blog.csdn.net/weixin_42600072/category_8751294.html\n","source":"_posts/机器学习基础知识总结.md","raw":"---\ntitle: 机器学习基础知识总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 学习总结\n  - MachineLearning\ncategories:\n  - 知识总结\nabbrlink: 808139430\ndate: 2022-12-27 17:04:31\npassword:\nsummary:\n---\n\n# 机器学习基础概念知识总结\n\n# 机器学习环境搭建\n\n- 一般使用anaconda搭建python虚拟环境（miniconda占的空间应该小一点，这个也可以）\n- 使用工具库一般有科学计算库numpy，数据处理库pandas，绘图matplotlib等，需要了解相关用法\n\n- ......\n\n# 线性回归 Linear Regression\n\n## 1 概述\n\n线性回归类似高中的**线性规划**题目。线性回归要做的是就是找到一个数学公式能相对较完美地把所有自变量组合（加减乘除）起来，得到的结果和目标接近。\n\n线性回归分为一元线性回归和多元线性回归。\n\n## 2 一元线性回归\n\n### 2.1 构造回归方程\n\n有n组数据，自变量（特征值） $x(x_1,x_2,...,x_n)$ 与因变量（目标值） $y(y_1,y_2,...,y_n)$ ，我们需要找到一个线性关系，使他们之间尽可能满足： $f(x) =ax+b$ ，这个就是构建的一元线性方程。\n\n![一元线性回归](808139430/1.jpg)\n\n线性回归的目标就是让 $f(X)$ 与 $y$ 之间的差距最小，也就是权重$a$和偏置$b$取什么值的时候$f(X)$和$y$最接近。\n\n### 2.2 构造损失函数\n\n损失函数是来度量模型预测值与真实值不一样的程度的，或者说度量预测错误的程度，损失函数值越小，模型就越好。\n\n在回归问题中，误差平方和是回归任务中最常用的性能度量。这里就可以令损失函数$L(a,b)$等于误差平方和。\n\n则损失函数为: $L(a, b) = \\sum \\limits_{i = 1}^{n}(f(x_i) - y_i)^2$\n\n### 2.3 确定参数\n\n我们需要通过最小的损失函数得到最佳的参数 $a$ 和 $b$ 。一般使用**最小二乘法**。\n$$\na = \\frac{\\sum \\limits_{i=1}^{n}x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^{n}x_i^2 - n \\overline x ^ 2}\n\\\\\\\nb = \\overline y - a \\overline x\n$$\n\n\n## 3 多元线性回归\n\n多元线性回归类似一元\n\n回归方程： $y = a_1 x_1 + a_2 x_2 + a_3 x_3 + ... + a_n x_n + b$\n\n对所有的数据统一用矩阵形式表示：\n$$\ny^{(i)} = \\theta ^ T x ^ {(i)} + \\varepsilon^{(i)} \\ (1)\n$$\n\n> $\\varepsilon$ 误差代表真实值和预测值之间的差异\n>\n> 误差 $\\varepsilon ^{(i)}$ 是独立并具有相同的分布，服从均值为 0 方差为 $\\theta ^ 2$ 的高斯分布\n\n损失函数：$L(a_1, a_2, ..., a_n, b) = \\sum_{i = 1}^{n}(f(x_i) - y_i)^2$\n\n高斯分布的概率函数：\n$$\np(x) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{x^2}{2 \\sigma ^ 2})} \\  (2)\n$$\n将`(1)`带入`(2)`得到**预测值成为真实值的概率**函数： \n$$\np(y ^ {(i)} | x ^ {(i)}; \\theta) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}\n$$\n似然函数：（什么样的参数计算出来的误差最小，即与实际值最接近）\n$$\nL(\\theta) = \\prod \\limits_{i = 1}^{m} p(y ^ {(i)} | x ^ {(i)}; \\theta) = \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}\n$$\n对数似然法：（将乘法转化为加法），之后需要用极大似然估计方法求解\n$$\nln L(\\theta) = ln \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}\n$$\n展开化简：\n$$\nln L(\\theta) = \\sum \\limits_{i = 1}^{m}ln \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})} \n\\\\\\\n= mln \\frac{1}{\\sqrt {2 \\pi} \\sigma} - \\frac{1}{\\sigma^2} \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2\n$$\n\n目标：让似然函数越大越好（极大似然估计），即让$J(\\theta)$越小越好（可以使用**最小二乘法**求解）\n$$\nJ(\\theta) = \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2\n$$\n![最小二乘法分析](808139430/image-20221227173603912.png)\n\n![评估方法](808139430/image-20221227173755095.png)\n\n## 4 梯度下降\n\n梯度下降法（gradient descent）是一种常用的一阶（first-order）优化方法。主要解决求最小值问题，其基本思想在于不断地逼近最优点，每一步的优化方向就是梯度的方向。\n\n### 4.1 梯度下降方法\n\n- 批量梯度下降\n\n容易得到最优解，但是由于每次考虑所有样本，速度很慢。\n\n- 随机梯度下降\n\n每次找一个样本，迭代速度很快，但不一定每次都朝着收敛的方向。\n\n- 小批量梯度下降\n\n每次更新一小部分数据来算，因为在整个训练集上算梯度资源消耗太大，我们可以随机采取$b$个样本$i_1, i_2, \\cdots, i_b$来近似损失，$e$是损失函数，$b$是批量大小。\n$$\n\\frac{1}{b} \\sum \\limits_{i \\in I_b} \\mathcal{e}(\\mathbf{x_i}, y_i, \\mathbf{w})\n$$\n\n\n### 4.2 其他参数\n\n- 学习率：更新的步长\n\n![学习率的影响](808139430/image-20221228161134519.png)\n\n- 批处理数量\n\n一般`batch_size`选择32，64，128等，有时候会考虑内存和效率。\n\n# 逻辑回归\n\n逻辑回归是一个经典的二分类算法。\n\n## 1 sigmoid函数\n\n$$\ng(z) = \\frac{1}{1 + e ^ {-z}}, z \\in R\n$$\n\n![sigmoid函数图像](808139430/image-20221228161724190.png)\n\n> 将任意的输入映射到了$[0, 1]$区间中，在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就可以完成由值到概率的转换，这就是分类任务。\n\n## 2 逻辑回归求解\n\n预测函数：\n$$\nh_{\\theta}(x) = g(\\theta ^ T x) = \\frac{1}{1 + e ^ {-\\theta^T x}} \\\\\\\n其中 \\theta_0 + \\theta_1 x_1 + ... + \\theta_n x_n = \\sum \\limits_{i = 1}^n \\theta_i x_i = \\theta ^ T x\n$$\n分类任务：\n$$\n\\begin{cases}\nP(y = 1|x; \\theta) = h_\\theta(x) \\\\\\\nP(y = 0|x; \\theta) = 1 - h_\\theta(x)\n\\end{cases}\n\\Rightarrow\nP(y | x; \\theta) = (h_\\theta(x)) ^ y (1 - h_\\theta(x)) ^ {1 - y}\n$$\n对于二分类任务（0， 1），整合后，`y`取0只保留$(1 - h_\\theta(x)) ^ {1 - y}$ ，`y`取1只保留 $(h_\\theta(x)) ^ y$ 。\n\n似然函数：\n$$\nL(\\theta) = \\prod \\limits_{i = 1}^m P(y_i | x_i; \\theta) = \\prod \\limits_{i = 1}^m (h_\\theta(x_i)) ^ y_i (1 - h_\\theta(x_i)) ^ {1 - y_i}\n$$\n对数似然法，即求$l(\\theta)$ 的最大值：\n$$\nl(\\theta) = logL(\\theta) = \\sum \\limits_{i = 1} ^m (y_i log h_\\theta(x_i) + (1 - y_i) log (1 - h_\\theta(x_i)))\n$$\n将上述函数转化为求最小值，同时系数乘上一个常数，即求$J(\\theta) = -\\frac{1}{m}l(\\theta)$ 的最小值，转化为梯度下降问题：\n$$\nJ(\\theta) = -\\frac{1}{m}l(\\theta)\n$$\n![求导过程](808139430/image-20221228164952743.png)\n\n上述过程即求出了偏导的方向，有了更新方向就可以进行参数更新： $\\alpha$代表学习率\n$$\n\\theta_j = \\theta_j - \\alpha \\frac{1}{m} \\sum \\limits_{i = 1} ^ m (h_\\theta(x_i) - y_i)x_i^j\n$$\n\n> 减法是代表用的梯度下降，整体除以`m`是考虑了所有的m个样本。\n\n多分类问题：\n\n![多分类](808139430/image-20221228171310763.png)\n\n> Softmax回归是逻辑回归的一般化，相关对比参考 https://zhuanlan.zhihu.com/p/98061179\n\n# 模型评估标准\n\n## 1 回归模型评估\n\n### 1.1 平均绝对误差（Mean Absolute Error，MAE）\n\n平均绝对误差就是指预测值与真实值之间平均相差多大\n$$\nMAE = \\frac{1}{m}\\sum \\limits _{i = 1}^m \\lvert f_i - y_i \\rvert\n$$\n\n### 1.2 均方误差（Mean Squared Error，MSE）\n\n观测值与真值偏差的平方和与观测次数的比值\n$$\nMSE = \\frac{1}{m} \\sum \\limits_{i = 1}^m(f_i - y_i)^2\n$$\n这也是线性回归中最常用的损失函数，线性回归过程中尽量让该损失函数最小。那么模型之间的对比也可以用它来比较。\n\nMSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。\n\n### 1.3 R-square（决定系数）\n\n$$\nR^2 = 1 - \\frac{\\sum(Y_{actual} - Y_{predict})^2}{\\sum(Y_{actual} - Y_{mean})^2}\n$$\n\n### 1.4 Adjusted R-Square（校正决定系数）\n\n$$\nR^2_{adjusted} = 1 - \\frac{(1 - R^2)(n - 1)}{n - p - 1}\n$$\n\n\n\nn为样本数量，p为特征数量\n\n消除了样本数量和特征数量的影响\n\n### 1.5 交叉验证\n\n我们有一个总的数据集，将总数据集切分，例如，将数据分为训练集（80%）和测试集（20%），训练集用来训练model，测试集用来最终的测试。\n\n训练集还再平均进行切分为3份（标号为1、2、3）。\n\n> 测试集和训练集的比例自己定。\n\n交叉验证就是在训练集中，采用2份数据来训练，用另一份数据来验证训练出的模型的参数，进行3次。\n\n即：1 + 2来训练，3验证；2 + 3来训练，1来验证；1 + 3来训练，2来验证。\n\n为了让模型的评估效果比较好，最后将3次的参数取平均值。\n\n> 无论分类还是回归模型，都可以利用交叉验证，进行模型评估\n>\n> sklearn模块中有交叉验证函数，例如`sklearn.cross_validation` 中的 `train_testsplit` 函数\n\n交叉验证主要是为了防止某一部分数据比较简单，导致模型的效果比较高。\n\n## 2 分类模型评估\n\n### 2.1 准确率、精确率、召回率、f1_score\n\n- 准确率（Accuracy）的定义是：对于给定的测试集，分类模型正确分类的样本数与总样本数之比；\n\n- 精确率（Precision）的定义是：对于给定测试集的某一个类别，分类模型预测正确的比例，或者说：分类模型预测的正样本中有多少是真正的正样本；\n\n- 召回率（Recall）的定义为：对于给定测试集的某一个类别，样本中的正类有多少被分类模型预测正确；\n\n  > 假设有1000个人，其中990个人正常，有10个人患有癌症，模型旨在预测哪些人是患有癌症的。\n  >\n  > 如果模型预测1000个人中都是正常的，没有癌症患者，那么可以说模型的精度是$\\frac{990}{1000}=0.99$。虽然精度很高，但是都是正样本，没有负样本，模型是无用的，因为一个患者都没有找到。因此无法用精度来评估模型，而是使用recall召回率来评估。\n\n- F1_score，在理想情况下，我们希望模型的精确率越高越好，同时召回率也越高越高，但是，现实情况往往事与愿违，在现实情况下，精确率和召回率像是坐在跷跷板上一样，往往出现一个值升高，另一个值降低，那么，有没有一个指标来综合考虑精确率和召回率了，这个指标就是F值。F值的计算公式为：\n  $$\n  F = \\frac{(a ^ 2 + 1) \\times P \\times R}{a ^ 2 \\times (P + R)}\n  $$\n\n  > P: Precision， R: Recall, a：权重因子\n  >\n  > 当a=1时，F值便是F1值，代表精确率和召回率的权重是一样的，是最常用的一种评价指标。\n  >\n  > F1的计算公式为：$F1 = \\frac{2 \\times P \\times R}{P + R}$\n\n### 2.2 混淆矩阵\n\n混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。\n\n具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。\n\n下面是一个混淆矩阵，`Actual`代表真实值，`Predicted`代表预测值，预测的是标签号（因为是分类任务，主要对标签进行分类）。\n\n> 下面是我对TP、TN、FP、FN四个值的理解（助记）\n>\n> TP：预测正确，预测成1\n>\n> TN：预测正确，预测成0\n>\n> FP：预测错误，预测成1\n>\n> FN：预测错误，预测成0\n\n![混淆矩阵](808139430/image-20221230142020907.png)\n\n可以通过上面四个值计算相应的评估值，见下图。\n\n![混淆矩阵计算评估指标](808139430/image-20221230143921870.png)\n\n# 回归模型相关技巧\n\n## 1 下采样和上采样\n\n在分类问题的数据中，很容易出现正反数据集数量存在极大的差距，这类数据直接用于训练不利于模型的构架，所以我们需要对数据进行些许处理。\n\n很容易想到，合理的数据集应该是正反数据集数量应接近，那就存在两种策略：\n\n下采样策略：把数量多的减少到与数量少的相近\n\n上（过）采样策略：把数量少的增加到与数量多的相近\n\n- 下采样：\n\n![img](808139430/2.png)\n\n- 上采样：SMOTE算法\n\n**步骤：**\n\n（1）对于少数类中每一个样本x，以**欧氏距离（两点之间距离）**为标准计算它到少数类样本集中所有样本的距离，得到其`k`近邻（所有距离排序后前`k`小的距离）\n\n（2）根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn\n\n（3）对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本。\n$$\nx_{new} = x + rand(0, 1) \\times (\\widetilde x - x)\n$$\n\n> $(\\widetilde x - x)$ 相当于距离 $d_i$ （欧几里得距离），那么每个 $d_i$ 都可以生成一个新的数据。\n\n![SMOTE算法原理图](808139430/image-20221230161807567.png)\n\n## 2 正则化惩罚\n\n加上了正则化项能在一定程度上避免过拟合\n\n# 决策树\n\n## 1 概述\n\n### 1.1 定义\n\n决策树是一种解决分类问题的算法，决策树算法采用树形结构，使用层层推理来实现最终的分类。\n\n决策树即可以做分类，也可以做回归。它主要分为两种：**分类树** 和 **回归树**。\n\n### 1.2 决策树算法\n\n- 第一个决策树算法: CLS （Concept Learning System）\n- 使决策树受到关注、成为机器学习主流技术的算法: ID3\n- 最常用的决策树算法: C4.5\n- 可以用于回归任务的决策树算法: CART （Classification and Regression Tree）\n- 基于决策树的最强大算法: RF （Random Forest）\n\n### 1.3 结构\n\n决策树由下面几种元素构成：\n\n- 根节点：包含样本的全集（全部训练数据）\n- 内部节点：对应特征属性测试\n- 叶节点：代表决策的结果\n\n![决策树结构](808139430/image-20221230164038527.png)\n\n决策树学习的**目的**是为了产生一棵泛化能力强的决策树\n\n## 2 决策树构建\n\n### 2.1 构建过程\n\n整体策略：自上而下分而治之\n\n决策树的构建过程就是一个**自根至叶的递归过程**， 在每个中间结点寻找一个**划分**属性。\n\n大致过程：\n\n- 开始：构建根节点，所有训练数据都放在根节点，选择x个最优特征，按着这一特征将训练数据集分割成子集，进入子节点。\n- 所有子集按内部节点的属性递归地进行分割。\n- 如果这些子集已经能够被基本正确分类，那么构建叶节点，并将这些子集分到所对应的叶节点去。\n- 每个子集都被分到叶节点上，即都有了明确的类，这样就生成了一颗决策树。\n\n递归的三种停止条件：\n\n- 当前结点包含的样本全属于同一类别，无需划分；\n- 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分;\n- 当前结点包含的样本集合为空，不能划分。\n\n### 2.2 特征选择\n\n**信息熵**：随机变量的不确定性。\n$$\nH(X) = - \\sum p_i log_2 p_i \\hspace{2em} \\text{i = 1, 2, ..., n}\n$$\n\n> 例：\n>\n> A集合 $[1, 1, 1, 1, 1, 1, 1, 1, 2, 2]$\n>\n> B集合$[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]$\n>\n> A集合熵值低于B集合熵值，因为A集合中只有两种类别，B集合中类别比较多（结构比较乱），熵值就会比较大\n\n**信息增益：** 表示特征X使得类Y的不确定性减少的程度（熵值减少），即当前划分对信息熵所造成的变化。\n\n信息增益越大，表示特征a来划分所减少的熵最大，即提升最大，应当作为根节点。\n\n## 3 决策树算法\n\n### 3.1 ID3（信息增益）\n\n下面是基于信息增益的ID3算法的实例：\n\n我们有14天的数据，4个特征条件：**天气，温度，湿度，是否有风**。最终结果是去玩不玩。\n\n![数据](808139430/image-20221231110826312.png)\n\n![划分方式](808139430/image-20221231110929844.png)\n\n上面有四种划分方式，我们需要判断谁来当根节点，根据的主要就是信息增益这个指标。下面计算信息增益来判断根节点。\n\n本例暂且以`ent(a, b)`代表以下含义：（只有两种结果的时候的熵值计算）\n\n```python\nfrom math import log2\ndef ent(a, b):\n    tot = a + b\n    x, y = a / tot, b / tot\n    return -(x * log2(x) + y * log2(y))\n```\n\n总的数据中，9天玩，5天不玩，熵值为：\n$$\n-\\frac{9}{14}log_2 \\frac{9}{14} - \\frac{5}{14}log_2 \\frac{5}{14} = 0.940\n$$\n然后对4个特征逐个分析：\n\n- outlook\n\n  - `outlook = sunny`时，熵值为0.971，取值为sunny的概率为 $\\frac{5}{14}$\n  - `outlook = overcast`时，熵值为0，取值为overcast的概率为 $\\frac{4}{14}$\n  - `outlook = rainy`时，熵值为0.971，取值为rainy的概率为 $\\frac{5}{14}$\n\n  熵值为：\n  $$\n  \\frac{5}{14} \\times 0.971 + \\frac{4}{14} \\times 0 + \\frac{5}{14} \\times 0.971 = 0.693\n  $$\n  信息增益：系统熵值从0.940下降到0.693，增益为0.247。\n\n- temperture\n\n  - `temperture = hot`时，熵值为1.0（`ent(2, 2)`），取值为hot的概率为$\\frac{4}{14}$\n  - `temperture = mild`时，熵值为0.918（`ent(4, 2)`），取值为mild的概率为$\\frac{6}{14}$\n  - `temperture = cool`时，熵值为0.81（`ent(3,1)`），取值为cool的概率为$\\frac{4}{14}$\n\n  熵值为：\n  $$\n  \\frac{4}{14} \\times 1.0 + \\frac{6}{14} \\times 0.918 + \\frac{4}{14} \\times 0.81 = 0.911\n  $$\n  信息增益：$Gain(S, temperture) = 0.940 - 0.911 = 0.029$\n\n- 其他特征按照相同方法来做得到：\n\n$$\nGain(S，Outlook)=0.247  \\\\\nGain(S, Humidity)=0.151  \\\\\nGain(S, Wind)=0 .048 \\\\\nGain(S,Temperature)=0 .029\n$$\n\n\n\n计算出所有的信息增益之后，选择**有最大的信息增益的特征**作为根节点。\n\n下面找Sunny分支的决策树划分：\n\n总的熵值\n$$\n-\\frac{2}{5} \\times log_2(\\frac{2}{5}) - \\frac{3}{5}log_2(\\frac{3}{5}) = 0.97\n$$\n以剩下的三个特征进行分析：\n\n- temperture\n\n  - temperture=hot，熵值为0，概率为$\\frac{2}{5}$\n  - temperture=mild，熵值为1.0，概率为$\\frac{2}{5}$\n  - temperture=cool，熵值为0，概率为$\\frac{1}{5}$\n\n  熵值为$\\frac{2}{5}$\n\n  信息增益：$0.97-0.4 = 0.57$\n\n- humidy\n\n  - high，熵值为0，概率为$\\frac{3}{5}$\n  - normal，熵值为1，概率为$\\frac{2}{5}$\n\n  熵值为$\\frac{2}{5}$\n\n  信息增益：$0.97 - 0.4 = 0.57$\n\n- windy\n\n  - false，熵值为0.918，概率为$\\frac{3}{5}$\n  - true，熵值为1，概率为$\\frac{2}{5}$\n\n  熵值为$0.951$\n\n  信息增益：$0.97 - 0.95 = 0.02$\n\n故选择humidy或wind划分\n\n剩下的划分同理，最终决策树为\n\n![最终决策树](808139430/image-20230208111655893.png)\n\n### 3.2 C4.5（信息增益率）\n\n> 基于信息增益的决策树算法会有哪些问题：\n>\n> 如果有一个特征：id，代表样本的编号，以上述数据为例，id为从1到14，如果计算id特征的根节点，发现信息增益是最大的，因为每一个子节点的信息熵值都为0。\n\n信息增益率：（解决了ID3的问题，考虑自身熵，信息增益除以自身熵）\n$$\n\\frac{G}{H(x)} \\hspace{2em} \\text{G:信息增益, H(x):熵值}\n$$\n\n### 3.3 CART（GINI系数） \n\n使用基尼系数作为衡量标准。\n$$\nGini(p) = \\sum \\limits _{k = 1}^K p_k (1 - p_k) = 1 - \\sum \\limits _{k = 1}^K p_k^2\n$$\n\n\n## 3 决策树剪枝\n\n### 3.1 预剪枝\n\n在建立决策树边的时候进行剪枝的操作，比较使用实用。\n\n剪枝策略：\n\n- 限制深度\n- 限制叶子结点个数\n- 限制叶子结点样本数\n- 限制信息增益量等。\n\n### 3.2 后剪枝\n\n建立完决策树后进行剪枝操作。\n\n## 4 连续值和缺失值处理\n\n- 连续值属性可取数值不是有限的，不能根据连续树形的可取值对节点进行划分。常见做法是：**二分法**对其进行离散化。\n\n- 现实应用中，经常会遇到属性值`缺失`现象仅使用无缺失的样例，这是对数据的极大浪费使用带缺失值的样例，需解决：\n\n  - 如何进行划分属性选择?\n  - 给定划分属性，若样本在该属性上的值缺失，如何进行划分?\n\n  基本思路：**样本赋权，权重划分**\n\n# 集成算法\n\n## 1 概述\n\n集成算法：Ensemble Learning\n\nBagging：训练多个分类器取平均 \n$$\nf(x) = \\frac{1}{M} \\sum \\limits_{m = 1}^M f_m(x)\n$$\nBoosting：从弱学习器开始加强，通过加权来训练。\n$$\nF_m(x) = F_{m - 1}(x) + argmin_h \\sum \\limits_{i = 1}^n L(y_i, F_{m - 1}(x_i) + h(x_i))\n$$\nStacking：聚合多个分类或回归模型。\n\n## 2 Bagging模型-随机森林\n\n其实就是并行训练一堆分类器（每个分类器互相独立）。典型代表为随机森林（多个决策树并行放在一起）。\n\n> 随机指的是：数据随机采样，特征随机选择\n>\n> 每个分类器喂的数据随机，数据的特征数随机。二重随机性，会让每个树基本都不一样，最终的结果也不一样。\n\n随机森林优势：\n\n- 可以处理高维度（feature多）数据，不用做特征选择\n- 训练完之后，可以给出那些feature比较重要\n- 容易做成并行化方法，速度快\n- 可以进行可视化展示，便于分析\n\n## 3 Boosting模型\n\n提升模型典型代表：AdaBoost，XgBoost\n\nAdaBoost：会根据前一次的分类效果调整数据权重\n\n## 4 Stacking模型\n\n堆叠模型：可以堆叠各种各样的分类器（KNN，SVM，RF等）\n\n分阶段进行：第一阶段得出各自的结果，第二阶段再利用前一阶段结果进行训练。\n\n# 贝叶斯算法\n\n贝叶斯公式：\n$$\nP(A | B) = \\frac{P(B|A)P(A)}{P(B)}\n$$\n\n## 1.1 实例：拼写纠正\n\n用户输入一个不在词典中的单词，需要猜测用户真正想输入的单词。\n\n我们要求的是`P(我们猜测用户想输入的单词|用户实际输入的单词)`\n\n假设用户实际输入的单词为`D`（Data）\n\n我们有多个猜测：`P(h1 | D), P(h2 | D)`， 方便后续计算，统一为`P(h | D)`\n$$\nP(h | D) = \\frac{P(h) P(D | h)}{P(D)}\n$$\n\n> $P(h)$为单词在语料库中出现的概率（出现次数 / 总次数），我们叫做**先验概率**，这个概率可以算出来。\n>\n> $P(D|h)$ 为我们将一个正确的词输入错误的概率。\n\n对于所有的猜测，$P(D)$ 都是一样的，所以可以忽略这个常数。\n\n则\n$$\nP(h|D) \\varpropto P(h)P(D|h)\n$$\n\n>$P(D|h)$可以根据某种指标来判定，可以看键盘上字母的编辑距离来算概率等等。\n\n如果计算出来多个结果预测概率是一样的，那么就可以使用**先验概率**来进行判断谁最优先。\n\n## 1.2 拼写检查器实现\n\n原理：\n$$\nargmaxc \\ P(A|B) = argmaxc \\  \\frac{P(B|A) P(A)}{P(B)}\n$$\n\n\n\n\n$P(A|B)$：待求值，用户本想输入B的前提下，错输成A的概率\n\n$P(A)$：文章中出现正确单词A的概率\n\n$P(B|A)$：用户本想输入A的前提下，错输成B的概率\n\n$P(B)$：文章中出现正确单词B的概率\n\n$argmaxc$：用来枚举所有可能的A，并选取概率最大的那个\n\n拼写检查器就是，输入一个单词，先判断这个单词是否存在于语料库中（是否正确），如果不在（可能语料库中没有，或者拼写错误），则需要根据编辑距离进行检查修正。\n\n`big.txt`文件：https://wwwi.lanzouo.com/i9s8t0ju5qzg\n\n```python\nimport re, collections\n\n#  将所有大写字母转化为小写，并且去掉特殊字符\ndef words(text): return re.findall('[a-z]+', text.lower())\n\ndef train(features):\n    # 遇到从来没有见过的新词但语料库中未包含，概率模型中希望返回一个很小的概率，故出现次数设置为1\n    model = collections.defaultdict(lambda: 1)\n    for f in features:\n        model[f] += 1\n    return model\n\n\nNWORDS = train(words(open('big.txt').read()))  # 词频\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n# 编辑距离为1的单词\ndef edits1(word):\n    n = len(word)\n    return set([word[0: i] + word[i + 1:] for i in range(n)] +   # deletion\n               [word[0: i] + word[i + 1] + word[i] + word[i + 2:] for i in range(n - 1)] +  # transportation\n               [word[0: i] + c + word[i + 1: ] for i in range(n) for c in alphabet] +  # alteration\n               [word[0: i] + c + word[i: ] for i in range(n + 1) for c in alphabet])  # insertion\n\n\n# 编辑距离为2 的单词\ndef edits2(word):\n    return set(e2 for e1 in edits1(word) for e2 in edits1(e1))\n\n\n# 将那些正确的词作为候选词\ndef known(words):\n    return set(w for w in words if w in NWORDS)\n\n\n# 检查器函数，先判断是不是正确的拼写形式，如果不是则选出编辑距离为1的单词……\ndef correct(word):\n    candidates = known([word]) or known(edits1(word)) or known(edits2(word)) or [word]\n    return max(candidates, key=lambda w: NWORDS[w])\n\n\nprint(correct('mach'))\n```\n\n## 1.3 新闻分类\n\n之后用到了再补，短时间不会写。\n\n# SVM支持向量机\n\n## 1 概述\n\nSupport Vector Machine是一种二分类模型，它的基本模型是定义在特征空间上的**间隔最大的线性分类器**\n\nSVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $wx+b=0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。\n\n![支持向量机](808139430/image-20230102144808362.png)\n\n## 2 推导\n\n### 2.1 距离\n\n正常三维条件下点$(x_0, y_0, z_0)$到平面$Ax + By + Cz + D = 0$的距离公式（高中知识）：\n$$\n\\frac{\\vert Ax_0 + By_0 + Cz_0 + D \\vert}{\\sqrt{A^2 + B^2 + C^2}}\n$$\n推导分析过程：\n\n平面方程： $ax + by + cz = d$ ，平面外一点$P(x_0, y_0, z_0)$\n\n![示意图](808139430/image-20230102153203878.png)\n\nPQ垂直平面，即为求PQ的长度，但不知Q点的具体数据。\n\n故构造一个平面上的点$P^{'}(x_1, y_1, z_1)$，问题即转化为求$\\overrightarrow {P^{'}P}$ 在法向量N上面的分量，即$\\overrightarrow {P^{'}P}$ 与N相同方向的单位向量的点积。\n\n![示意图](808139430/image-20230102153230935.png)\n\n设距离为D。\n\n![距离公式推导](808139430/1203675-20180109152428254-718844217.png)\n\n现在考虑一般情况：\n\n求平面外一点 $x$ 到平面$w^T x + b = 0$ 的距离：\n\n> 结论：平面$Ax + By + Cz + D = 0$的法向量为$(A, B, C)$\n\n![示意图](808139430/image-20230102154354917.png)\n\n同上述原理：\n\n距离就为\n$$\ndistance(x, b, w) = \\vert \\frac{w^T}{\\vert w \\vert}(x - x^{'}) \\vert = \\frac{1}{\\vert w \\vert} \\vert w^Tx + b \\vert\n$$\n\n> 上述公式进行了代入，将$x^{'}$代入平面方程得$w^Tx^{'} = -b$\n\n### 2.2 数据\n\n数据集：$(x_1, y_1)(x_2, y_2)...(x_n, y_n)$\n\n$Y$ 为样本的类别：当$X$ 为正例时，$Y = +1$，当$X$为负例时，$Y = -1$\n\n决策方程：$y(x) = w^T \\Phi(x) + b$ （其中$\\Phi(x)$是对数据做了变换）\n$$\n\\begin{cases}\ny(x_i) > 0 \\Leftrightarrow y_i = +1 \\\\\\\ny(x_i) < 0 \\Leftrightarrow y_i = -1\n\\end{cases}\n\\Longrightarrow\ny_i y(x_i) > 0\n$$\n\n### 2.3 目标函数求解\n\n将点到直线距离进行转化（化简）：\n$$\n\\frac{y_i \\cdot (w^T \\cdot \\Phi(x) + b)}{\\vert w \\vert}\n$$\n\n> $y_i y(x_i) > 0$ 直接乘上$y_i$ 将绝对值去掉，$|y_i| = 1$，并不影响值大小\n\n放缩变换：对于决策方程（w, b）可以通过放缩变换是的其结果值$|Y| \\geq 1$ ，则\n$$\ny_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1\n$$\n\n> 缩放之前w和b有无数组解，缩放之后w和b只有一组解。\n\n优化目标：\n$$\n\\mathop{arg\\  max} \\limits_{w, b} \\bigg\\{ \\frac{1}{|w|} \\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b)\\Big \\} \\bigg\\}\n$$\n\n> $\\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\Big \\}$ 是求所有样本点到平面的最小距离的那个点\n>\n> $arg\\ max$ 是**最大化到平面最小距离的点的距离**\n>\n> 由于$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$， 故最小值为1，只需要考虑 $\\mathop{arg\\  max} \\limits_{w, b} \\frac{1}{|w|}$\n\n当前目标变为：$\\mathop{max} \\limits_{w, b} \\frac{1}{|w|}$，即求$|w|$的最小值，但有约束条件 $y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$\n\n将求极大值转化为求极小值的问题，求$\\frac{1}{2}w^2$ 的最小值。\n\n需要使用**拉格朗日乘子法**：（此处不做证明，直接给出结论，我还不知道$\\alpha$的作用，呜呜呜）\n$$\nL(w, b, \\alpha) = \\frac{1}{2}|w|^2 - \\sum \\limits_{i = 1}^n \\alpha_i (y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) - 1)\n$$\n\n> 上式需要满足约束条件：$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$\n\n![求解过程](808139430/image-20230102224841617.png)\n\n![求解过程](808139430/image-20230102225344026.png)\n\n![求解过程](808139430/image-20230102225422893.png)\n\n## 3 SVM实例\n\n有三个数据：3个点，正例$x_1(3, 3), x_2(4, 3)$， 负例$x_3(1, 1)$，（数据是二维数据）对其进行二分类。\n\n首先需要求解下式的最小值：\n$$\n\\frac{1}{2}\\sum \\limits_{i = 1}^n \\sum \\limits _{j = 1}^n \\alpha_i \\alpha_j y_i y_j (x_i \\cdot x_j) - \\sum \\limits_{i = 1}^n\\alpha_i \\hspace{3em} (1)\n$$\n\n> 注意：$x_i \\cdot x_j$ 的运算是点积运算。\n>\n> 约束条件：\n> $$\n> \\alpha_1 + \\alpha_2 - \\alpha_3 = 0 \\\\\\\n> \\alpha_i \\geq 0, \\hspace{2em} i = 1, 2, 3\n> $$\n\n![图像示意](808139430/image-20230103144319179.png)\n\n将对应的数据带入（1）式，得：\n$$\n\\frac{1}{2} \\Big( 18 \\alpha_1^2 + 25\\alpha_2^2 + 2 \\alpha_3^2 + 42\\alpha_1\\alpha_2 - 12\\alpha_1\\alpha_3 - 14\\alpha_2\\alpha_3 \\Big) - \\alpha_1 - \\alpha_2 - \\alpha_3\n$$\n由于$\\alpha_1 + \\alpha_2 = \\alpha_3$，化简得：\n$$\n4 \\alpha_1 ^ 2 + \\frac{13}{2} \\alpha_2^2 + 10\\alpha_1\\alpha_2 - 2\\alpha_1 - 2\\alpha_2\n$$\n分别对$\\alpha_1,\\alpha_2$求偏导，偏导等于0得\n$$\n\\begin{cases}\n\\alpha_1 = 1.5 \\\\\\\n\\alpha_2 = -1\n\\end{cases}\n$$\n发现不满足约束条件$\\alpha_i \\geq 0$，故解应在边界上。分别让两个值等于0求解\n$$\n\\begin{cases}\n\\alpha_1 = 0 \\\\\\\n\\alpha_2 = -\\frac{2}{13}\n\\end{cases}\n(\\times)\n\\hspace{4em}\n\\begin{cases}\n\\alpha_1 = 0.25 \\\\\\\n\\alpha_2 = 0\n\\end{cases}\n(\\checkmark)\n$$\n第一组解不满足，故最小值在$(0.25, 0.25)$处取得。\n\n将$\\alpha$结果带求解$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$，$\\Phi(x_i)$以$x_i$来代替\n$$\nw = \\frac{1}{4} \\times 1 \\times (3,3) + \\frac{1}{4} \\times (-1) \\times(1,1) = (\\frac{1}{2}, \\frac{1}{2}) \n\\\\\\\nb = y_i - \\sum \\limits_{i = 1}^n a_i y_i (x_i x_j) = 1 - (\\frac{1}{4} \\times 1 \\times 18  + \\frac{1}{4} \\times (-1) \\times 6) = -2 \n$$\n故平面方程为：\n$$\n0.5 x_1 + 0.5 x_2 - 2 = 0\n$$\n\n> 因为$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$\n>\n> 支持向量的$\\alpha$值不等于0，$\\alpha = 0$的向量不是支持向量，对最终结果没有影响。\n>\n> 支持向量就是那些对最终结果起作用的向量，也可以当做是边界上的向量。\n\n## 4 软间隔\n\n数据中有时候会有一些噪音点，如果考虑它们结果可能不会很好。\n\n为解决该问题，引入松弛因子：$y_i(w \\cdot x_i + b) \\geq 1 - \\xi_i$\n\n新的目标函数：\n$$\nmin \\frac{1}{2} |w|^2 + C \\sum \\limits _{i = 1}^n \\xi_i\n$$\n\n> C是我们需要指定的一个参数\n>\n> 当C趋近于很大时：意味着分类严格不能有错误\n>\n> 当C趋近于很小时：意味着可以由更大的错误容忍\n\n解法基本一样：\n\n![解法](808139430/image-20230103153918323.png)\n\n## 5 SVM核变换\n\n将低维不可分映射到高维，找到一种变换方法，即为$\\phi(x)$\n\n高斯核函数：\n$$\nK(X, Y) =  exp \\bigg\\{ -\\frac{||X-Y||^2}{2\\sigma^2} \\bigg\\}\n$$\n\n## 6 基于sklearn求解SVM\n\n参考 https://blog.csdn.net/weixin_42600072/article/details/88644229\n\n# K-MEANS算法\n\n## 1 概述\n\n聚类概念：这是个无监督问题（没有标签数据），目的是将相似的东西分到一组。\n\n通常使用的算法是K-MEANS算法\n\n> K-MEANS算法：\n>\n> - 需要指定簇的个数，即K值\n> - 质心：数据的均值，即向量各维取平均即可\n> - 距离的度量：常用欧几里得距离和余弦相似度（先标准化，让数据基本都是在一个比较小的范围内浮动）\n> - 优化目标：$min\\sum \\limits_{i = 1}^K \\sum \\limits_{x \\in C_i} dist(c_i, x)^2$ （对于每一个簇让每一个样本到中心点的距离越小越好，$c_i$代表中心点）\n\n## 2 K-MEANS流程\n\n假设平面上有一系列样本点，现在需要将其进行分组。\n\n选定`K=2`，即将这些数据点分成两个组别。\n\n- 随机选择两个质心（分别代表两个簇），计算所有样本点到两个质心的距离。每个样本点会计算出到两个质心的距离，那么选择最小的距离，这个样本点就归属于哪个簇。\n- 然后对于两个簇的所有样本点分别算出对应的质心（这两个质心便充当新的质心），再对所有样本点计算到两个新的质心的距离，还是选择最小的距离，那么这个样本点就归属于哪个簇。\n- 最终直到两个簇所属的样本点不在发生变化。\n\n> [K-MEANS工作流程视频参考](https://www.bilibili.com/video/BV1bt411i77G?p=101&vd_source=bb4ca29d8dfb2e3c28c10bb09f4b962e)\n\n## 3 优缺点\n\n优点：\n\n- 简单快速，适合常规数据集\n\n缺点：\n\n- K值难以确定\n- 复杂度与样本呈线性关系\n- 很难发现任意形状的簇\n- 初始的点影响很大\n\n>  [K-MEANS可视化演示](https://www.naftaliharris.com/blog/visualizing-k-means-clustering/)\n\n## 4 K-MEANS进行图像压缩\n\n```python\nfrom skimage import io\nfrom sklearn.cluster import KMeans\nimport numpy as np\n\nimage = io.imread(\"1.jpg\")\nio.imshow(image)\n# io.show()  # 显示图片\n\nrows = image.shape[0]\ncols = image.shape[1]\nprint(image.shape)\n\nimage = image.reshape(rows * cols, 3)\nkmeans = KMeans(n_clusters=128, n_init=10, max_iter=100)  # 簇128, 最大迭代次数100\nkmeans.fit(image)\n\nclusters = np.asarray(kmeans.cluster_centers_, dtype=np.uint8)\nlabels = np.asarray(kmeans.labels_, dtype=np.uint8)\nlabels = labels.reshape(rows, cols)\n\nprint(clusters.shape)\nnp.save('test.npy', clusters)\nio.imsave('compressed.jpg', labels)\n```\n\n# DBSCAN算法\n\n## 1 概述\n\nDBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种**基于密度的空间聚类算法**。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间[数据库](https://cloud.tencent.com/solution/database?from=10680)中发现任意形状的簇，DBSCAN算法将`簇`定义为密度相连的点的最大集合。\n\n核心对象：若某个点的密度达到算法设定的阈值则称其为核心点。（即`r`邻域内的点的数量不小于`minPts`）\n\n基于以上密度的定义，我们可以将样本集中的点划分为以下三类：\n\n- **核心点**：在半径r区域内，含有超过MinPts数目（最小数目）的点，称为核心点；\n- **边界点**：在半径r区域内，点的数量小于MinPts数目，但是是核心点的直接邻居；\n- **噪声点**：既不是核心点也不是边界点的点\n\n> 噪声点是不会被聚类纳入的点，边界点与核心点组成聚类的“簇”。\n\n一些概念：\n\n- **直接密度可达**：在给定一个对象集合D，如果p在q的r领域内，且**q是一个核心点对象**，则称对象p从对象q出发时是直接密度可达的\n- **密度可达**：在给定对象集合D中，如果存在一个对象链q–>e–>a–>k–>l–>p，任意相邻两个对象间都是直接密度可达的，则称对象p是对象q关于r邻域内、MinPts数目下，是密度可达的；\n- **密度相连**：如果在对象集合D中存在一个对象O，使得对象p和q都是从O关于r邻域内、MinPts数目下，是密度相连的。\n\n> 核心点能够连通（密度可达），它们构成的以r为半径的圆形邻域相互连接或重叠，这些连通的核心点及其所处的邻域内的全部点构成一个簇。\n\n## 2 原理\n\n1. DBSCAN通过检查数据集中每个点的r邻域来搜索簇，如果点p的r邻域包含多于MinPts个点，则创建一个以p为核心对象的簇；\n2. 然后， DBSCAN迭代的聚集从这些核心对象直接密度可达的对象，这个过程可能涉及一些密度可达簇的合并；\n3. 当没有新的带你添加到任何簇时，迭代过程结束。\n\n优缺点：\n\n- 优点：基于密度定义，可以对抗噪声，能处理任意形状和大小的簇\n\n- 缺点：当簇的密度变化太大时候，聚类得到的结果会不理想；对于高维问题，密度定义也是一个比较麻烦的问题。\n\n## 3 实现\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\nimport matplotlib.colors\n\n# 创建Figure\nfig = plt.figure()\n# 用来正常显示中文标签\nmatplotlib.rcParams['font.sans-serif'] = [u'SimHei']\n# 用来正常显示负号\nmatplotlib.rcParams['axes.unicode_minus'] = False\n\nX1, y1 = datasets.make_circles(n_samples=5000, factor=.6,\n                                      noise=.05)\nX2, y2 = datasets.make_blobs(n_samples=1000, n_features=2,\n                             centers=[[1.2,1.2]], cluster_std=[[.1]],random_state=9)\n\n# 原始点的分布\nax1 = fig.add_subplot(311)\nX = np.concatenate((X1, X2))\nplt.scatter(X[:, 0], X[:, 1], marker='o')\nplt.title(u'原始数据分布')\nplt.sca(ax1)\n\n# K-means聚类\nfrom sklearn.cluster import KMeans\nax2 = fig.add_subplot(312)\ny_pred = KMeans(n_clusters=3, random_state=9).fit_predict(X)\nplt.scatter(X[:, 0], X[:, 1], c=y_pred)\nplt.title(u'K-means聚类')\nplt.sca(ax2)\n\n# DBSCAN聚类\nfrom sklearn.cluster import DBSCAN\nax3 = fig.add_subplot(313)\ny_pred = DBSCAN(eps = 0.1, min_samples = 10).fit_predict(X)\nplt.scatter(X[:, 0], X[:, 1], c=y_pred)\nplt.title(u'DBSCAN聚类')\nplt.sca(ax3)\n\nplt.show()\n```\n\n# PCA主成分分析\n\nPrincipal Component Analysis：降维中最常用的一种手段\n\n## 1 基变换\n\n目标：提取最有价值的信息（基于方差）\n\n- 基概念：例如在二维坐标系中，向量（3，4）也可表示为线性组合$x(1, 0) + y(0, 1)$，而$(0,1)(1,0)$叫做二维空间的一组基。\n\n- 基变换\n\n  - 要求：基是正交的（内积/点积为0，或者说互相垂直，线性无关）\n\n  - 变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量；数据与第二个基做内积运算，结果作为第二个新的坐标分量。\n\n比如$(3,2)$映射到基的坐标：\n$$\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} \\\\\\\n-\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n\\begin{pmatrix}\n3 \\\\\\\n2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{5}{\\sqrt 2} \\\\\\\n-\\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n$$\n\n- 基变换一般公式：\n\n$$\n\\begin{pmatrix}\np_1 \\\\\\\np_2 \\\\\\\n\\vdots \\\\\\\np_n\n\\end{pmatrix}\n\\begin{pmatrix}\na_1 & a_2 & \\cdots &a_m\n\\end{pmatrix}\n=\n\\begin{pmatrix}\np_1a_1 & p_1a_2 & \\cdots & p_1a_m \\\\\\\np_2a_1 & p_2a_2 & \\cdots & p_2a_m \\\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\\\np_na_1 & p_na_2 & \\cdots & p_na_m \\\\\\\n\\end{pmatrix}\n$$\n\n> 等式左边的两个矩阵中，左边是基，右边是数据。\n>\n> 两个矩阵相乘的意义是将右边的矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。\n\n## 2 协方差矩阵\n\n我们希望选择一个方向（基）：数据能够保留更多的原始信息，也可以说希望经过某个基投影后的投影值尽可能分散。（雾\n\n方差：\n$$\nVar(a) = \\frac{1}{m} \\sum \\limits_{i = 1}^m (a_i - \\mu)^2\n$$\n寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，**方差值最大**（分散）。\n\n协方差：（假设均值为0时）（对于标签$a_i, b_i$，如果两个相似度越大，协方差越大）\n$$\nCov(a, b) = \\frac{1}{m} \\sum \\limits_{i = 1}^m a_ib_i\n$$\n\n> 如果单纯选择方差最大的方向，后续方向应该会和方差最大的方向接近重合。\n>\n> 解决方案：为了让两个子段尽可能表示更多的原始信息，我们是不希望他们之间存在（线性）相关性的。\n>\n> 可以用两个字段的协方差表示相关性，当协方差为0时，代表两个字段是相互独立的。\n\n题意：将一组N维向量降为K维，目标是选择K个单位的正交基，使原始数据变换到这组基上面后，各字段两两之间协方差为0，字段方差尽可能大。\n\n\n$$\n\\text{特征数据}X = \n\\begin{pmatrix}\na_1 & a_2 & \\cdots & a_m \\\\\\\nb_1 & b_2 & \\cdots & b_m\n\\end{pmatrix}\n$$\n协方差矩阵：\n$$\n\\frac{1}{m}XX^T = \n\\begin{pmatrix}\n\\frac{1}{m}\\sum \\limits_{i = 1}^m a_i^2  & \\frac{1}{m}\\sum \\limits_{i = 1}^ma_ib_i \\\\\\\n\\frac{1}{m}\\sum \\limits_{i = 1}^m a_ib_i & \\frac{1}{m}\\sum \\limits_{i = 1}^mb_i^2\n\\end{pmatrix}\n$$\n\n> 矩阵对角线上的两个元素分别为两个字段的方差（假设均值为0），而其他元素是a和b的协方差。\n\n## 3 优化\n\n接下来就是希望让协方差矩阵的除对角线位置的元素为0（协方差为0），就是进行对角化操作。\n\n协方差矩阵对角化：\n$$\nPCP^T = \\Lambda = \n\\begin{pmatrix}\n\\lambda_1 \\\\\\\n& \\lambda_2 \\\\\\\n& & \\ddots \\\\\\\n& & & \\lambda_n\n\\end{pmatrix}\n$$\n\n> 结论：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量\n> $$\n> E = \\begin{pmatrix} e_1 & e_2 & \\cdots & e_n\\end{pmatrix}\n> $$\n> 实对称矩阵可以进行对角化：\n> $$\n> ECE^T = \\Lambda = \n> \\begin{pmatrix}\n> \\lambda_1 \\\\\\\n> & \\lambda_2 \\\\\\\n> & & \\ddots \\\\\\\n> & & & \\lambda_n\n> \\end{pmatrix}\n> $$\n\n将特征值从大到小排列，用前K行组成的矩阵乘原始数据矩阵X，就得到降维后的数据矩阵Y。\n\n## 4 示例\n\n数据（共5个数据，每个数据2个特征点）\n$$\n\\begin{pmatrix}\n-1 & -1 & 0 & 2 & 0 \\\\\\\n-2 & 0 & 0 & 1 & 1\n\\end{pmatrix}\n$$\n协方差矩阵\n$$\nC = \\frac{1}{5}\n\\begin{pmatrix}\n-1 & -1 & 0 & 2 & 0 \\\\\\\n-2 & 0 & 0 & 1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n-1 & -2 \\\\\\\n-1 & 0 \\\\\\\n0 & 0 \\\\\\\n2 & 1 \\\\\\\n0 & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{6}{5} & \\frac{4}{5} \\\\\\\n\\frac{4}{5} & \\frac{6}{5}\n\\end{pmatrix}\n$$\n特征值\n$$\n\\lambda_1 = 2, \\lambda_2 = \\frac{2}{5}\n$$\n特征向量\n$$\nc_1\n\\begin{pmatrix}\n1 \\\\\\\n1\n\\end{pmatrix} ,\nc_2\n\\begin{pmatrix}\n-1 \\\\\\\n1\n\\end{pmatrix}\n$$\n对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量$c_1$这个\n$$\nPCP^T = \n\\begin{pmatrix}\n\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2} \\\\\\\n-\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{6}{5} & \\frac{4}{5} \\\\\\\n\\frac{4}{5} & \\frac{6}{5}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{1}{\\sqrt 2} & -\\frac{1}{\\sqrt 2} \\\\\\\n\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2 & 0 \\\\\\\n0 & \\frac{2}{5}\n\\end{pmatrix}\n$$\n降维\n$$\nY = \n\\begin{pmatrix}\n\\frac{1}{\\sqrt 2} & \\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n\\begin{pmatrix}\n-1 & -1 & 0 & 2 & 0 \\\\\\\n-2 & 0 & 0 & 1 & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\frac{3}{\\sqrt 2} & -\\frac{1}{\\sqrt 2} & 0 & \\frac{3}{\\sqrt 2} & -\\frac{1}{\\sqrt 2}\n\\end{pmatrix}\n$$\n\n\n\n\n\n\n\n> 机器学习实战参考：https://blog.csdn.net/weixin_42600072/category_8751294.html\n","slug":"机器学习基础知识总结","published":1,"updated":"2023-02-08T03:18:16.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhu001u6kuh4zkvf1ms","content":"<h1 id=\"机器学习基础概念知识总结\"><a href=\"#机器学习基础概念知识总结\" class=\"headerlink\" title=\"机器学习基础概念知识总结\"></a>机器学习基础概念知识总结</h1><h1 id=\"机器学习环境搭建\"><a href=\"#机器学习环境搭建\" class=\"headerlink\" title=\"机器学习环境搭建\"></a>机器学习环境搭建</h1><ul>\n<li><p>一般使用anaconda搭建python虚拟环境（miniconda占的空间应该小一点，这个也可以）</p>\n</li>\n<li><p>使用工具库一般有科学计算库numpy，数据处理库pandas，绘图matplotlib等，需要了解相关用法</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<h1 id=\"线性回归-Linear-Regression\"><a href=\"#线性回归-Linear-Regression\" class=\"headerlink\" title=\"线性回归 Linear Regression\"></a>线性回归 Linear Regression</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>线性回归类似高中的<strong>线性规划</strong>题目。线性回归要做的是就是找到一个数学公式能相对较完美地把所有自变量组合（加减乘除）起来，得到的结果和目标接近。</p>\n<p>线性回归分为一元线性回归和多元线性回归。</p>\n<h2 id=\"2-一元线性回归\"><a href=\"#2-一元线性回归\" class=\"headerlink\" title=\"2 一元线性回归\"></a>2 一元线性回归</h2><h3 id=\"2-1-构造回归方程\"><a href=\"#2-1-构造回归方程\" class=\"headerlink\" title=\"2.1 构造回归方程\"></a>2.1 构造回归方程</h3><p>有n组数据，自变量（特征值） $x(x_1,x_2,…,x_n)$ 与因变量（目标值） $y(y_1,y_2,…,y_n)$ ，我们需要找到一个线性关系，使他们之间尽可能满足： $f(x) =ax+b$ ，这个就是构建的一元线性方程。</p>\n<p><img src=\"808139430/1.jpg\" alt=\"一元线性回归\"></p>\n<p>线性回归的目标就是让 $f(X)$ 与 $y$ 之间的差距最小，也就是权重$a$和偏置$b$取什么值的时候$f(X)$和$y$最接近。</p>\n<h3 id=\"2-2-构造损失函数\"><a href=\"#2-2-构造损失函数\" class=\"headerlink\" title=\"2.2 构造损失函数\"></a>2.2 构造损失函数</h3><p>损失函数是来度量模型预测值与真实值不一样的程度的，或者说度量预测错误的程度，损失函数值越小，模型就越好。</p>\n<p>在回归问题中，误差平方和是回归任务中最常用的性能度量。这里就可以令损失函数$L(a,b)$等于误差平方和。</p>\n<p>则损失函数为: $L(a, b) = \\sum \\limits_{i = 1}^{n}(f(x_i) - y_i)^2$</p>\n<h3 id=\"2-3-确定参数\"><a href=\"#2-3-确定参数\" class=\"headerlink\" title=\"2.3 确定参数\"></a>2.3 确定参数</h3><p>我们需要通过最小的损失函数得到最佳的参数 $a$ 和 $b$ 。一般使用<strong>最小二乘法</strong>。<br>$$<br>a = \\frac{\\sum \\limits_{i=1}^{n}x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^{n}x_i^2 - n \\overline x ^ 2}<br>\\\\<br>b = \\overline y - a \\overline x<br>$$</p>\n<h2 id=\"3-多元线性回归\"><a href=\"#3-多元线性回归\" class=\"headerlink\" title=\"3 多元线性回归\"></a>3 多元线性回归</h2><p>多元线性回归类似一元</p>\n<p>回归方程： $y = a_1 x_1 + a_2 x_2 + a_3 x_3 + … + a_n x_n + b$</p>\n<p>对所有的数据统一用矩阵形式表示：<br>$$<br>y^{(i)} = \\theta ^ T x ^ {(i)} + \\varepsilon^{(i)} \\ (1)<br>$$</p>\n<blockquote>\n<p>$\\varepsilon$ 误差代表真实值和预测值之间的差异</p>\n<p>误差 $\\varepsilon ^{(i)}$ 是独立并具有相同的分布，服从均值为 0 方差为 $\\theta ^ 2$ 的高斯分布</p>\n</blockquote>\n<p>损失函数：$L(a_1, a_2, …, a_n, b) = \\sum_{i = 1}^{n}(f(x_i) - y_i)^2$</p>\n<p>高斯分布的概率函数：<br>$$<br>p(x) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{x^2}{2 \\sigma ^ 2})} \\  (2)<br>$$<br>将<code>(1)</code>带入<code>(2)</code>得到<strong>预测值成为真实值的概率</strong>函数：<br>$$<br>p(y ^ {(i)} | x ^ {(i)}; \\theta) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>$$<br>似然函数：（什么样的参数计算出来的误差最小，即与实际值最接近）<br>$$<br>L(\\theta) = \\prod \\limits_{i = 1}^{m} p(y ^ {(i)} | x ^ {(i)}; \\theta) = \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>$$<br>对数似然法：（将乘法转化为加法），之后需要用极大似然估计方法求解<br>$$<br>ln L(\\theta) = ln \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>$$<br>展开化简：<br>$$<br>ln L(\\theta) = \\sum \\limits_{i = 1}^{m}ln \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>\\\\<br>= mln \\frac{1}{\\sqrt {2 \\pi} \\sigma} - \\frac{1}{\\sigma^2} \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2<br>$$</p>\n<p>目标：让似然函数越大越好（极大似然估计），即让$J(\\theta)$越小越好（可以使用<strong>最小二乘法</strong>求解）<br>$$<br>J(\\theta) = \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2<br>$$<br><img src=\"808139430/image-20221227173603912.png\" alt=\"最小二乘法分析\"></p>\n<p><img src=\"808139430/image-20221227173755095.png\" alt=\"评估方法\"></p>\n<h2 id=\"4-梯度下降\"><a href=\"#4-梯度下降\" class=\"headerlink\" title=\"4 梯度下降\"></a>4 梯度下降</h2><p>梯度下降法（gradient descent）是一种常用的一阶（first-order）优化方法。主要解决求最小值问题，其基本思想在于不断地逼近最优点，每一步的优化方向就是梯度的方向。</p>\n<h3 id=\"4-1-梯度下降方法\"><a href=\"#4-1-梯度下降方法\" class=\"headerlink\" title=\"4.1 梯度下降方法\"></a>4.1 梯度下降方法</h3><ul>\n<li>批量梯度下降</li>\n</ul>\n<p>容易得到最优解，但是由于每次考虑所有样本，速度很慢。</p>\n<ul>\n<li>随机梯度下降</li>\n</ul>\n<p>每次找一个样本，迭代速度很快，但不一定每次都朝着收敛的方向。</p>\n<ul>\n<li>小批量梯度下降</li>\n</ul>\n<p>每次更新一小部分数据来算，因为在整个训练集上算梯度资源消耗太大，我们可以随机采取$b$个样本$i_1, i_2, \\cdots, i_b$来近似损失，$e$是损失函数，$b$是批量大小。<br>$$<br>\\frac{1}{b} \\sum \\limits_{i \\in I_b} \\mathcal{e}(\\mathbf{x_i}, y_i, \\mathbf{w})<br>$$</p>\n<h3 id=\"4-2-其他参数\"><a href=\"#4-2-其他参数\" class=\"headerlink\" title=\"4.2 其他参数\"></a>4.2 其他参数</h3><ul>\n<li>学习率：更新的步长</li>\n</ul>\n<p><img src=\"808139430/image-20221228161134519.png\" alt=\"学习率的影响\"></p>\n<ul>\n<li>批处理数量</li>\n</ul>\n<p>一般<code>batch_size</code>选择32，64，128等，有时候会考虑内存和效率。</p>\n<h1 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h1><p>逻辑回归是一个经典的二分类算法。</p>\n<h2 id=\"1-sigmoid函数\"><a href=\"#1-sigmoid函数\" class=\"headerlink\" title=\"1 sigmoid函数\"></a>1 sigmoid函数</h2><p>$$<br>g(z) = \\frac{1}{1 + e ^ {-z}}, z \\in R<br>$$</p>\n<p><img src=\"808139430/image-20221228161724190.png\" alt=\"sigmoid函数图像\"></p>\n<blockquote>\n<p>将任意的输入映射到了$[0, 1]$区间中，在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就可以完成由值到概率的转换，这就是分类任务。</p>\n</blockquote>\n<h2 id=\"2-逻辑回归求解\"><a href=\"#2-逻辑回归求解\" class=\"headerlink\" title=\"2 逻辑回归求解\"></a>2 逻辑回归求解</h2><p>预测函数：<br>$$<br>h_{\\theta}(x) = g(\\theta ^ T x) = \\frac{1}{1 + e ^ {-\\theta^T x}} \\\\<br>其中 \\theta_0 + \\theta_1 x_1 + … + \\theta_n x_n = \\sum \\limits_{i = 1}^n \\theta_i x_i = \\theta ^ T x<br>$$<br>分类任务：<br>$$<br>\\begin{cases}<br>P(y = 1|x; \\theta) = h_\\theta(x) \\\\<br>P(y = 0|x; \\theta) = 1 - h_\\theta(x)<br>\\end{cases}<br>\\Rightarrow<br>P(y | x; \\theta) = (h_\\theta(x)) ^ y (1 - h_\\theta(x)) ^ {1 - y}<br>$$<br>对于二分类任务（0， 1），整合后，<code>y</code>取0只保留$(1 - h_\\theta(x)) ^ {1 - y}$ ，<code>y</code>取1只保留 $(h_\\theta(x)) ^ y$ 。</p>\n<p>似然函数：<br>$$<br>L(\\theta) = \\prod \\limits_{i = 1}^m P(y_i | x_i; \\theta) = \\prod \\limits_{i = 1}^m (h_\\theta(x_i)) ^ y_i (1 - h_\\theta(x_i)) ^ {1 - y_i}<br>$$<br>对数似然法，即求$l(\\theta)$ 的最大值：<br>$$<br>l(\\theta) = logL(\\theta) = \\sum \\limits_{i = 1} ^m (y_i log h_\\theta(x_i) + (1 - y_i) log (1 - h_\\theta(x_i)))<br>$$<br>将上述函数转化为求最小值，同时系数乘上一个常数，即求$J(\\theta) = -\\frac{1}{m}l(\\theta)$ 的最小值，转化为梯度下降问题：<br>$$<br>J(\\theta) = -\\frac{1}{m}l(\\theta)<br>$$<br><img src=\"808139430/image-20221228164952743.png\" alt=\"求导过程\"></p>\n<p>上述过程即求出了偏导的方向，有了更新方向就可以进行参数更新： $\\alpha$代表学习率<br>$$<br>\\theta_j = \\theta_j - \\alpha \\frac{1}{m} \\sum \\limits_{i = 1} ^ m (h_\\theta(x_i) - y_i)x_i^j<br>$$</p>\n<blockquote>\n<p>减法是代表用的梯度下降，整体除以<code>m</code>是考虑了所有的m个样本。</p>\n</blockquote>\n<p>多分类问题：</p>\n<p><img src=\"808139430/image-20221228171310763.png\" alt=\"多分类\"></p>\n<blockquote>\n<p>Softmax回归是逻辑回归的一般化，相关对比参考 <a href=\"https://zhuanlan.zhihu.com/p/98061179\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/98061179</a></p>\n</blockquote>\n<h1 id=\"模型评估标准\"><a href=\"#模型评估标准\" class=\"headerlink\" title=\"模型评估标准\"></a>模型评估标准</h1><h2 id=\"1-回归模型评估\"><a href=\"#1-回归模型评估\" class=\"headerlink\" title=\"1 回归模型评估\"></a>1 回归模型评估</h2><h3 id=\"1-1-平均绝对误差（Mean-Absolute-Error，MAE）\"><a href=\"#1-1-平均绝对误差（Mean-Absolute-Error，MAE）\" class=\"headerlink\" title=\"1.1 平均绝对误差（Mean Absolute Error，MAE）\"></a>1.1 平均绝对误差（Mean Absolute Error，MAE）</h3><p>平均绝对误差就是指预测值与真实值之间平均相差多大<br>$$<br>MAE = \\frac{1}{m}\\sum \\limits _{i = 1}^m \\lvert f_i - y_i \\rvert<br>$$</p>\n<h3 id=\"1-2-均方误差（Mean-Squared-Error，MSE）\"><a href=\"#1-2-均方误差（Mean-Squared-Error，MSE）\" class=\"headerlink\" title=\"1.2 均方误差（Mean Squared Error，MSE）\"></a>1.2 均方误差（Mean Squared Error，MSE）</h3><p>观测值与真值偏差的平方和与观测次数的比值<br>$$<br>MSE = \\frac{1}{m} \\sum \\limits_{i = 1}^m(f_i - y_i)^2<br>$$<br>这也是线性回归中最常用的损失函数，线性回归过程中尽量让该损失函数最小。那么模型之间的对比也可以用它来比较。</p>\n<p>MSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。</p>\n<h3 id=\"1-3-R-square（决定系数）\"><a href=\"#1-3-R-square（决定系数）\" class=\"headerlink\" title=\"1.3 R-square（决定系数）\"></a>1.3 R-square（决定系数）</h3><p>$$<br>R^2 = 1 - \\frac{\\sum(Y_{actual} - Y_{predict})^2}{\\sum(Y_{actual} - Y_{mean})^2}<br>$$</p>\n<h3 id=\"1-4-Adjusted-R-Square（校正决定系数）\"><a href=\"#1-4-Adjusted-R-Square（校正决定系数）\" class=\"headerlink\" title=\"1.4 Adjusted R-Square（校正决定系数）\"></a>1.4 Adjusted R-Square（校正决定系数）</h3><p>$$<br>R^2_{adjusted} = 1 - \\frac{(1 - R^2)(n - 1)}{n - p - 1}<br>$$</p>\n<p>n为样本数量，p为特征数量</p>\n<p>消除了样本数量和特征数量的影响</p>\n<h3 id=\"1-5-交叉验证\"><a href=\"#1-5-交叉验证\" class=\"headerlink\" title=\"1.5 交叉验证\"></a>1.5 交叉验证</h3><p>我们有一个总的数据集，将总数据集切分，例如，将数据分为训练集（80%）和测试集（20%），训练集用来训练model，测试集用来最终的测试。</p>\n<p>训练集还再平均进行切分为3份（标号为1、2、3）。</p>\n<blockquote>\n<p>测试集和训练集的比例自己定。</p>\n</blockquote>\n<p>交叉验证就是在训练集中，采用2份数据来训练，用另一份数据来验证训练出的模型的参数，进行3次。</p>\n<p>即：1 + 2来训练，3验证；2 + 3来训练，1来验证；1 + 3来训练，2来验证。</p>\n<p>为了让模型的评估效果比较好，最后将3次的参数取平均值。</p>\n<blockquote>\n<p>无论分类还是回归模型，都可以利用交叉验证，进行模型评估</p>\n<p>sklearn模块中有交叉验证函数，例如<code>sklearn.cross_validation</code> 中的 <code>train_testsplit</code> 函数</p>\n</blockquote>\n<p>交叉验证主要是为了防止某一部分数据比较简单，导致模型的效果比较高。</p>\n<h2 id=\"2-分类模型评估\"><a href=\"#2-分类模型评估\" class=\"headerlink\" title=\"2 分类模型评估\"></a>2 分类模型评估</h2><h3 id=\"2-1-准确率、精确率、召回率、f1-score\"><a href=\"#2-1-准确率、精确率、召回率、f1-score\" class=\"headerlink\" title=\"2.1 准确率、精确率、召回率、f1_score\"></a>2.1 准确率、精确率、召回率、f1_score</h3><ul>\n<li><p>准确率（Accuracy）的定义是：对于给定的测试集，分类模型正确分类的样本数与总样本数之比；</p>\n</li>\n<li><p>精确率（Precision）的定义是：对于给定测试集的某一个类别，分类模型预测正确的比例，或者说：分类模型预测的正样本中有多少是真正的正样本；</p>\n</li>\n<li><p>召回率（Recall）的定义为：对于给定测试集的某一个类别，样本中的正类有多少被分类模型预测正确；</p>\n<blockquote>\n<p>假设有1000个人，其中990个人正常，有10个人患有癌症，模型旨在预测哪些人是患有癌症的。</p>\n<p>如果模型预测1000个人中都是正常的，没有癌症患者，那么可以说模型的精度是$\\frac{990}{1000}=0.99$。虽然精度很高，但是都是正样本，没有负样本，模型是无用的，因为一个患者都没有找到。因此无法用精度来评估模型，而是使用recall召回率来评估。</p>\n</blockquote>\n</li>\n<li><p>F1_score，在理想情况下，我们希望模型的精确率越高越好，同时召回率也越高越高，但是，现实情况往往事与愿违，在现实情况下，精确率和召回率像是坐在跷跷板上一样，往往出现一个值升高，另一个值降低，那么，有没有一个指标来综合考虑精确率和召回率了，这个指标就是F值。F值的计算公式为：<br>$$<br>F = \\frac{(a ^ 2 + 1) \\times P \\times R}{a ^ 2 \\times (P + R)}<br>$$</p>\n<blockquote>\n<p>P: Precision， R: Recall, a：权重因子</p>\n<p>当a=1时，F值便是F1值，代表精确率和召回率的权重是一样的，是最常用的一种评价指标。</p>\n<p>F1的计算公式为：$F1 = \\frac{2 \\times P \\times R}{P + R}$</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-2-混淆矩阵\"><a href=\"#2-2-混淆矩阵\" class=\"headerlink\" title=\"2.2 混淆矩阵\"></a>2.2 混淆矩阵</h3><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。</p>\n<p>具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。</p>\n<p>下面是一个混淆矩阵，<code>Actual</code>代表真实值，<code>Predicted</code>代表预测值，预测的是标签号（因为是分类任务，主要对标签进行分类）。</p>\n<blockquote>\n<p>下面是我对TP、TN、FP、FN四个值的理解（助记）</p>\n<p>TP：预测正确，预测成1</p>\n<p>TN：预测正确，预测成0</p>\n<p>FP：预测错误，预测成1</p>\n<p>FN：预测错误，预测成0</p>\n</blockquote>\n<p><img src=\"808139430/image-20221230142020907.png\" alt=\"混淆矩阵\"></p>\n<p>可以通过上面四个值计算相应的评估值，见下图。</p>\n<p><img src=\"808139430/image-20221230143921870.png\" alt=\"混淆矩阵计算评估指标\"></p>\n<h1 id=\"回归模型相关技巧\"><a href=\"#回归模型相关技巧\" class=\"headerlink\" title=\"回归模型相关技巧\"></a>回归模型相关技巧</h1><h2 id=\"1-下采样和上采样\"><a href=\"#1-下采样和上采样\" class=\"headerlink\" title=\"1 下采样和上采样\"></a>1 下采样和上采样</h2><p>在分类问题的数据中，很容易出现正反数据集数量存在极大的差距，这类数据直接用于训练不利于模型的构架，所以我们需要对数据进行些许处理。</p>\n<p>很容易想到，合理的数据集应该是正反数据集数量应接近，那就存在两种策略：</p>\n<p>下采样策略：把数量多的减少到与数量少的相近</p>\n<p>上（过）采样策略：把数量少的增加到与数量多的相近</p>\n<ul>\n<li>下采样：</li>\n</ul>\n<p><img src=\"808139430/2.png\" alt=\"img\"></p>\n<ul>\n<li>上采样：SMOTE算法</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<p>（1）对于少数类中每一个样本x，以<strong>欧氏距离（两点之间距离）</strong>为标准计算它到少数类样本集中所有样本的距离，得到其<code>k</code>近邻（所有距离排序后前<code>k</code>小的距离）</p>\n<p>（2）根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn</p>\n<p>（3）对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本。<br>$$<br>x_{new} = x + rand(0, 1) \\times (\\widetilde x - x)<br>$$</p>\n<blockquote>\n<p>$(\\widetilde x - x)$ 相当于距离 $d_i$ （欧几里得距离），那么每个 $d_i$ 都可以生成一个新的数据。</p>\n</blockquote>\n<p><img src=\"808139430/image-20221230161807567.png\" alt=\"SMOTE算法原理图\"></p>\n<h2 id=\"2-正则化惩罚\"><a href=\"#2-正则化惩罚\" class=\"headerlink\" title=\"2 正则化惩罚\"></a>2 正则化惩罚</h2><p>加上了正则化项能在一定程度上避免过拟合</p>\n<h1 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h1><h2 id=\"1-概述-1\"><a href=\"#1-概述-1\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><h3 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h3><p>决策树是一种解决分类问题的算法，决策树算法采用树形结构，使用层层推理来实现最终的分类。</p>\n<p>决策树即可以做分类，也可以做回归。它主要分为两种：<strong>分类树</strong> 和 <strong>回归树</strong>。</p>\n<h3 id=\"1-2-决策树算法\"><a href=\"#1-2-决策树算法\" class=\"headerlink\" title=\"1.2 决策树算法\"></a>1.2 决策树算法</h3><ul>\n<li>第一个决策树算法: CLS （Concept Learning System）</li>\n<li>使决策树受到关注、成为机器学习主流技术的算法: ID3</li>\n<li>最常用的决策树算法: C4.5</li>\n<li>可以用于回归任务的决策树算法: CART （Classification and Regression Tree）</li>\n<li>基于决策树的最强大算法: RF （Random Forest）</li>\n</ul>\n<h3 id=\"1-3-结构\"><a href=\"#1-3-结构\" class=\"headerlink\" title=\"1.3 结构\"></a>1.3 结构</h3><p>决策树由下面几种元素构成：</p>\n<ul>\n<li>根节点：包含样本的全集（全部训练数据）</li>\n<li>内部节点：对应特征属性测试</li>\n<li>叶节点：代表决策的结果</li>\n</ul>\n<p><img src=\"808139430/image-20221230164038527.png\" alt=\"决策树结构\"></p>\n<p>决策树学习的<strong>目的</strong>是为了产生一棵泛化能力强的决策树</p>\n<h2 id=\"2-决策树构建\"><a href=\"#2-决策树构建\" class=\"headerlink\" title=\"2 决策树构建\"></a>2 决策树构建</h2><h3 id=\"2-1-构建过程\"><a href=\"#2-1-构建过程\" class=\"headerlink\" title=\"2.1 构建过程\"></a>2.1 构建过程</h3><p>整体策略：自上而下分而治之</p>\n<p>决策树的构建过程就是一个<strong>自根至叶的递归过程</strong>， 在每个中间结点寻找一个<strong>划分</strong>属性。</p>\n<p>大致过程：</p>\n<ul>\n<li>开始：构建根节点，所有训练数据都放在根节点，选择x个最优特征，按着这一特征将训练数据集分割成子集，进入子节点。</li>\n<li>所有子集按内部节点的属性递归地进行分割。</li>\n<li>如果这些子集已经能够被基本正确分类，那么构建叶节点，并将这些子集分到所对应的叶节点去。</li>\n<li>每个子集都被分到叶节点上，即都有了明确的类，这样就生成了一颗决策树。</li>\n</ul>\n<p>递归的三种停止条件：</p>\n<ul>\n<li>当前结点包含的样本全属于同一类别，无需划分；</li>\n<li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分;</li>\n<li>当前结点包含的样本集合为空，不能划分。</li>\n</ul>\n<h3 id=\"2-2-特征选择\"><a href=\"#2-2-特征选择\" class=\"headerlink\" title=\"2.2 特征选择\"></a>2.2 特征选择</h3><p><strong>信息熵</strong>：随机变量的不确定性。<br>$$<br>H(X) = - \\sum p_i log_2 p_i \\hspace{2em} \\text{i = 1, 2, …, n}<br>$$</p>\n<blockquote>\n<p>例：</p>\n<p>A集合 $[1, 1, 1, 1, 1, 1, 1, 1, 2, 2]$</p>\n<p>B集合$[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]$</p>\n<p>A集合熵值低于B集合熵值，因为A集合中只有两种类别，B集合中类别比较多（结构比较乱），熵值就会比较大</p>\n</blockquote>\n<p><strong>信息增益：</strong> 表示特征X使得类Y的不确定性减少的程度（熵值减少），即当前划分对信息熵所造成的变化。</p>\n<p>信息增益越大，表示特征a来划分所减少的熵最大，即提升最大，应当作为根节点。</p>\n<h2 id=\"3-决策树算法\"><a href=\"#3-决策树算法\" class=\"headerlink\" title=\"3 决策树算法\"></a>3 决策树算法</h2><h3 id=\"3-1-ID3（信息增益）\"><a href=\"#3-1-ID3（信息增益）\" class=\"headerlink\" title=\"3.1 ID3（信息增益）\"></a>3.1 ID3（信息增益）</h3><p>下面是基于信息增益的ID3算法的实例：</p>\n<p>我们有14天的数据，4个特征条件：<strong>天气，温度，湿度，是否有风</strong>。最终结果是去玩不玩。</p>\n<p><img src=\"808139430/image-20221231110826312.png\" alt=\"数据\"></p>\n<p><img src=\"808139430/image-20221231110929844.png\" alt=\"划分方式\"></p>\n<p>上面有四种划分方式，我们需要判断谁来当根节点，根据的主要就是信息增益这个指标。下面计算信息增益来判断根节点。</p>\n<p>本例暂且以<code>ent(a, b)</code>代表以下含义：（只有两种结果的时候的熵值计算）</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> math <span class=\"token keyword\">import</span> log2\n<span class=\"token keyword\">def</span> <span class=\"token function\">ent</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    tot <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b\n    x<span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> a <span class=\"token operator\">/</span> tot<span class=\"token punctuation\">,</span> b <span class=\"token operator\">/</span> tot\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">*</span> log2<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> y <span class=\"token operator\">*</span> log2<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>总的数据中，9天玩，5天不玩，熵值为：<br>$$<br>-\\frac{9}{14}log_2 \\frac{9}{14} - \\frac{5}{14}log_2 \\frac{5}{14} = 0.940<br>$$<br>然后对4个特征逐个分析：</p>\n<ul>\n<li><p>outlook</p>\n<ul>\n<li><code>outlook = sunny</code>时，熵值为0.971，取值为sunny的概率为 $\\frac{5}{14}$</li>\n<li><code>outlook = overcast</code>时，熵值为0，取值为overcast的概率为 $\\frac{4}{14}$</li>\n<li><code>outlook = rainy</code>时，熵值为0.971，取值为rainy的概率为 $\\frac{5}{14}$</li>\n</ul>\n<p>熵值为：<br>$$<br>\\frac{5}{14} \\times 0.971 + \\frac{4}{14} \\times 0 + \\frac{5}{14} \\times 0.971 = 0.693<br>$$<br>信息增益：系统熵值从0.940下降到0.693，增益为0.247。</p>\n</li>\n<li><p>temperture</p>\n<ul>\n<li><code>temperture = hot</code>时，熵值为1.0（<code>ent(2, 2)</code>），取值为hot的概率为$\\frac{4}{14}$</li>\n<li><code>temperture = mild</code>时，熵值为0.918（<code>ent(4, 2)</code>），取值为mild的概率为$\\frac{6}{14}$</li>\n<li><code>temperture = cool</code>时，熵值为0.81（<code>ent(3,1)</code>），取值为cool的概率为$\\frac{4}{14}$</li>\n</ul>\n<p>熵值为：<br>$$<br>\\frac{4}{14} \\times 1.0 + \\frac{6}{14} \\times 0.918 + \\frac{4}{14} \\times 0.81 = 0.911<br>$$<br>信息增益：$Gain(S, temperture) = 0.940 - 0.911 = 0.029$</p>\n</li>\n<li><p>其他特征按照相同方法来做得到：</p>\n</li>\n</ul>\n<p>$$<br>Gain(S，Outlook)=0.247  \\<br>Gain(S, Humidity)=0.151  \\<br>Gain(S, Wind)=0 .048 \\<br>Gain(S,Temperature)=0 .029<br>$$</p>\n<p>计算出所有的信息增益之后，选择<strong>有最大的信息增益的特征</strong>作为根节点。</p>\n<p>下面找Sunny分支的决策树划分：</p>\n<p>总的熵值<br>$$<br>-\\frac{2}{5} \\times log_2(\\frac{2}{5}) - \\frac{3}{5}log_2(\\frac{3}{5}) = 0.97<br>$$<br>以剩下的三个特征进行分析：</p>\n<ul>\n<li><p>temperture</p>\n<ul>\n<li>temperture=hot，熵值为0，概率为$\\frac{2}{5}$</li>\n<li>temperture=mild，熵值为1.0，概率为$\\frac{2}{5}$</li>\n<li>temperture=cool，熵值为0，概率为$\\frac{1}{5}$</li>\n</ul>\n<p>熵值为$\\frac{2}{5}$</p>\n<p>信息增益：$0.97-0.4 = 0.57$</p>\n</li>\n<li><p>humidy</p>\n<ul>\n<li>high，熵值为0，概率为$\\frac{3}{5}$</li>\n<li>normal，熵值为1，概率为$\\frac{2}{5}$</li>\n</ul>\n<p>熵值为$\\frac{2}{5}$</p>\n<p>信息增益：$0.97 - 0.4 = 0.57$</p>\n</li>\n<li><p>windy</p>\n<ul>\n<li>false，熵值为0.918，概率为$\\frac{3}{5}$</li>\n<li>true，熵值为1，概率为$\\frac{2}{5}$</li>\n</ul>\n<p>熵值为$0.951$</p>\n<p>信息增益：$0.97 - 0.95 = 0.02$</p>\n</li>\n</ul>\n<p>故选择humidy或wind划分</p>\n<p>剩下的划分同理，最终决策树为</p>\n<p><img src=\"808139430/image-20230208111655893.png\" alt=\"最终决策树\"></p>\n<h3 id=\"3-2-C4-5（信息增益率）\"><a href=\"#3-2-C4-5（信息增益率）\" class=\"headerlink\" title=\"3.2 C4.5（信息增益率）\"></a>3.2 C4.5（信息增益率）</h3><blockquote>\n<p>基于信息增益的决策树算法会有哪些问题：</p>\n<p>如果有一个特征：id，代表样本的编号，以上述数据为例，id为从1到14，如果计算id特征的根节点，发现信息增益是最大的，因为每一个子节点的信息熵值都为0。</p>\n</blockquote>\n<p>信息增益率：（解决了ID3的问题，考虑自身熵，信息增益除以自身熵）<br>$$<br>\\frac{G}{H(x)} \\hspace{2em} \\text{G:信息增益, H(x):熵值}<br>$$</p>\n<h3 id=\"3-3-CART（GINI系数）\"><a href=\"#3-3-CART（GINI系数）\" class=\"headerlink\" title=\"3.3 CART（GINI系数）\"></a>3.3 CART（GINI系数）</h3><p>使用基尼系数作为衡量标准。<br>$$<br>Gini(p) = \\sum \\limits _{k = 1}^K p_k (1 - p_k) = 1 - \\sum \\limits _{k = 1}^K p_k^2<br>$$</p>\n<h2 id=\"3-决策树剪枝\"><a href=\"#3-决策树剪枝\" class=\"headerlink\" title=\"3 决策树剪枝\"></a>3 决策树剪枝</h2><h3 id=\"3-1-预剪枝\"><a href=\"#3-1-预剪枝\" class=\"headerlink\" title=\"3.1 预剪枝\"></a>3.1 预剪枝</h3><p>在建立决策树边的时候进行剪枝的操作，比较使用实用。</p>\n<p>剪枝策略：</p>\n<ul>\n<li>限制深度</li>\n<li>限制叶子结点个数</li>\n<li>限制叶子结点样本数</li>\n<li>限制信息增益量等。</li>\n</ul>\n<h3 id=\"3-2-后剪枝\"><a href=\"#3-2-后剪枝\" class=\"headerlink\" title=\"3.2 后剪枝\"></a>3.2 后剪枝</h3><p>建立完决策树后进行剪枝操作。</p>\n<h2 id=\"4-连续值和缺失值处理\"><a href=\"#4-连续值和缺失值处理\" class=\"headerlink\" title=\"4 连续值和缺失值处理\"></a>4 连续值和缺失值处理</h2><ul>\n<li><p>连续值属性可取数值不是有限的，不能根据连续树形的可取值对节点进行划分。常见做法是：<strong>二分法</strong>对其进行离散化。</p>\n</li>\n<li><p>现实应用中，经常会遇到属性值<code>缺失</code>现象仅使用无缺失的样例，这是对数据的极大浪费使用带缺失值的样例，需解决：</p>\n<ul>\n<li>如何进行划分属性选择?</li>\n<li>给定划分属性，若样本在该属性上的值缺失，如何进行划分?</li>\n</ul>\n<p>基本思路：<strong>样本赋权，权重划分</strong></p>\n</li>\n</ul>\n<h1 id=\"集成算法\"><a href=\"#集成算法\" class=\"headerlink\" title=\"集成算法\"></a>集成算法</h1><h2 id=\"1-概述-2\"><a href=\"#1-概述-2\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>集成算法：Ensemble Learning</p>\n<p>Bagging：训练多个分类器取平均<br>$$<br>f(x) = \\frac{1}{M} \\sum \\limits_{m = 1}^M f_m(x)<br>$$<br>Boosting：从弱学习器开始加强，通过加权来训练。<br>$$<br>F_m(x) = F_{m - 1}(x) + argmin_h \\sum \\limits_{i = 1}^n L(y_i, F_{m - 1}(x_i) + h(x_i))<br>$$<br>Stacking：聚合多个分类或回归模型。</p>\n<h2 id=\"2-Bagging模型-随机森林\"><a href=\"#2-Bagging模型-随机森林\" class=\"headerlink\" title=\"2 Bagging模型-随机森林\"></a>2 Bagging模型-随机森林</h2><p>其实就是并行训练一堆分类器（每个分类器互相独立）。典型代表为随机森林（多个决策树并行放在一起）。</p>\n<blockquote>\n<p>随机指的是：数据随机采样，特征随机选择</p>\n<p>每个分类器喂的数据随机，数据的特征数随机。二重随机性，会让每个树基本都不一样，最终的结果也不一样。</p>\n</blockquote>\n<p>随机森林优势：</p>\n<ul>\n<li>可以处理高维度（feature多）数据，不用做特征选择</li>\n<li>训练完之后，可以给出那些feature比较重要</li>\n<li>容易做成并行化方法，速度快</li>\n<li>可以进行可视化展示，便于分析</li>\n</ul>\n<h2 id=\"3-Boosting模型\"><a href=\"#3-Boosting模型\" class=\"headerlink\" title=\"3 Boosting模型\"></a>3 Boosting模型</h2><p>提升模型典型代表：AdaBoost，XgBoost</p>\n<p>AdaBoost：会根据前一次的分类效果调整数据权重</p>\n<h2 id=\"4-Stacking模型\"><a href=\"#4-Stacking模型\" class=\"headerlink\" title=\"4 Stacking模型\"></a>4 Stacking模型</h2><p>堆叠模型：可以堆叠各种各样的分类器（KNN，SVM，RF等）</p>\n<p>分阶段进行：第一阶段得出各自的结果，第二阶段再利用前一阶段结果进行训练。</p>\n<h1 id=\"贝叶斯算法\"><a href=\"#贝叶斯算法\" class=\"headerlink\" title=\"贝叶斯算法\"></a>贝叶斯算法</h1><p>贝叶斯公式：<br>$$<br>P(A | B) = \\frac{P(B|A)P(A)}{P(B)}<br>$$</p>\n<h2 id=\"1-1-实例：拼写纠正\"><a href=\"#1-1-实例：拼写纠正\" class=\"headerlink\" title=\"1.1 实例：拼写纠正\"></a>1.1 实例：拼写纠正</h2><p>用户输入一个不在词典中的单词，需要猜测用户真正想输入的单词。</p>\n<p>我们要求的是<code>P(我们猜测用户想输入的单词|用户实际输入的单词)</code></p>\n<p>假设用户实际输入的单词为<code>D</code>（Data）</p>\n<p>我们有多个猜测：<code>P(h1 | D), P(h2 | D)</code>， 方便后续计算，统一为<code>P(h | D)</code><br>$$<br>P(h | D) = \\frac{P(h) P(D | h)}{P(D)}<br>$$</p>\n<blockquote>\n<p>$P(h)$为单词在语料库中出现的概率（出现次数 / 总次数），我们叫做<strong>先验概率</strong>，这个概率可以算出来。</p>\n<p>$P(D|h)$ 为我们将一个正确的词输入错误的概率。</p>\n</blockquote>\n<p>对于所有的猜测，$P(D)$ 都是一样的，所以可以忽略这个常数。</p>\n<p>则<br>$$<br>P(h|D) \\varpropto P(h)P(D|h)<br>$$</p>\n<blockquote>\n<p>$P(D|h)$可以根据某种指标来判定，可以看键盘上字母的编辑距离来算概率等等。</p>\n</blockquote>\n<p>如果计算出来多个结果预测概率是一样的，那么就可以使用<strong>先验概率</strong>来进行判断谁最优先。</p>\n<h2 id=\"1-2-拼写检查器实现\"><a href=\"#1-2-拼写检查器实现\" class=\"headerlink\" title=\"1.2 拼写检查器实现\"></a>1.2 拼写检查器实现</h2><p>原理：<br>$$<br>argmaxc \\ P(A|B) = argmaxc \\  \\frac{P(B|A) P(A)}{P(B)}<br>$$</p>\n<p>$P(A|B)$：待求值，用户本想输入B的前提下，错输成A的概率</p>\n<p>$P(A)$：文章中出现正确单词A的概率</p>\n<p>$P(B|A)$：用户本想输入A的前提下，错输成B的概率</p>\n<p>$P(B)$：文章中出现正确单词B的概率</p>\n<p>$argmaxc$：用来枚举所有可能的A，并选取概率最大的那个</p>\n<p>拼写检查器就是，输入一个单词，先判断这个单词是否存在于语料库中（是否正确），如果不在（可能语料库中没有，或者拼写错误），则需要根据编辑距离进行检查修正。</p>\n<p><code>big.txt</code>文件：<a href=\"https://wwwi.lanzouo.com/i9s8t0ju5qzg\" target=\"_blank\" rel=\"noopener\">https://wwwi.lanzouo.com/i9s8t0ju5qzg</a></p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> re<span class=\"token punctuation\">,</span> collections\n\n<span class=\"token comment\" spellcheck=\"true\">#  将所有大写字母转化为小写，并且去掉特殊字符</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">return</span> re<span class=\"token punctuation\">.</span>findall<span class=\"token punctuation\">(</span><span class=\"token string\">'[a-z]+'</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">train</span><span class=\"token punctuation\">(</span>features<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\" spellcheck=\"true\"># 遇到从来没有见过的新词但语料库中未包含，概率模型中希望返回一个很小的概率，故出现次数设置为1</span>\n    model <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>defaultdict<span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> f <span class=\"token keyword\">in</span> features<span class=\"token punctuation\">:</span>\n        model<span class=\"token punctuation\">[</span>f<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> model\n\n\nNWORDS <span class=\"token operator\">=</span> train<span class=\"token punctuation\">(</span>words<span class=\"token punctuation\">(</span>open<span class=\"token punctuation\">(</span><span class=\"token string\">'big.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 词频</span>\nalphabet <span class=\"token operator\">=</span> <span class=\"token string\">'abcdefghijklmnopqrstuvwxyz'</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 编辑距离为1的单词</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">edits1</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    n <span class=\"token operator\">=</span> len<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> set<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> word<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span>   <span class=\"token comment\" spellcheck=\"true\"># deletion</span>\n               <span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> word<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> word<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span>  <span class=\"token comment\" spellcheck=\"true\"># transportation</span>\n               <span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> c <span class=\"token operator\">+</span> word<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> alphabet<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span>  <span class=\"token comment\" spellcheck=\"true\"># alteration</span>\n               <span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> c <span class=\"token operator\">+</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> alphabet<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># insertion</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 编辑距离为2 的单词</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">edits2</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> set<span class=\"token punctuation\">(</span>e2 <span class=\"token keyword\">for</span> e1 <span class=\"token keyword\">in</span> edits1<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> e2 <span class=\"token keyword\">in</span> edits1<span class=\"token punctuation\">(</span>e1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 将那些正确的词作为候选词</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">known</span><span class=\"token punctuation\">(</span>words<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> set<span class=\"token punctuation\">(</span>w <span class=\"token keyword\">for</span> w <span class=\"token keyword\">in</span> words <span class=\"token keyword\">if</span> w <span class=\"token keyword\">in</span> NWORDS<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 检查器函数，先判断是不是正确的拼写形式，如果不是则选出编辑距离为1的单词……</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">correct</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    candidates <span class=\"token operator\">=</span> known<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> known<span class=\"token punctuation\">(</span>edits1<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> known<span class=\"token punctuation\">(</span>edits2<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> <span class=\"token punctuation\">[</span>word<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">(</span>candidates<span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> w<span class=\"token punctuation\">:</span> NWORDS<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>correct<span class=\"token punctuation\">(</span><span class=\"token string\">'mach'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-3-新闻分类\"><a href=\"#1-3-新闻分类\" class=\"headerlink\" title=\"1.3 新闻分类\"></a>1.3 新闻分类</h2><p>之后用到了再补，短时间不会写。</p>\n<h1 id=\"SVM支持向量机\"><a href=\"#SVM支持向量机\" class=\"headerlink\" title=\"SVM支持向量机\"></a>SVM支持向量机</h1><h2 id=\"1-概述-3\"><a href=\"#1-概述-3\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>Support Vector Machine是一种二分类模型，它的基本模型是定义在特征空间上的<strong>间隔最大的线性分类器</strong></p>\n<p>SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $wx+b=0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。</p>\n<p><img src=\"808139430/image-20230102144808362.png\" alt=\"支持向量机\"></p>\n<h2 id=\"2-推导\"><a href=\"#2-推导\" class=\"headerlink\" title=\"2 推导\"></a>2 推导</h2><h3 id=\"2-1-距离\"><a href=\"#2-1-距离\" class=\"headerlink\" title=\"2.1 距离\"></a>2.1 距离</h3><p>正常三维条件下点$(x_0, y_0, z_0)$到平面$Ax + By + Cz + D = 0$的距离公式（高中知识）：<br>$$<br>\\frac{\\vert Ax_0 + By_0 + Cz_0 + D \\vert}{\\sqrt{A^2 + B^2 + C^2}}<br>$$<br>推导分析过程：</p>\n<p>平面方程： $ax + by + cz = d$ ，平面外一点$P(x_0, y_0, z_0)$</p>\n<p><img src=\"808139430/image-20230102153203878.png\" alt=\"示意图\"></p>\n<p>PQ垂直平面，即为求PQ的长度，但不知Q点的具体数据。</p>\n<p>故构造一个平面上的点$P^{‘}(x_1, y_1, z_1)$，问题即转化为求$\\overrightarrow {P^{‘}P}$ 在法向量N上面的分量，即$\\overrightarrow {P^{‘}P}$ 与N相同方向的单位向量的点积。</p>\n<p><img src=\"808139430/image-20230102153230935.png\" alt=\"示意图\"></p>\n<p>设距离为D。</p>\n<p><img src=\"808139430/1203675-20180109152428254-718844217.png\" alt=\"距离公式推导\"></p>\n<p>现在考虑一般情况：</p>\n<p>求平面外一点 $x$ 到平面$w^T x + b = 0$ 的距离：</p>\n<blockquote>\n<p>结论：平面$Ax + By + Cz + D = 0$的法向量为$(A, B, C)$</p>\n</blockquote>\n<p><img src=\"808139430/image-20230102154354917.png\" alt=\"示意图\"></p>\n<p>同上述原理：</p>\n<p>距离就为<br>$$<br>distance(x, b, w) = \\vert \\frac{w^T}{\\vert w \\vert}(x - x^{‘}) \\vert = \\frac{1}{\\vert w \\vert} \\vert w^Tx + b \\vert<br>$$</p>\n<blockquote>\n<p>上述公式进行了代入，将$x^{‘}$代入平面方程得$w^Tx^{‘} = -b$</p>\n</blockquote>\n<h3 id=\"2-2-数据\"><a href=\"#2-2-数据\" class=\"headerlink\" title=\"2.2 数据\"></a>2.2 数据</h3><p>数据集：$(x_1, y_1)(x_2, y_2)…(x_n, y_n)$</p>\n<p>$Y$ 为样本的类别：当$X$ 为正例时，$Y = +1$，当$X$为负例时，$Y = -1$</p>\n<p>决策方程：$y(x) = w^T \\Phi(x) + b$ （其中$\\Phi(x)$是对数据做了变换）<br>$$<br>\\begin{cases}<br>y(x_i) &gt; 0 \\Leftrightarrow y_i = +1 \\\\<br>y(x_i) &lt; 0 \\Leftrightarrow y_i = -1<br>\\end{cases}<br>\\Longrightarrow<br>y_i y(x_i) &gt; 0<br>$$</p>\n<h3 id=\"2-3-目标函数求解\"><a href=\"#2-3-目标函数求解\" class=\"headerlink\" title=\"2.3 目标函数求解\"></a>2.3 目标函数求解</h3><p>将点到直线距离进行转化（化简）：<br>$$<br>\\frac{y_i \\cdot (w^T \\cdot \\Phi(x) + b)}{\\vert w \\vert}<br>$$</p>\n<blockquote>\n<p>$y_i y(x_i) &gt; 0$ 直接乘上$y_i$ 将绝对值去掉，$|y_i| = 1$，并不影响值大小</p>\n</blockquote>\n<p>放缩变换：对于决策方程（w, b）可以通过放缩变换是的其结果值$|Y| \\geq 1$ ，则<br>$$<br>y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1<br>$$</p>\n<blockquote>\n<p>缩放之前w和b有无数组解，缩放之后w和b只有一组解。</p>\n</blockquote>\n<p>优化目标：<br>$$<br>\\mathop{arg\\  max} \\limits_{w, b} \\bigg\\{ \\frac{1}{|w|} \\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b)\\Big \\} \\bigg\\}<br>$$</p>\n<blockquote>\n<p>$\\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\Big \\}$ 是求所有样本点到平面的最小距离的那个点</p>\n<p>$arg\\ max$ 是<strong>最大化到平面最小距离的点的距离</strong></p>\n<p>由于$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$， 故最小值为1，只需要考虑 $\\mathop{arg\\  max} \\limits_{w, b} \\frac{1}{|w|}$</p>\n</blockquote>\n<p>当前目标变为：$\\mathop{max} \\limits_{w, b} \\frac{1}{|w|}$，即求$|w|$的最小值，但有约束条件 $y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$</p>\n<p>将求极大值转化为求极小值的问题，求$\\frac{1}{2}w^2$ 的最小值。</p>\n<p>需要使用<strong>拉格朗日乘子法</strong>：（此处不做证明，直接给出结论，我还不知道$\\alpha$的作用，呜呜呜）<br>$$<br>L(w, b, \\alpha) = \\frac{1}{2}|w|^2 - \\sum \\limits_{i = 1}^n \\alpha_i (y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) - 1)<br>$$</p>\n<blockquote>\n<p>上式需要满足约束条件：$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$</p>\n</blockquote>\n<p><img src=\"808139430/image-20230102224841617.png\" alt=\"求解过程\"></p>\n<p><img src=\"808139430/image-20230102225344026.png\" alt=\"求解过程\"></p>\n<p><img src=\"808139430/image-20230102225422893.png\" alt=\"求解过程\"></p>\n<h2 id=\"3-SVM实例\"><a href=\"#3-SVM实例\" class=\"headerlink\" title=\"3 SVM实例\"></a>3 SVM实例</h2><p>有三个数据：3个点，正例$x_1(3, 3), x_2(4, 3)$， 负例$x_3(1, 1)$，（数据是二维数据）对其进行二分类。</p>\n<p>首先需要求解下式的最小值：<br>$$<br>\\frac{1}{2}\\sum \\limits_{i = 1}^n \\sum \\limits _{j = 1}^n \\alpha_i \\alpha_j y_i y_j (x_i \\cdot x_j) - \\sum \\limits_{i = 1}^n\\alpha_i \\hspace{3em} (1)<br>$$</p>\n<blockquote>\n<p>注意：$x_i \\cdot x_j$ 的运算是点积运算。</p>\n<p>约束条件：<br>$$<br>\\alpha_1 + \\alpha_2 - \\alpha_3 = 0 \\\\<br>\\alpha_i \\geq 0, \\hspace{2em} i = 1, 2, 3<br>$$</p>\n</blockquote>\n<p><img src=\"808139430/image-20230103144319179.png\" alt=\"图像示意\"></p>\n<p>将对应的数据带入（1）式，得：<br>$$<br>\\frac{1}{2} \\Big( 18 \\alpha_1^2 + 25\\alpha_2^2 + 2 \\alpha_3^2 + 42\\alpha_1\\alpha_2 - 12\\alpha_1\\alpha_3 - 14\\alpha_2\\alpha_3 \\Big) - \\alpha_1 - \\alpha_2 - \\alpha_3<br>$$<br>由于$\\alpha_1 + \\alpha_2 = \\alpha_3$，化简得：<br>$$<br>4 \\alpha_1 ^ 2 + \\frac{13}{2} \\alpha_2^2 + 10\\alpha_1\\alpha_2 - 2\\alpha_1 - 2\\alpha_2<br>$$<br>分别对$\\alpha_1,\\alpha_2$求偏导，偏导等于0得<br>$$<br>\\begin{cases}<br>\\alpha_1 = 1.5 \\\\<br>\\alpha_2 = -1<br>\\end{cases}<br>$$<br>发现不满足约束条件$\\alpha_i \\geq 0$，故解应在边界上。分别让两个值等于0求解<br>$$<br>\\begin{cases}<br>\\alpha_1 = 0 \\\\<br>\\alpha_2 = -\\frac{2}{13}<br>\\end{cases}<br>(\\times)<br>\\hspace{4em}<br>\\begin{cases}<br>\\alpha_1 = 0.25 \\\\<br>\\alpha_2 = 0<br>\\end{cases}<br>(\\checkmark)<br>$$<br>第一组解不满足，故最小值在$(0.25, 0.25)$处取得。</p>\n<p>将$\\alpha$结果带求解$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$，$\\Phi(x_i)$以$x_i$来代替<br>$$<br>w = \\frac{1}{4} \\times 1 \\times (3,3) + \\frac{1}{4} \\times (-1) \\times(1,1) = (\\frac{1}{2}, \\frac{1}{2})<br>\\\\<br>b = y_i - \\sum \\limits_{i = 1}^n a_i y_i (x_i x_j) = 1 - (\\frac{1}{4} \\times 1 \\times 18  + \\frac{1}{4} \\times (-1) \\times 6) = -2<br>$$<br>故平面方程为：<br>$$<br>0.5 x_1 + 0.5 x_2 - 2 = 0<br>$$</p>\n<blockquote>\n<p>因为$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$</p>\n<p>支持向量的$\\alpha$值不等于0，$\\alpha = 0$的向量不是支持向量，对最终结果没有影响。</p>\n<p>支持向量就是那些对最终结果起作用的向量，也可以当做是边界上的向量。</p>\n</blockquote>\n<h2 id=\"4-软间隔\"><a href=\"#4-软间隔\" class=\"headerlink\" title=\"4 软间隔\"></a>4 软间隔</h2><p>数据中有时候会有一些噪音点，如果考虑它们结果可能不会很好。</p>\n<p>为解决该问题，引入松弛因子：$y_i(w \\cdot x_i + b) \\geq 1 - \\xi_i$</p>\n<p>新的目标函数：<br>$$<br>min \\frac{1}{2} |w|^2 + C \\sum \\limits _{i = 1}^n \\xi_i<br>$$</p>\n<blockquote>\n<p>C是我们需要指定的一个参数</p>\n<p>当C趋近于很大时：意味着分类严格不能有错误</p>\n<p>当C趋近于很小时：意味着可以由更大的错误容忍</p>\n</blockquote>\n<p>解法基本一样：</p>\n<p><img src=\"808139430/image-20230103153918323.png\" alt=\"解法\"></p>\n<h2 id=\"5-SVM核变换\"><a href=\"#5-SVM核变换\" class=\"headerlink\" title=\"5 SVM核变换\"></a>5 SVM核变换</h2><p>将低维不可分映射到高维，找到一种变换方法，即为$\\phi(x)$</p>\n<p>高斯核函数：<br>$$<br>K(X, Y) =  exp \\bigg\\{ -\\frac{||X-Y||^2}{2\\sigma^2} \\bigg\\}<br>$$</p>\n<h2 id=\"6-基于sklearn求解SVM\"><a href=\"#6-基于sklearn求解SVM\" class=\"headerlink\" title=\"6 基于sklearn求解SVM\"></a>6 基于sklearn求解SVM</h2><p>参考 <a href=\"https://blog.csdn.net/weixin_42600072/article/details/88644229\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42600072/article/details/88644229</a></p>\n<h1 id=\"K-MEANS算法\"><a href=\"#K-MEANS算法\" class=\"headerlink\" title=\"K-MEANS算法\"></a>K-MEANS算法</h1><h2 id=\"1-概述-4\"><a href=\"#1-概述-4\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>聚类概念：这是个无监督问题（没有标签数据），目的是将相似的东西分到一组。</p>\n<p>通常使用的算法是K-MEANS算法</p>\n<blockquote>\n<p>K-MEANS算法：</p>\n<ul>\n<li>需要指定簇的个数，即K值</li>\n<li>质心：数据的均值，即向量各维取平均即可</li>\n<li>距离的度量：常用欧几里得距离和余弦相似度（先标准化，让数据基本都是在一个比较小的范围内浮动）</li>\n<li>优化目标：$min\\sum \\limits_{i = 1}^K \\sum \\limits_{x \\in C_i} dist(c_i, x)^2$ （对于每一个簇让每一个样本到中心点的距离越小越好，$c_i$代表中心点）</li>\n</ul>\n</blockquote>\n<h2 id=\"2-K-MEANS流程\"><a href=\"#2-K-MEANS流程\" class=\"headerlink\" title=\"2 K-MEANS流程\"></a>2 K-MEANS流程</h2><p>假设平面上有一系列样本点，现在需要将其进行分组。</p>\n<p>选定<code>K=2</code>，即将这些数据点分成两个组别。</p>\n<ul>\n<li>随机选择两个质心（分别代表两个簇），计算所有样本点到两个质心的距离。每个样本点会计算出到两个质心的距离，那么选择最小的距离，这个样本点就归属于哪个簇。</li>\n<li>然后对于两个簇的所有样本点分别算出对应的质心（这两个质心便充当新的质心），再对所有样本点计算到两个新的质心的距离，还是选择最小的距离，那么这个样本点就归属于哪个簇。</li>\n<li>最终直到两个簇所属的样本点不在发生变化。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1bt411i77G?p=101&vd_source=bb4ca29d8dfb2e3c28c10bb09f4b962e\" target=\"_blank\" rel=\"noopener\">K-MEANS工作流程视频参考</a></p>\n</blockquote>\n<h2 id=\"3-优缺点\"><a href=\"#3-优缺点\" class=\"headerlink\" title=\"3 优缺点\"></a>3 优缺点</h2><p>优点：</p>\n<ul>\n<li>简单快速，适合常规数据集</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>K值难以确定</li>\n<li>复杂度与样本呈线性关系</li>\n<li>很难发现任意形状的簇</li>\n<li>初始的点影响很大</li>\n</ul>\n<blockquote>\n<p> <a href=\"https://www.naftaliharris.com/blog/visualizing-k-means-clustering/\" target=\"_blank\" rel=\"noopener\">K-MEANS可视化演示</a></p>\n</blockquote>\n<h2 id=\"4-K-MEANS进行图像压缩\"><a href=\"#4-K-MEANS进行图像压缩\" class=\"headerlink\" title=\"4 K-MEANS进行图像压缩\"></a>4 K-MEANS进行图像压缩</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> skimage <span class=\"token keyword\">import</span> io\n<span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>cluster <span class=\"token keyword\">import</span> KMeans\n<span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n\nimage <span class=\"token operator\">=</span> io<span class=\"token punctuation\">.</span>imread<span class=\"token punctuation\">(</span><span class=\"token string\">\"1.jpg\"</span><span class=\"token punctuation\">)</span>\nio<span class=\"token punctuation\">.</span>imshow<span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># io.show()  # 显示图片</span>\n\nrows <span class=\"token operator\">=</span> image<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\ncols <span class=\"token operator\">=</span> image<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span>\n\nimage <span class=\"token operator\">=</span> image<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>rows <span class=\"token operator\">*</span> cols<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\nkmeans <span class=\"token operator\">=</span> KMeans<span class=\"token punctuation\">(</span>n_clusters<span class=\"token operator\">=</span><span class=\"token number\">128</span><span class=\"token punctuation\">,</span> n_init<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> max_iter<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 簇128, 最大迭代次数100</span>\nkmeans<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">)</span>\n\nclusters <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>asarray<span class=\"token punctuation\">(</span>kmeans<span class=\"token punctuation\">.</span>cluster_centers_<span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span>uint8<span class=\"token punctuation\">)</span>\nlabels <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>asarray<span class=\"token punctuation\">(</span>kmeans<span class=\"token punctuation\">.</span>labels_<span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span>uint8<span class=\"token punctuation\">)</span>\nlabels <span class=\"token operator\">=</span> labels<span class=\"token punctuation\">.</span>reshape<span class=\"token punctuation\">(</span>rows<span class=\"token punctuation\">,</span> cols<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>clusters<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span>\nnp<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span><span class=\"token string\">'test.npy'</span><span class=\"token punctuation\">,</span> clusters<span class=\"token punctuation\">)</span>\nio<span class=\"token punctuation\">.</span>imsave<span class=\"token punctuation\">(</span><span class=\"token string\">'compressed.jpg'</span><span class=\"token punctuation\">,</span> labels<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"DBSCAN算法\"><a href=\"#DBSCAN算法\" class=\"headerlink\" title=\"DBSCAN算法\"></a>DBSCAN算法</h1><h2 id=\"1-概述-5\"><a href=\"#1-概述-5\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种<strong>基于密度的空间聚类算法</strong>。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间<a href=\"https://cloud.tencent.com/solution/database?from=10680\" target=\"_blank\" rel=\"noopener\">数据库</a>中发现任意形状的簇，DBSCAN算法将<code>簇</code>定义为密度相连的点的最大集合。</p>\n<p>核心对象：若某个点的密度达到算法设定的阈值则称其为核心点。（即<code>r</code>邻域内的点的数量不小于<code>minPts</code>）</p>\n<p>基于以上密度的定义，我们可以将样本集中的点划分为以下三类：</p>\n<ul>\n<li><strong>核心点</strong>：在半径r区域内，含有超过MinPts数目（最小数目）的点，称为核心点；</li>\n<li><strong>边界点</strong>：在半径r区域内，点的数量小于MinPts数目，但是是核心点的直接邻居；</li>\n<li><strong>噪声点</strong>：既不是核心点也不是边界点的点</li>\n</ul>\n<blockquote>\n<p>噪声点是不会被聚类纳入的点，边界点与核心点组成聚类的“簇”。</p>\n</blockquote>\n<p>一些概念：</p>\n<ul>\n<li><strong>直接密度可达</strong>：在给定一个对象集合D，如果p在q的r领域内，且<strong>q是一个核心点对象</strong>，则称对象p从对象q出发时是直接密度可达的</li>\n<li><strong>密度可达</strong>：在给定对象集合D中，如果存在一个对象链q–&gt;e–&gt;a–&gt;k–&gt;l–&gt;p，任意相邻两个对象间都是直接密度可达的，则称对象p是对象q关于r邻域内、MinPts数目下，是密度可达的；</li>\n<li><strong>密度相连</strong>：如果在对象集合D中存在一个对象O，使得对象p和q都是从O关于r邻域内、MinPts数目下，是密度相连的。</li>\n</ul>\n<blockquote>\n<p>核心点能够连通（密度可达），它们构成的以r为半径的圆形邻域相互连接或重叠，这些连通的核心点及其所处的邻域内的全部点构成一个簇。</p>\n</blockquote>\n<h2 id=\"2-原理\"><a href=\"#2-原理\" class=\"headerlink\" title=\"2 原理\"></a>2 原理</h2><ol>\n<li>DBSCAN通过检查数据集中每个点的r邻域来搜索簇，如果点p的r邻域包含多于MinPts个点，则创建一个以p为核心对象的簇；</li>\n<li>然后， DBSCAN迭代的聚集从这些核心对象直接密度可达的对象，这个过程可能涉及一些密度可达簇的合并；</li>\n<li>当没有新的带你添加到任何簇时，迭代过程结束。</li>\n</ol>\n<p>优缺点：</p>\n<ul>\n<li><p>优点：基于密度定义，可以对抗噪声，能处理任意形状和大小的簇</p>\n</li>\n<li><p>缺点：当簇的密度变化太大时候，聚类得到的结果会不理想；对于高维问题，密度定义也是一个比较麻烦的问题。</p>\n</li>\n</ul>\n<h2 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h2><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n<span class=\"token keyword\">import</span> matplotlib<span class=\"token punctuation\">.</span>pyplot <span class=\"token keyword\">as</span> plt\n<span class=\"token keyword\">from</span> sklearn <span class=\"token keyword\">import</span> datasets\n<span class=\"token keyword\">import</span> matplotlib<span class=\"token punctuation\">.</span>colors\n\n<span class=\"token comment\" spellcheck=\"true\"># 创建Figure</span>\nfig <span class=\"token operator\">=</span> plt<span class=\"token punctuation\">.</span>figure<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 用来正常显示中文标签</span>\nmatplotlib<span class=\"token punctuation\">.</span>rcParams<span class=\"token punctuation\">[</span><span class=\"token string\">'font.sans-serif'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>u<span class=\"token string\">'SimHei'</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\" spellcheck=\"true\"># 用来正常显示负号</span>\nmatplotlib<span class=\"token punctuation\">.</span>rcParams<span class=\"token punctuation\">[</span><span class=\"token string\">'axes.unicode_minus'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n\nX1<span class=\"token punctuation\">,</span> y1 <span class=\"token operator\">=</span> datasets<span class=\"token punctuation\">.</span>make_circles<span class=\"token punctuation\">(</span>n_samples<span class=\"token operator\">=</span><span class=\"token number\">5000</span><span class=\"token punctuation\">,</span> factor<span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span>\n                                      noise<span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token number\">05</span><span class=\"token punctuation\">)</span>\nX2<span class=\"token punctuation\">,</span> y2 <span class=\"token operator\">=</span> datasets<span class=\"token punctuation\">.</span>make_blobs<span class=\"token punctuation\">(</span>n_samples<span class=\"token operator\">=</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> n_features<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n                             centers<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1.2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1.2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> cluster_std<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>random_state<span class=\"token operator\">=</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 原始点的分布</span>\nax1 <span class=\"token operator\">=</span> fig<span class=\"token punctuation\">.</span>add_subplot<span class=\"token punctuation\">(</span><span class=\"token number\">311</span><span class=\"token punctuation\">)</span>\nX <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>concatenate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>X1<span class=\"token punctuation\">,</span> X2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> X<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> marker<span class=\"token operator\">=</span><span class=\"token string\">'o'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">(</span>u<span class=\"token string\">'原始数据分布'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>sca<span class=\"token punctuation\">(</span>ax1<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># K-means聚类</span>\n<span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>cluster <span class=\"token keyword\">import</span> KMeans\nax2 <span class=\"token operator\">=</span> fig<span class=\"token punctuation\">.</span>add_subplot<span class=\"token punctuation\">(</span><span class=\"token number\">312</span><span class=\"token punctuation\">)</span>\ny_pred <span class=\"token operator\">=</span> KMeans<span class=\"token punctuation\">(</span>n_clusters<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> random_state<span class=\"token operator\">=</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fit_predict<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> X<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">=</span>y_pred<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">(</span>u<span class=\"token string\">'K-means聚类'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>sca<span class=\"token punctuation\">(</span>ax2<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># DBSCAN聚类</span>\n<span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>cluster <span class=\"token keyword\">import</span> DBSCAN\nax3 <span class=\"token operator\">=</span> fig<span class=\"token punctuation\">.</span>add_subplot<span class=\"token punctuation\">(</span><span class=\"token number\">313</span><span class=\"token punctuation\">)</span>\ny_pred <span class=\"token operator\">=</span> DBSCAN<span class=\"token punctuation\">(</span>eps <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> min_samples <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fit_predict<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> X<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">=</span>y_pred<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">(</span>u<span class=\"token string\">'DBSCAN聚类'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>sca<span class=\"token punctuation\">(</span>ax3<span class=\"token punctuation\">)</span>\n\nplt<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"PCA主成分分析\"><a href=\"#PCA主成分分析\" class=\"headerlink\" title=\"PCA主成分分析\"></a>PCA主成分分析</h1><p>Principal Component Analysis：降维中最常用的一种手段</p>\n<h2 id=\"1-基变换\"><a href=\"#1-基变换\" class=\"headerlink\" title=\"1 基变换\"></a>1 基变换</h2><p>目标：提取最有价值的信息（基于方差）</p>\n<ul>\n<li><p>基概念：例如在二维坐标系中，向量（3，4）也可表示为线性组合$x(1, 0) + y(0, 1)$，而$(0,1)(1,0)$叫做二维空间的一组基。</p>\n</li>\n<li><p>基变换</p>\n<ul>\n<li><p>要求：基是正交的（内积/点积为0，或者说互相垂直，线性无关）</p>\n</li>\n<li><p>变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量；数据与第二个基做内积运算，结果作为第二个新的坐标分量。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>比如$(3,2)$映射到基的坐标：<br>$$<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt{2}} &amp; \\frac{1}{\\sqrt{2}} \\\\<br>-\\frac{1}{\\sqrt{2}} &amp; \\frac{1}{\\sqrt{2}}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>3 \\\\<br>2<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>\\frac{5}{\\sqrt 2} \\\\<br>-\\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>$$</p>\n<ul>\n<li>基变换一般公式：</li>\n</ul>\n<p>$$<br>\\begin{pmatrix}<br>p_1 \\\\<br>p_2 \\\\<br>\\vdots \\\\<br>p_n<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \\cdots &amp;a_m<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>p_1a_1 &amp; p_1a_2 &amp; \\cdots &amp; p_1a_m \\\\<br>p_2a_1 &amp; p_2a_2 &amp; \\cdots &amp; p_2a_m \\\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\<br>p_na_1 &amp; p_na_2 &amp; \\cdots &amp; p_na_m \\\\<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>等式左边的两个矩阵中，左边是基，右边是数据。</p>\n<p>两个矩阵相乘的意义是将右边的矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。</p>\n</blockquote>\n<h2 id=\"2-协方差矩阵\"><a href=\"#2-协方差矩阵\" class=\"headerlink\" title=\"2 协方差矩阵\"></a>2 协方差矩阵</h2><p>我们希望选择一个方向（基）：数据能够保留更多的原始信息，也可以说希望经过某个基投影后的投影值尽可能分散。（雾</p>\n<p>方差：<br>$$<br>Var(a) = \\frac{1}{m} \\sum \\limits_{i = 1}^m (a_i - \\mu)^2<br>$$<br>寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，<strong>方差值最大</strong>（分散）。</p>\n<p>协方差：（假设均值为0时）（对于标签$a_i, b_i$，如果两个相似度越大，协方差越大）<br>$$<br>Cov(a, b) = \\frac{1}{m} \\sum \\limits_{i = 1}^m a_ib_i<br>$$</p>\n<blockquote>\n<p>如果单纯选择方差最大的方向，后续方向应该会和方差最大的方向接近重合。</p>\n<p>解决方案：为了让两个子段尽可能表示更多的原始信息，我们是不希望他们之间存在（线性）相关性的。</p>\n<p>可以用两个字段的协方差表示相关性，当协方差为0时，代表两个字段是相互独立的。</p>\n</blockquote>\n<p>题意：将一组N维向量降为K维，目标是选择K个单位的正交基，使原始数据变换到这组基上面后，各字段两两之间协方差为0，字段方差尽可能大。</p>\n<p>$$<br>\\text{特征数据}X =<br>\\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \\cdots &amp; a_m \\\\<br>b_1 &amp; b_2 &amp; \\cdots &amp; b_m<br>\\end{pmatrix}<br>$$<br>协方差矩阵：<br>$$<br>\\frac{1}{m}XX^T =<br>\\begin{pmatrix}<br>\\frac{1}{m}\\sum \\limits_{i = 1}^m a_i^2  &amp; \\frac{1}{m}\\sum \\limits_{i = 1}^ma_ib_i \\\\<br>\\frac{1}{m}\\sum \\limits_{i = 1}^m a_ib_i &amp; \\frac{1}{m}\\sum \\limits_{i = 1}^mb_i^2<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>矩阵对角线上的两个元素分别为两个字段的方差（假设均值为0），而其他元素是a和b的协方差。</p>\n</blockquote>\n<h2 id=\"3-优化\"><a href=\"#3-优化\" class=\"headerlink\" title=\"3 优化\"></a>3 优化</h2><p>接下来就是希望让协方差矩阵的除对角线位置的元素为0（协方差为0），就是进行对角化操作。</p>\n<p>协方差矩阵对角化：<br>$$<br>PCP^T = \\Lambda =<br>\\begin{pmatrix}<br>\\lambda_1 \\\\<br>&amp; \\lambda_2 \\\\<br>&amp; &amp; \\ddots \\\\<br>&amp; &amp; &amp; \\lambda_n<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>结论：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量<br>$$<br>E = \\begin{pmatrix} e_1 &amp; e_2 &amp; \\cdots &amp; e_n\\end{pmatrix}<br>$$<br>实对称矩阵可以进行对角化：<br>$$<br>ECE^T = \\Lambda =<br>\\begin{pmatrix}<br>\\lambda_1 \\\\<br>&amp; \\lambda_2 \\\\<br>&amp; &amp; \\ddots \\\\<br>&amp; &amp; &amp; \\lambda_n<br>\\end{pmatrix}<br>$$</p>\n</blockquote>\n<p>将特征值从大到小排列，用前K行组成的矩阵乘原始数据矩阵X，就得到降维后的数据矩阵Y。</p>\n<h2 id=\"4-示例\"><a href=\"#4-示例\" class=\"headerlink\" title=\"4 示例\"></a>4 示例</h2><p>数据（共5个数据，每个数据2个特征点）<br>$$<br>\\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\\end{pmatrix}<br>$$<br>协方差矩阵<br>$$<br>C = \\frac{1}{5}<br>\\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>-1 &amp; -2 \\\\<br>-1 &amp; 0 \\\\<br>0 &amp; 0 \\\\<br>2 &amp; 1 \\\\<br>0 &amp; 1<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>\\frac{6}{5} &amp; \\frac{4}{5} \\\\<br>\\frac{4}{5} &amp; \\frac{6}{5}<br>\\end{pmatrix}<br>$$<br>特征值<br>$$<br>\\lambda_1 = 2, \\lambda_2 = \\frac{2}{5}<br>$$<br>特征向量<br>$$<br>c_1<br>\\begin{pmatrix}<br>1 \\\\<br>1<br>\\end{pmatrix} ,<br>c_2<br>\\begin{pmatrix}<br>-1 \\\\<br>1<br>\\end{pmatrix}<br>$$<br>对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量$c_1$这个<br>$$<br>PCP^T =<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2} \\\\<br>-\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>\\frac{6}{5} &amp; \\frac{4}{5} \\\\<br>\\frac{4}{5} &amp; \\frac{6}{5}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt 2} &amp; -\\frac{1}{\\sqrt 2} \\\\<br>\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>2 &amp; 0 \\\\<br>0 &amp; \\frac{2}{5}<br>\\end{pmatrix}<br>$$<br>降维<br>$$<br>Y =<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>-\\frac{3}{\\sqrt 2} &amp; -\\frac{1}{\\sqrt 2} &amp; 0 &amp; \\frac{3}{\\sqrt 2} &amp; -\\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>机器学习实战参考：<a href=\"https://blog.csdn.net/weixin_42600072/category_8751294.html\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42600072/category_8751294.html</a></p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"机器学习基础概念知识总结\"><a href=\"#机器学习基础概念知识总结\" class=\"headerlink\" title=\"机器学习基础概念知识总结\"></a>机器学习基础概念知识总结</h1><h1 id=\"机器学习环境搭建\"><a href=\"#机器学习环境搭建\" class=\"headerlink\" title=\"机器学习环境搭建\"></a>机器学习环境搭建</h1><ul>\n<li><p>一般使用anaconda搭建python虚拟环境（miniconda占的空间应该小一点，这个也可以）</p>\n</li>\n<li><p>使用工具库一般有科学计算库numpy，数据处理库pandas，绘图matplotlib等，需要了解相关用法</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<h1 id=\"线性回归-Linear-Regression\"><a href=\"#线性回归-Linear-Regression\" class=\"headerlink\" title=\"线性回归 Linear Regression\"></a>线性回归 Linear Regression</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>线性回归类似高中的<strong>线性规划</strong>题目。线性回归要做的是就是找到一个数学公式能相对较完美地把所有自变量组合（加减乘除）起来，得到的结果和目标接近。</p>\n<p>线性回归分为一元线性回归和多元线性回归。</p>\n<h2 id=\"2-一元线性回归\"><a href=\"#2-一元线性回归\" class=\"headerlink\" title=\"2 一元线性回归\"></a>2 一元线性回归</h2><h3 id=\"2-1-构造回归方程\"><a href=\"#2-1-构造回归方程\" class=\"headerlink\" title=\"2.1 构造回归方程\"></a>2.1 构造回归方程</h3><p>有n组数据，自变量（特征值） $x(x_1,x_2,…,x_n)$ 与因变量（目标值） $y(y_1,y_2,…,y_n)$ ，我们需要找到一个线性关系，使他们之间尽可能满足： $f(x) =ax+b$ ，这个就是构建的一元线性方程。</p>\n<p><img src=\"808139430/1.jpg\" alt=\"一元线性回归\"></p>\n<p>线性回归的目标就是让 $f(X)$ 与 $y$ 之间的差距最小，也就是权重$a$和偏置$b$取什么值的时候$f(X)$和$y$最接近。</p>\n<h3 id=\"2-2-构造损失函数\"><a href=\"#2-2-构造损失函数\" class=\"headerlink\" title=\"2.2 构造损失函数\"></a>2.2 构造损失函数</h3><p>损失函数是来度量模型预测值与真实值不一样的程度的，或者说度量预测错误的程度，损失函数值越小，模型就越好。</p>\n<p>在回归问题中，误差平方和是回归任务中最常用的性能度量。这里就可以令损失函数$L(a,b)$等于误差平方和。</p>\n<p>则损失函数为: $L(a, b) = \\sum \\limits_{i = 1}^{n}(f(x_i) - y_i)^2$</p>\n<h3 id=\"2-3-确定参数\"><a href=\"#2-3-确定参数\" class=\"headerlink\" title=\"2.3 确定参数\"></a>2.3 确定参数</h3><p>我们需要通过最小的损失函数得到最佳的参数 $a$ 和 $b$ 。一般使用<strong>最小二乘法</strong>。<br>$$<br>a = \\frac{\\sum \\limits_{i=1}^{n}x_iy_i - n \\overline x \\overline y}{\\sum \\limits_{i=1}^{n}x_i^2 - n \\overline x ^ 2}<br>\\\\<br>b = \\overline y - a \\overline x<br>$$</p>\n<h2 id=\"3-多元线性回归\"><a href=\"#3-多元线性回归\" class=\"headerlink\" title=\"3 多元线性回归\"></a>3 多元线性回归</h2><p>多元线性回归类似一元</p>\n<p>回归方程： $y = a_1 x_1 + a_2 x_2 + a_3 x_3 + … + a_n x_n + b$</p>\n<p>对所有的数据统一用矩阵形式表示：<br>$$<br>y^{(i)} = \\theta ^ T x ^ {(i)} + \\varepsilon^{(i)} \\ (1)<br>$$</p>\n<blockquote>\n<p>$\\varepsilon$ 误差代表真实值和预测值之间的差异</p>\n<p>误差 $\\varepsilon ^{(i)}$ 是独立并具有相同的分布，服从均值为 0 方差为 $\\theta ^ 2$ 的高斯分布</p>\n</blockquote>\n<p>损失函数：$L(a_1, a_2, …, a_n, b) = \\sum_{i = 1}^{n}(f(x_i) - y_i)^2$</p>\n<p>高斯分布的概率函数：<br>$$<br>p(x) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{x^2}{2 \\sigma ^ 2})} \\  (2)<br>$$<br>将<code>(1)</code>带入<code>(2)</code>得到<strong>预测值成为真实值的概率</strong>函数：<br>$$<br>p(y ^ {(i)} | x ^ {(i)}; \\theta) = \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>$$<br>似然函数：（什么样的参数计算出来的误差最小，即与实际值最接近）<br>$$<br>L(\\theta) = \\prod \\limits_{i = 1}^{m} p(y ^ {(i)} | x ^ {(i)}; \\theta) = \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>$$<br>对数似然法：（将乘法转化为加法），之后需要用极大似然估计方法求解<br>$$<br>ln L(\\theta) = ln \\prod \\limits_{i=1}^{m}\\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>$$<br>展开化简：<br>$$<br>ln L(\\theta) = \\sum \\limits_{i = 1}^{m}ln \\frac{1}{\\sqrt {2 \\pi} \\sigma} \\exp{(-\\frac{(y^{(i)} - \\theta ^ T x ^ {(i)})^2}{2 \\sigma ^ 2})}<br>\\\\<br>= mln \\frac{1}{\\sqrt {2 \\pi} \\sigma} - \\frac{1}{\\sigma^2} \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2<br>$$</p>\n<p>目标：让似然函数越大越好（极大似然估计），即让$J(\\theta)$越小越好（可以使用<strong>最小二乘法</strong>求解）<br>$$<br>J(\\theta) = \\frac{1}{2} \\sum \\limits _{i = 1}^{m} (y^{(i)} - \\theta ^ T x ^ {(i)})^2<br>$$<br><img src=\"808139430/image-20221227173603912.png\" alt=\"最小二乘法分析\"></p>\n<p><img src=\"808139430/image-20221227173755095.png\" alt=\"评估方法\"></p>\n<h2 id=\"4-梯度下降\"><a href=\"#4-梯度下降\" class=\"headerlink\" title=\"4 梯度下降\"></a>4 梯度下降</h2><p>梯度下降法（gradient descent）是一种常用的一阶（first-order）优化方法。主要解决求最小值问题，其基本思想在于不断地逼近最优点，每一步的优化方向就是梯度的方向。</p>\n<h3 id=\"4-1-梯度下降方法\"><a href=\"#4-1-梯度下降方法\" class=\"headerlink\" title=\"4.1 梯度下降方法\"></a>4.1 梯度下降方法</h3><ul>\n<li>批量梯度下降</li>\n</ul>\n<p>容易得到最优解，但是由于每次考虑所有样本，速度很慢。</p>\n<ul>\n<li>随机梯度下降</li>\n</ul>\n<p>每次找一个样本，迭代速度很快，但不一定每次都朝着收敛的方向。</p>\n<ul>\n<li>小批量梯度下降</li>\n</ul>\n<p>每次更新一小部分数据来算，因为在整个训练集上算梯度资源消耗太大，我们可以随机采取$b$个样本$i_1, i_2, \\cdots, i_b$来近似损失，$e$是损失函数，$b$是批量大小。<br>$$<br>\\frac{1}{b} \\sum \\limits_{i \\in I_b} \\mathcal{e}(\\mathbf{x_i}, y_i, \\mathbf{w})<br>$$</p>\n<h3 id=\"4-2-其他参数\"><a href=\"#4-2-其他参数\" class=\"headerlink\" title=\"4.2 其他参数\"></a>4.2 其他参数</h3><ul>\n<li>学习率：更新的步长</li>\n</ul>\n<p><img src=\"808139430/image-20221228161134519.png\" alt=\"学习率的影响\"></p>\n<ul>\n<li>批处理数量</li>\n</ul>\n<p>一般<code>batch_size</code>选择32，64，128等，有时候会考虑内存和效率。</p>\n<h1 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h1><p>逻辑回归是一个经典的二分类算法。</p>\n<h2 id=\"1-sigmoid函数\"><a href=\"#1-sigmoid函数\" class=\"headerlink\" title=\"1 sigmoid函数\"></a>1 sigmoid函数</h2><p>$$<br>g(z) = \\frac{1}{1 + e ^ {-z}}, z \\in R<br>$$</p>\n<p><img src=\"808139430/image-20221228161724190.png\" alt=\"sigmoid函数图像\"></p>\n<blockquote>\n<p>将任意的输入映射到了$[0, 1]$区间中，在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就可以完成由值到概率的转换，这就是分类任务。</p>\n</blockquote>\n<h2 id=\"2-逻辑回归求解\"><a href=\"#2-逻辑回归求解\" class=\"headerlink\" title=\"2 逻辑回归求解\"></a>2 逻辑回归求解</h2><p>预测函数：<br>$$<br>h_{\\theta}(x) = g(\\theta ^ T x) = \\frac{1}{1 + e ^ {-\\theta^T x}} \\\\<br>其中 \\theta_0 + \\theta_1 x_1 + … + \\theta_n x_n = \\sum \\limits_{i = 1}^n \\theta_i x_i = \\theta ^ T x<br>$$<br>分类任务：<br>$$<br>\\begin{cases}<br>P(y = 1|x; \\theta) = h_\\theta(x) \\\\<br>P(y = 0|x; \\theta) = 1 - h_\\theta(x)<br>\\end{cases}<br>\\Rightarrow<br>P(y | x; \\theta) = (h_\\theta(x)) ^ y (1 - h_\\theta(x)) ^ {1 - y}<br>$$<br>对于二分类任务（0， 1），整合后，<code>y</code>取0只保留$(1 - h_\\theta(x)) ^ {1 - y}$ ，<code>y</code>取1只保留 $(h_\\theta(x)) ^ y$ 。</p>\n<p>似然函数：<br>$$<br>L(\\theta) = \\prod \\limits_{i = 1}^m P(y_i | x_i; \\theta) = \\prod \\limits_{i = 1}^m (h_\\theta(x_i)) ^ y_i (1 - h_\\theta(x_i)) ^ {1 - y_i}<br>$$<br>对数似然法，即求$l(\\theta)$ 的最大值：<br>$$<br>l(\\theta) = logL(\\theta) = \\sum \\limits_{i = 1} ^m (y_i log h_\\theta(x_i) + (1 - y_i) log (1 - h_\\theta(x_i)))<br>$$<br>将上述函数转化为求最小值，同时系数乘上一个常数，即求$J(\\theta) = -\\frac{1}{m}l(\\theta)$ 的最小值，转化为梯度下降问题：<br>$$<br>J(\\theta) = -\\frac{1}{m}l(\\theta)<br>$$<br><img src=\"808139430/image-20221228164952743.png\" alt=\"求导过程\"></p>\n<p>上述过程即求出了偏导的方向，有了更新方向就可以进行参数更新： $\\alpha$代表学习率<br>$$<br>\\theta_j = \\theta_j - \\alpha \\frac{1}{m} \\sum \\limits_{i = 1} ^ m (h_\\theta(x_i) - y_i)x_i^j<br>$$</p>\n<blockquote>\n<p>减法是代表用的梯度下降，整体除以<code>m</code>是考虑了所有的m个样本。</p>\n</blockquote>\n<p>多分类问题：</p>\n<p><img src=\"808139430/image-20221228171310763.png\" alt=\"多分类\"></p>\n<blockquote>\n<p>Softmax回归是逻辑回归的一般化，相关对比参考 <a href=\"https://zhuanlan.zhihu.com/p/98061179\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/98061179</a></p>\n</blockquote>\n<h1 id=\"模型评估标准\"><a href=\"#模型评估标准\" class=\"headerlink\" title=\"模型评估标准\"></a>模型评估标准</h1><h2 id=\"1-回归模型评估\"><a href=\"#1-回归模型评估\" class=\"headerlink\" title=\"1 回归模型评估\"></a>1 回归模型评估</h2><h3 id=\"1-1-平均绝对误差（Mean-Absolute-Error，MAE）\"><a href=\"#1-1-平均绝对误差（Mean-Absolute-Error，MAE）\" class=\"headerlink\" title=\"1.1 平均绝对误差（Mean Absolute Error，MAE）\"></a>1.1 平均绝对误差（Mean Absolute Error，MAE）</h3><p>平均绝对误差就是指预测值与真实值之间平均相差多大<br>$$<br>MAE = \\frac{1}{m}\\sum \\limits _{i = 1}^m \\lvert f_i - y_i \\rvert<br>$$</p>\n<h3 id=\"1-2-均方误差（Mean-Squared-Error，MSE）\"><a href=\"#1-2-均方误差（Mean-Squared-Error，MSE）\" class=\"headerlink\" title=\"1.2 均方误差（Mean Squared Error，MSE）\"></a>1.2 均方误差（Mean Squared Error，MSE）</h3><p>观测值与真值偏差的平方和与观测次数的比值<br>$$<br>MSE = \\frac{1}{m} \\sum \\limits_{i = 1}^m(f_i - y_i)^2<br>$$<br>这也是线性回归中最常用的损失函数，线性回归过程中尽量让该损失函数最小。那么模型之间的对比也可以用它来比较。</p>\n<p>MSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。</p>\n<h3 id=\"1-3-R-square（决定系数）\"><a href=\"#1-3-R-square（决定系数）\" class=\"headerlink\" title=\"1.3 R-square（决定系数）\"></a>1.3 R-square（决定系数）</h3><p>$$<br>R^2 = 1 - \\frac{\\sum(Y_{actual} - Y_{predict})^2}{\\sum(Y_{actual} - Y_{mean})^2}<br>$$</p>\n<h3 id=\"1-4-Adjusted-R-Square（校正决定系数）\"><a href=\"#1-4-Adjusted-R-Square（校正决定系数）\" class=\"headerlink\" title=\"1.4 Adjusted R-Square（校正决定系数）\"></a>1.4 Adjusted R-Square（校正决定系数）</h3><p>$$<br>R^2_{adjusted} = 1 - \\frac{(1 - R^2)(n - 1)}{n - p - 1}<br>$$</p>\n<p>n为样本数量，p为特征数量</p>\n<p>消除了样本数量和特征数量的影响</p>\n<h3 id=\"1-5-交叉验证\"><a href=\"#1-5-交叉验证\" class=\"headerlink\" title=\"1.5 交叉验证\"></a>1.5 交叉验证</h3><p>我们有一个总的数据集，将总数据集切分，例如，将数据分为训练集（80%）和测试集（20%），训练集用来训练model，测试集用来最终的测试。</p>\n<p>训练集还再平均进行切分为3份（标号为1、2、3）。</p>\n<blockquote>\n<p>测试集和训练集的比例自己定。</p>\n</blockquote>\n<p>交叉验证就是在训练集中，采用2份数据来训练，用另一份数据来验证训练出的模型的参数，进行3次。</p>\n<p>即：1 + 2来训练，3验证；2 + 3来训练，1来验证；1 + 3来训练，2来验证。</p>\n<p>为了让模型的评估效果比较好，最后将3次的参数取平均值。</p>\n<blockquote>\n<p>无论分类还是回归模型，都可以利用交叉验证，进行模型评估</p>\n<p>sklearn模块中有交叉验证函数，例如<code>sklearn.cross_validation</code> 中的 <code>train_testsplit</code> 函数</p>\n</blockquote>\n<p>交叉验证主要是为了防止某一部分数据比较简单，导致模型的效果比较高。</p>\n<h2 id=\"2-分类模型评估\"><a href=\"#2-分类模型评估\" class=\"headerlink\" title=\"2 分类模型评估\"></a>2 分类模型评估</h2><h3 id=\"2-1-准确率、精确率、召回率、f1-score\"><a href=\"#2-1-准确率、精确率、召回率、f1-score\" class=\"headerlink\" title=\"2.1 准确率、精确率、召回率、f1_score\"></a>2.1 准确率、精确率、召回率、f1_score</h3><ul>\n<li><p>准确率（Accuracy）的定义是：对于给定的测试集，分类模型正确分类的样本数与总样本数之比；</p>\n</li>\n<li><p>精确率（Precision）的定义是：对于给定测试集的某一个类别，分类模型预测正确的比例，或者说：分类模型预测的正样本中有多少是真正的正样本；</p>\n</li>\n<li><p>召回率（Recall）的定义为：对于给定测试集的某一个类别，样本中的正类有多少被分类模型预测正确；</p>\n<blockquote>\n<p>假设有1000个人，其中990个人正常，有10个人患有癌症，模型旨在预测哪些人是患有癌症的。</p>\n<p>如果模型预测1000个人中都是正常的，没有癌症患者，那么可以说模型的精度是$\\frac{990}{1000}=0.99$。虽然精度很高，但是都是正样本，没有负样本，模型是无用的，因为一个患者都没有找到。因此无法用精度来评估模型，而是使用recall召回率来评估。</p>\n</blockquote>\n</li>\n<li><p>F1_score，在理想情况下，我们希望模型的精确率越高越好，同时召回率也越高越高，但是，现实情况往往事与愿违，在现实情况下，精确率和召回率像是坐在跷跷板上一样，往往出现一个值升高，另一个值降低，那么，有没有一个指标来综合考虑精确率和召回率了，这个指标就是F值。F值的计算公式为：<br>$$<br>F = \\frac{(a ^ 2 + 1) \\times P \\times R}{a ^ 2 \\times (P + R)}<br>$$</p>\n<blockquote>\n<p>P: Precision， R: Recall, a：权重因子</p>\n<p>当a=1时，F值便是F1值，代表精确率和召回率的权重是一样的，是最常用的一种评价指标。</p>\n<p>F1的计算公式为：$F1 = \\frac{2 \\times P \\times R}{P + R}$</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-2-混淆矩阵\"><a href=\"#2-2-混淆矩阵\" class=\"headerlink\" title=\"2.2 混淆矩阵\"></a>2.2 混淆矩阵</h3><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。</p>\n<p>具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。</p>\n<p>下面是一个混淆矩阵，<code>Actual</code>代表真实值，<code>Predicted</code>代表预测值，预测的是标签号（因为是分类任务，主要对标签进行分类）。</p>\n<blockquote>\n<p>下面是我对TP、TN、FP、FN四个值的理解（助记）</p>\n<p>TP：预测正确，预测成1</p>\n<p>TN：预测正确，预测成0</p>\n<p>FP：预测错误，预测成1</p>\n<p>FN：预测错误，预测成0</p>\n</blockquote>\n<p><img src=\"808139430/image-20221230142020907.png\" alt=\"混淆矩阵\"></p>\n<p>可以通过上面四个值计算相应的评估值，见下图。</p>\n<p><img src=\"808139430/image-20221230143921870.png\" alt=\"混淆矩阵计算评估指标\"></p>\n<h1 id=\"回归模型相关技巧\"><a href=\"#回归模型相关技巧\" class=\"headerlink\" title=\"回归模型相关技巧\"></a>回归模型相关技巧</h1><h2 id=\"1-下采样和上采样\"><a href=\"#1-下采样和上采样\" class=\"headerlink\" title=\"1 下采样和上采样\"></a>1 下采样和上采样</h2><p>在分类问题的数据中，很容易出现正反数据集数量存在极大的差距，这类数据直接用于训练不利于模型的构架，所以我们需要对数据进行些许处理。</p>\n<p>很容易想到，合理的数据集应该是正反数据集数量应接近，那就存在两种策略：</p>\n<p>下采样策略：把数量多的减少到与数量少的相近</p>\n<p>上（过）采样策略：把数量少的增加到与数量多的相近</p>\n<ul>\n<li>下采样：</li>\n</ul>\n<p><img src=\"808139430/2.png\" alt=\"img\"></p>\n<ul>\n<li>上采样：SMOTE算法</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<p>（1）对于少数类中每一个样本x，以<strong>欧氏距离（两点之间距离）</strong>为标准计算它到少数类样本集中所有样本的距离，得到其<code>k</code>近邻（所有距离排序后前<code>k</code>小的距离）</p>\n<p>（2）根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn</p>\n<p>（3）对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本。<br>$$<br>x_{new} = x + rand(0, 1) \\times (\\widetilde x - x)<br>$$</p>\n<blockquote>\n<p>$(\\widetilde x - x)$ 相当于距离 $d_i$ （欧几里得距离），那么每个 $d_i$ 都可以生成一个新的数据。</p>\n</blockquote>\n<p><img src=\"808139430/image-20221230161807567.png\" alt=\"SMOTE算法原理图\"></p>\n<h2 id=\"2-正则化惩罚\"><a href=\"#2-正则化惩罚\" class=\"headerlink\" title=\"2 正则化惩罚\"></a>2 正则化惩罚</h2><p>加上了正则化项能在一定程度上避免过拟合</p>\n<h1 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h1><h2 id=\"1-概述-1\"><a href=\"#1-概述-1\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><h3 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h3><p>决策树是一种解决分类问题的算法，决策树算法采用树形结构，使用层层推理来实现最终的分类。</p>\n<p>决策树即可以做分类，也可以做回归。它主要分为两种：<strong>分类树</strong> 和 <strong>回归树</strong>。</p>\n<h3 id=\"1-2-决策树算法\"><a href=\"#1-2-决策树算法\" class=\"headerlink\" title=\"1.2 决策树算法\"></a>1.2 决策树算法</h3><ul>\n<li>第一个决策树算法: CLS （Concept Learning System）</li>\n<li>使决策树受到关注、成为机器学习主流技术的算法: ID3</li>\n<li>最常用的决策树算法: C4.5</li>\n<li>可以用于回归任务的决策树算法: CART （Classification and Regression Tree）</li>\n<li>基于决策树的最强大算法: RF （Random Forest）</li>\n</ul>\n<h3 id=\"1-3-结构\"><a href=\"#1-3-结构\" class=\"headerlink\" title=\"1.3 结构\"></a>1.3 结构</h3><p>决策树由下面几种元素构成：</p>\n<ul>\n<li>根节点：包含样本的全集（全部训练数据）</li>\n<li>内部节点：对应特征属性测试</li>\n<li>叶节点：代表决策的结果</li>\n</ul>\n<p><img src=\"808139430/image-20221230164038527.png\" alt=\"决策树结构\"></p>\n<p>决策树学习的<strong>目的</strong>是为了产生一棵泛化能力强的决策树</p>\n<h2 id=\"2-决策树构建\"><a href=\"#2-决策树构建\" class=\"headerlink\" title=\"2 决策树构建\"></a>2 决策树构建</h2><h3 id=\"2-1-构建过程\"><a href=\"#2-1-构建过程\" class=\"headerlink\" title=\"2.1 构建过程\"></a>2.1 构建过程</h3><p>整体策略：自上而下分而治之</p>\n<p>决策树的构建过程就是一个<strong>自根至叶的递归过程</strong>， 在每个中间结点寻找一个<strong>划分</strong>属性。</p>\n<p>大致过程：</p>\n<ul>\n<li>开始：构建根节点，所有训练数据都放在根节点，选择x个最优特征，按着这一特征将训练数据集分割成子集，进入子节点。</li>\n<li>所有子集按内部节点的属性递归地进行分割。</li>\n<li>如果这些子集已经能够被基本正确分类，那么构建叶节点，并将这些子集分到所对应的叶节点去。</li>\n<li>每个子集都被分到叶节点上，即都有了明确的类，这样就生成了一颗决策树。</li>\n</ul>\n<p>递归的三种停止条件：</p>\n<ul>\n<li>当前结点包含的样本全属于同一类别，无需划分；</li>\n<li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分;</li>\n<li>当前结点包含的样本集合为空，不能划分。</li>\n</ul>\n<h3 id=\"2-2-特征选择\"><a href=\"#2-2-特征选择\" class=\"headerlink\" title=\"2.2 特征选择\"></a>2.2 特征选择</h3><p><strong>信息熵</strong>：随机变量的不确定性。<br>$$<br>H(X) = - \\sum p_i log_2 p_i \\hspace{2em} \\text{i = 1, 2, …, n}<br>$$</p>\n<blockquote>\n<p>例：</p>\n<p>A集合 $[1, 1, 1, 1, 1, 1, 1, 1, 2, 2]$</p>\n<p>B集合$[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]$</p>\n<p>A集合熵值低于B集合熵值，因为A集合中只有两种类别，B集合中类别比较多（结构比较乱），熵值就会比较大</p>\n</blockquote>\n<p><strong>信息增益：</strong> 表示特征X使得类Y的不确定性减少的程度（熵值减少），即当前划分对信息熵所造成的变化。</p>\n<p>信息增益越大，表示特征a来划分所减少的熵最大，即提升最大，应当作为根节点。</p>\n<h2 id=\"3-决策树算法\"><a href=\"#3-决策树算法\" class=\"headerlink\" title=\"3 决策树算法\"></a>3 决策树算法</h2><h3 id=\"3-1-ID3（信息增益）\"><a href=\"#3-1-ID3（信息增益）\" class=\"headerlink\" title=\"3.1 ID3（信息增益）\"></a>3.1 ID3（信息增益）</h3><p>下面是基于信息增益的ID3算法的实例：</p>\n<p>我们有14天的数据，4个特征条件：<strong>天气，温度，湿度，是否有风</strong>。最终结果是去玩不玩。</p>\n<p><img src=\"808139430/image-20221231110826312.png\" alt=\"数据\"></p>\n<p><img src=\"808139430/image-20221231110929844.png\" alt=\"划分方式\"></p>\n<p>上面有四种划分方式，我们需要判断谁来当根节点，根据的主要就是信息增益这个指标。下面计算信息增益来判断根节点。</p>\n<p>本例暂且以<code>ent(a, b)</code>代表以下含义：（只有两种结果的时候的熵值计算）</p>\n<pre><code class=\"python\">from math import log2\ndef ent(a, b):\n    tot = a + b\n    x, y = a / tot, b / tot\n    return -(x * log2(x) + y * log2(y))</code></pre>\n<p>总的数据中，9天玩，5天不玩，熵值为：<br>$$<br>-\\frac{9}{14}log_2 \\frac{9}{14} - \\frac{5}{14}log_2 \\frac{5}{14} = 0.940<br>$$<br>然后对4个特征逐个分析：</p>\n<ul>\n<li><p>outlook</p>\n<ul>\n<li><code>outlook = sunny</code>时，熵值为0.971，取值为sunny的概率为 $\\frac{5}{14}$</li>\n<li><code>outlook = overcast</code>时，熵值为0，取值为overcast的概率为 $\\frac{4}{14}$</li>\n<li><code>outlook = rainy</code>时，熵值为0.971，取值为rainy的概率为 $\\frac{5}{14}$</li>\n</ul>\n<p>熵值为：<br>$$<br>\\frac{5}{14} \\times 0.971 + \\frac{4}{14} \\times 0 + \\frac{5}{14} \\times 0.971 = 0.693<br>$$<br>信息增益：系统熵值从0.940下降到0.693，增益为0.247。</p>\n</li>\n<li><p>temperture</p>\n<ul>\n<li><code>temperture = hot</code>时，熵值为1.0（<code>ent(2, 2)</code>），取值为hot的概率为$\\frac{4}{14}$</li>\n<li><code>temperture = mild</code>时，熵值为0.918（<code>ent(4, 2)</code>），取值为mild的概率为$\\frac{6}{14}$</li>\n<li><code>temperture = cool</code>时，熵值为0.81（<code>ent(3,1)</code>），取值为cool的概率为$\\frac{4}{14}$</li>\n</ul>\n<p>熵值为：<br>$$<br>\\frac{4}{14} \\times 1.0 + \\frac{6}{14} \\times 0.918 + \\frac{4}{14} \\times 0.81 = 0.911<br>$$<br>信息增益：$Gain(S, temperture) = 0.940 - 0.911 = 0.029$</p>\n</li>\n<li><p>其他特征按照相同方法来做得到：</p>\n</li>\n</ul>\n<p>$$<br>Gain(S，Outlook)=0.247  \\<br>Gain(S, Humidity)=0.151  \\<br>Gain(S, Wind)=0 .048 \\<br>Gain(S,Temperature)=0 .029<br>$$</p>\n<p>计算出所有的信息增益之后，选择<strong>有最大的信息增益的特征</strong>作为根节点。</p>\n<p>下面找Sunny分支的决策树划分：</p>\n<p>总的熵值<br>$$<br>-\\frac{2}{5} \\times log_2(\\frac{2}{5}) - \\frac{3}{5}log_2(\\frac{3}{5}) = 0.97<br>$$<br>以剩下的三个特征进行分析：</p>\n<ul>\n<li><p>temperture</p>\n<ul>\n<li>temperture=hot，熵值为0，概率为$\\frac{2}{5}$</li>\n<li>temperture=mild，熵值为1.0，概率为$\\frac{2}{5}$</li>\n<li>temperture=cool，熵值为0，概率为$\\frac{1}{5}$</li>\n</ul>\n<p>熵值为$\\frac{2}{5}$</p>\n<p>信息增益：$0.97-0.4 = 0.57$</p>\n</li>\n<li><p>humidy</p>\n<ul>\n<li>high，熵值为0，概率为$\\frac{3}{5}$</li>\n<li>normal，熵值为1，概率为$\\frac{2}{5}$</li>\n</ul>\n<p>熵值为$\\frac{2}{5}$</p>\n<p>信息增益：$0.97 - 0.4 = 0.57$</p>\n</li>\n<li><p>windy</p>\n<ul>\n<li>false，熵值为0.918，概率为$\\frac{3}{5}$</li>\n<li>true，熵值为1，概率为$\\frac{2}{5}$</li>\n</ul>\n<p>熵值为$0.951$</p>\n<p>信息增益：$0.97 - 0.95 = 0.02$</p>\n</li>\n</ul>\n<p>故选择humidy或wind划分</p>\n<p>剩下的划分同理，最终决策树为</p>\n<p><img src=\"808139430/image-20230208111655893.png\" alt=\"最终决策树\"></p>\n<h3 id=\"3-2-C4-5（信息增益率）\"><a href=\"#3-2-C4-5（信息增益率）\" class=\"headerlink\" title=\"3.2 C4.5（信息增益率）\"></a>3.2 C4.5（信息增益率）</h3><blockquote>\n<p>基于信息增益的决策树算法会有哪些问题：</p>\n<p>如果有一个特征：id，代表样本的编号，以上述数据为例，id为从1到14，如果计算id特征的根节点，发现信息增益是最大的，因为每一个子节点的信息熵值都为0。</p>\n</blockquote>\n<p>信息增益率：（解决了ID3的问题，考虑自身熵，信息增益除以自身熵）<br>$$<br>\\frac{G}{H(x)} \\hspace{2em} \\text{G:信息增益, H(x):熵值}<br>$$</p>\n<h3 id=\"3-3-CART（GINI系数）\"><a href=\"#3-3-CART（GINI系数）\" class=\"headerlink\" title=\"3.3 CART（GINI系数）\"></a>3.3 CART（GINI系数）</h3><p>使用基尼系数作为衡量标准。<br>$$<br>Gini(p) = \\sum \\limits _{k = 1}^K p_k (1 - p_k) = 1 - \\sum \\limits _{k = 1}^K p_k^2<br>$$</p>\n<h2 id=\"3-决策树剪枝\"><a href=\"#3-决策树剪枝\" class=\"headerlink\" title=\"3 决策树剪枝\"></a>3 决策树剪枝</h2><h3 id=\"3-1-预剪枝\"><a href=\"#3-1-预剪枝\" class=\"headerlink\" title=\"3.1 预剪枝\"></a>3.1 预剪枝</h3><p>在建立决策树边的时候进行剪枝的操作，比较使用实用。</p>\n<p>剪枝策略：</p>\n<ul>\n<li>限制深度</li>\n<li>限制叶子结点个数</li>\n<li>限制叶子结点样本数</li>\n<li>限制信息增益量等。</li>\n</ul>\n<h3 id=\"3-2-后剪枝\"><a href=\"#3-2-后剪枝\" class=\"headerlink\" title=\"3.2 后剪枝\"></a>3.2 后剪枝</h3><p>建立完决策树后进行剪枝操作。</p>\n<h2 id=\"4-连续值和缺失值处理\"><a href=\"#4-连续值和缺失值处理\" class=\"headerlink\" title=\"4 连续值和缺失值处理\"></a>4 连续值和缺失值处理</h2><ul>\n<li><p>连续值属性可取数值不是有限的，不能根据连续树形的可取值对节点进行划分。常见做法是：<strong>二分法</strong>对其进行离散化。</p>\n</li>\n<li><p>现实应用中，经常会遇到属性值<code>缺失</code>现象仅使用无缺失的样例，这是对数据的极大浪费使用带缺失值的样例，需解决：</p>\n<ul>\n<li>如何进行划分属性选择?</li>\n<li>给定划分属性，若样本在该属性上的值缺失，如何进行划分?</li>\n</ul>\n<p>基本思路：<strong>样本赋权，权重划分</strong></p>\n</li>\n</ul>\n<h1 id=\"集成算法\"><a href=\"#集成算法\" class=\"headerlink\" title=\"集成算法\"></a>集成算法</h1><h2 id=\"1-概述-2\"><a href=\"#1-概述-2\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>集成算法：Ensemble Learning</p>\n<p>Bagging：训练多个分类器取平均<br>$$<br>f(x) = \\frac{1}{M} \\sum \\limits_{m = 1}^M f_m(x)<br>$$<br>Boosting：从弱学习器开始加强，通过加权来训练。<br>$$<br>F_m(x) = F_{m - 1}(x) + argmin_h \\sum \\limits_{i = 1}^n L(y_i, F_{m - 1}(x_i) + h(x_i))<br>$$<br>Stacking：聚合多个分类或回归模型。</p>\n<h2 id=\"2-Bagging模型-随机森林\"><a href=\"#2-Bagging模型-随机森林\" class=\"headerlink\" title=\"2 Bagging模型-随机森林\"></a>2 Bagging模型-随机森林</h2><p>其实就是并行训练一堆分类器（每个分类器互相独立）。典型代表为随机森林（多个决策树并行放在一起）。</p>\n<blockquote>\n<p>随机指的是：数据随机采样，特征随机选择</p>\n<p>每个分类器喂的数据随机，数据的特征数随机。二重随机性，会让每个树基本都不一样，最终的结果也不一样。</p>\n</blockquote>\n<p>随机森林优势：</p>\n<ul>\n<li>可以处理高维度（feature多）数据，不用做特征选择</li>\n<li>训练完之后，可以给出那些feature比较重要</li>\n<li>容易做成并行化方法，速度快</li>\n<li>可以进行可视化展示，便于分析</li>\n</ul>\n<h2 id=\"3-Boosting模型\"><a href=\"#3-Boosting模型\" class=\"headerlink\" title=\"3 Boosting模型\"></a>3 Boosting模型</h2><p>提升模型典型代表：AdaBoost，XgBoost</p>\n<p>AdaBoost：会根据前一次的分类效果调整数据权重</p>\n<h2 id=\"4-Stacking模型\"><a href=\"#4-Stacking模型\" class=\"headerlink\" title=\"4 Stacking模型\"></a>4 Stacking模型</h2><p>堆叠模型：可以堆叠各种各样的分类器（KNN，SVM，RF等）</p>\n<p>分阶段进行：第一阶段得出各自的结果，第二阶段再利用前一阶段结果进行训练。</p>\n<h1 id=\"贝叶斯算法\"><a href=\"#贝叶斯算法\" class=\"headerlink\" title=\"贝叶斯算法\"></a>贝叶斯算法</h1><p>贝叶斯公式：<br>$$<br>P(A | B) = \\frac{P(B|A)P(A)}{P(B)}<br>$$</p>\n<h2 id=\"1-1-实例：拼写纠正\"><a href=\"#1-1-实例：拼写纠正\" class=\"headerlink\" title=\"1.1 实例：拼写纠正\"></a>1.1 实例：拼写纠正</h2><p>用户输入一个不在词典中的单词，需要猜测用户真正想输入的单词。</p>\n<p>我们要求的是<code>P(我们猜测用户想输入的单词|用户实际输入的单词)</code></p>\n<p>假设用户实际输入的单词为<code>D</code>（Data）</p>\n<p>我们有多个猜测：<code>P(h1 | D), P(h2 | D)</code>， 方便后续计算，统一为<code>P(h | D)</code><br>$$<br>P(h | D) = \\frac{P(h) P(D | h)}{P(D)}<br>$$</p>\n<blockquote>\n<p>$P(h)$为单词在语料库中出现的概率（出现次数 / 总次数），我们叫做<strong>先验概率</strong>，这个概率可以算出来。</p>\n<p>$P(D|h)$ 为我们将一个正确的词输入错误的概率。</p>\n</blockquote>\n<p>对于所有的猜测，$P(D)$ 都是一样的，所以可以忽略这个常数。</p>\n<p>则<br>$$<br>P(h|D) \\varpropto P(h)P(D|h)<br>$$</p>\n<blockquote>\n<p>$P(D|h)$可以根据某种指标来判定，可以看键盘上字母的编辑距离来算概率等等。</p>\n</blockquote>\n<p>如果计算出来多个结果预测概率是一样的，那么就可以使用<strong>先验概率</strong>来进行判断谁最优先。</p>\n<h2 id=\"1-2-拼写检查器实现\"><a href=\"#1-2-拼写检查器实现\" class=\"headerlink\" title=\"1.2 拼写检查器实现\"></a>1.2 拼写检查器实现</h2><p>原理：<br>$$<br>argmaxc \\ P(A|B) = argmaxc \\  \\frac{P(B|A) P(A)}{P(B)}<br>$$</p>\n<p>$P(A|B)$：待求值，用户本想输入B的前提下，错输成A的概率</p>\n<p>$P(A)$：文章中出现正确单词A的概率</p>\n<p>$P(B|A)$：用户本想输入A的前提下，错输成B的概率</p>\n<p>$P(B)$：文章中出现正确单词B的概率</p>\n<p>$argmaxc$：用来枚举所有可能的A，并选取概率最大的那个</p>\n<p>拼写检查器就是，输入一个单词，先判断这个单词是否存在于语料库中（是否正确），如果不在（可能语料库中没有，或者拼写错误），则需要根据编辑距离进行检查修正。</p>\n<p><code>big.txt</code>文件：<a href=\"https://wwwi.lanzouo.com/i9s8t0ju5qzg\" target=\"_blank\" rel=\"noopener\">https://wwwi.lanzouo.com/i9s8t0ju5qzg</a></p>\n<pre><code class=\"python\">import re, collections\n\n#  将所有大写字母转化为小写，并且去掉特殊字符\ndef words(text): return re.findall(&#39;[a-z]+&#39;, text.lower())\n\ndef train(features):\n    # 遇到从来没有见过的新词但语料库中未包含，概率模型中希望返回一个很小的概率，故出现次数设置为1\n    model = collections.defaultdict(lambda: 1)\n    for f in features:\n        model[f] += 1\n    return model\n\n\nNWORDS = train(words(open(&#39;big.txt&#39;).read()))  # 词频\nalphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;\n\n# 编辑距离为1的单词\ndef edits1(word):\n    n = len(word)\n    return set([word[0: i] + word[i + 1:] for i in range(n)] +   # deletion\n               [word[0: i] + word[i + 1] + word[i] + word[i + 2:] for i in range(n - 1)] +  # transportation\n               [word[0: i] + c + word[i + 1: ] for i in range(n) for c in alphabet] +  # alteration\n               [word[0: i] + c + word[i: ] for i in range(n + 1) for c in alphabet])  # insertion\n\n\n# 编辑距离为2 的单词\ndef edits2(word):\n    return set(e2 for e1 in edits1(word) for e2 in edits1(e1))\n\n\n# 将那些正确的词作为候选词\ndef known(words):\n    return set(w for w in words if w in NWORDS)\n\n\n# 检查器函数，先判断是不是正确的拼写形式，如果不是则选出编辑距离为1的单词……\ndef correct(word):\n    candidates = known([word]) or known(edits1(word)) or known(edits2(word)) or [word]\n    return max(candidates, key=lambda w: NWORDS[w])\n\n\nprint(correct(&#39;mach&#39;))</code></pre>\n<h2 id=\"1-3-新闻分类\"><a href=\"#1-3-新闻分类\" class=\"headerlink\" title=\"1.3 新闻分类\"></a>1.3 新闻分类</h2><p>之后用到了再补，短时间不会写。</p>\n<h1 id=\"SVM支持向量机\"><a href=\"#SVM支持向量机\" class=\"headerlink\" title=\"SVM支持向量机\"></a>SVM支持向量机</h1><h2 id=\"1-概述-3\"><a href=\"#1-概述-3\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>Support Vector Machine是一种二分类模型，它的基本模型是定义在特征空间上的<strong>间隔最大的线性分类器</strong></p>\n<p>SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $wx+b=0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。</p>\n<p><img src=\"808139430/image-20230102144808362.png\" alt=\"支持向量机\"></p>\n<h2 id=\"2-推导\"><a href=\"#2-推导\" class=\"headerlink\" title=\"2 推导\"></a>2 推导</h2><h3 id=\"2-1-距离\"><a href=\"#2-1-距离\" class=\"headerlink\" title=\"2.1 距离\"></a>2.1 距离</h3><p>正常三维条件下点$(x_0, y_0, z_0)$到平面$Ax + By + Cz + D = 0$的距离公式（高中知识）：<br>$$<br>\\frac{\\vert Ax_0 + By_0 + Cz_0 + D \\vert}{\\sqrt{A^2 + B^2 + C^2}}<br>$$<br>推导分析过程：</p>\n<p>平面方程： $ax + by + cz = d$ ，平面外一点$P(x_0, y_0, z_0)$</p>\n<p><img src=\"808139430/image-20230102153203878.png\" alt=\"示意图\"></p>\n<p>PQ垂直平面，即为求PQ的长度，但不知Q点的具体数据。</p>\n<p>故构造一个平面上的点$P^{‘}(x_1, y_1, z_1)$，问题即转化为求$\\overrightarrow {P^{‘}P}$ 在法向量N上面的分量，即$\\overrightarrow {P^{‘}P}$ 与N相同方向的单位向量的点积。</p>\n<p><img src=\"808139430/image-20230102153230935.png\" alt=\"示意图\"></p>\n<p>设距离为D。</p>\n<p><img src=\"808139430/1203675-20180109152428254-718844217.png\" alt=\"距离公式推导\"></p>\n<p>现在考虑一般情况：</p>\n<p>求平面外一点 $x$ 到平面$w^T x + b = 0$ 的距离：</p>\n<blockquote>\n<p>结论：平面$Ax + By + Cz + D = 0$的法向量为$(A, B, C)$</p>\n</blockquote>\n<p><img src=\"808139430/image-20230102154354917.png\" alt=\"示意图\"></p>\n<p>同上述原理：</p>\n<p>距离就为<br>$$<br>distance(x, b, w) = \\vert \\frac{w^T}{\\vert w \\vert}(x - x^{‘}) \\vert = \\frac{1}{\\vert w \\vert} \\vert w^Tx + b \\vert<br>$$</p>\n<blockquote>\n<p>上述公式进行了代入，将$x^{‘}$代入平面方程得$w^Tx^{‘} = -b$</p>\n</blockquote>\n<h3 id=\"2-2-数据\"><a href=\"#2-2-数据\" class=\"headerlink\" title=\"2.2 数据\"></a>2.2 数据</h3><p>数据集：$(x_1, y_1)(x_2, y_2)…(x_n, y_n)$</p>\n<p>$Y$ 为样本的类别：当$X$ 为正例时，$Y = +1$，当$X$为负例时，$Y = -1$</p>\n<p>决策方程：$y(x) = w^T \\Phi(x) + b$ （其中$\\Phi(x)$是对数据做了变换）<br>$$<br>\\begin{cases}<br>y(x_i) &gt; 0 \\Leftrightarrow y_i = +1 \\\\<br>y(x_i) &lt; 0 \\Leftrightarrow y_i = -1<br>\\end{cases}<br>\\Longrightarrow<br>y_i y(x_i) &gt; 0<br>$$</p>\n<h3 id=\"2-3-目标函数求解\"><a href=\"#2-3-目标函数求解\" class=\"headerlink\" title=\"2.3 目标函数求解\"></a>2.3 目标函数求解</h3><p>将点到直线距离进行转化（化简）：<br>$$<br>\\frac{y_i \\cdot (w^T \\cdot \\Phi(x) + b)}{\\vert w \\vert}<br>$$</p>\n<blockquote>\n<p>$y_i y(x_i) &gt; 0$ 直接乘上$y_i$ 将绝对值去掉，$|y_i| = 1$，并不影响值大小</p>\n</blockquote>\n<p>放缩变换：对于决策方程（w, b）可以通过放缩变换是的其结果值$|Y| \\geq 1$ ，则<br>$$<br>y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1<br>$$</p>\n<blockquote>\n<p>缩放之前w和b有无数组解，缩放之后w和b只有一组解。</p>\n</blockquote>\n<p>优化目标：<br>$$<br>\\mathop{arg\\  max} \\limits_{w, b} \\bigg\\{ \\frac{1}{|w|} \\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b)\\Big \\} \\bigg\\}<br>$$</p>\n<blockquote>\n<p>$\\mathop{min} \\limits_i \\Big \\{ y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\Big \\}$ 是求所有样本点到平面的最小距离的那个点</p>\n<p>$arg\\ max$ 是<strong>最大化到平面最小距离的点的距离</strong></p>\n<p>由于$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$， 故最小值为1，只需要考虑 $\\mathop{arg\\  max} \\limits_{w, b} \\frac{1}{|w|}$</p>\n</blockquote>\n<p>当前目标变为：$\\mathop{max} \\limits_{w, b} \\frac{1}{|w|}$，即求$|w|$的最小值，但有约束条件 $y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$</p>\n<p>将求极大值转化为求极小值的问题，求$\\frac{1}{2}w^2$ 的最小值。</p>\n<p>需要使用<strong>拉格朗日乘子法</strong>：（此处不做证明，直接给出结论，我还不知道$\\alpha$的作用，呜呜呜）<br>$$<br>L(w, b, \\alpha) = \\frac{1}{2}|w|^2 - \\sum \\limits_{i = 1}^n \\alpha_i (y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) - 1)<br>$$</p>\n<blockquote>\n<p>上式需要满足约束条件：$y_i \\cdot (w^T \\cdot \\Phi(x_i) + b) \\geq 1$</p>\n</blockquote>\n<p><img src=\"808139430/image-20230102224841617.png\" alt=\"求解过程\"></p>\n<p><img src=\"808139430/image-20230102225344026.png\" alt=\"求解过程\"></p>\n<p><img src=\"808139430/image-20230102225422893.png\" alt=\"求解过程\"></p>\n<h2 id=\"3-SVM实例\"><a href=\"#3-SVM实例\" class=\"headerlink\" title=\"3 SVM实例\"></a>3 SVM实例</h2><p>有三个数据：3个点，正例$x_1(3, 3), x_2(4, 3)$， 负例$x_3(1, 1)$，（数据是二维数据）对其进行二分类。</p>\n<p>首先需要求解下式的最小值：<br>$$<br>\\frac{1}{2}\\sum \\limits_{i = 1}^n \\sum \\limits _{j = 1}^n \\alpha_i \\alpha_j y_i y_j (x_i \\cdot x_j) - \\sum \\limits_{i = 1}^n\\alpha_i \\hspace{3em} (1)<br>$$</p>\n<blockquote>\n<p>注意：$x_i \\cdot x_j$ 的运算是点积运算。</p>\n<p>约束条件：<br>$$<br>\\alpha_1 + \\alpha_2 - \\alpha_3 = 0 \\\\<br>\\alpha_i \\geq 0, \\hspace{2em} i = 1, 2, 3<br>$$</p>\n</blockquote>\n<p><img src=\"808139430/image-20230103144319179.png\" alt=\"图像示意\"></p>\n<p>将对应的数据带入（1）式，得：<br>$$<br>\\frac{1}{2} \\Big( 18 \\alpha_1^2 + 25\\alpha_2^2 + 2 \\alpha_3^2 + 42\\alpha_1\\alpha_2 - 12\\alpha_1\\alpha_3 - 14\\alpha_2\\alpha_3 \\Big) - \\alpha_1 - \\alpha_2 - \\alpha_3<br>$$<br>由于$\\alpha_1 + \\alpha_2 = \\alpha_3$，化简得：<br>$$<br>4 \\alpha_1 ^ 2 + \\frac{13}{2} \\alpha_2^2 + 10\\alpha_1\\alpha_2 - 2\\alpha_1 - 2\\alpha_2<br>$$<br>分别对$\\alpha_1,\\alpha_2$求偏导，偏导等于0得<br>$$<br>\\begin{cases}<br>\\alpha_1 = 1.5 \\\\<br>\\alpha_2 = -1<br>\\end{cases}<br>$$<br>发现不满足约束条件$\\alpha_i \\geq 0$，故解应在边界上。分别让两个值等于0求解<br>$$<br>\\begin{cases}<br>\\alpha_1 = 0 \\\\<br>\\alpha_2 = -\\frac{2}{13}<br>\\end{cases}<br>(\\times)<br>\\hspace{4em}<br>\\begin{cases}<br>\\alpha_1 = 0.25 \\\\<br>\\alpha_2 = 0<br>\\end{cases}<br>(\\checkmark)<br>$$<br>第一组解不满足，故最小值在$(0.25, 0.25)$处取得。</p>\n<p>将$\\alpha$结果带求解$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$，$\\Phi(x_i)$以$x_i$来代替<br>$$<br>w = \\frac{1}{4} \\times 1 \\times (3,3) + \\frac{1}{4} \\times (-1) \\times(1,1) = (\\frac{1}{2}, \\frac{1}{2})<br>\\\\<br>b = y_i - \\sum \\limits_{i = 1}^n a_i y_i (x_i x_j) = 1 - (\\frac{1}{4} \\times 1 \\times 18  + \\frac{1}{4} \\times (-1) \\times 6) = -2<br>$$<br>故平面方程为：<br>$$<br>0.5 x_1 + 0.5 x_2 - 2 = 0<br>$$</p>\n<blockquote>\n<p>因为$w = \\sum \\limits_{i = 1}^n \\alpha_i y_i \\Phi(x_i)$</p>\n<p>支持向量的$\\alpha$值不等于0，$\\alpha = 0$的向量不是支持向量，对最终结果没有影响。</p>\n<p>支持向量就是那些对最终结果起作用的向量，也可以当做是边界上的向量。</p>\n</blockquote>\n<h2 id=\"4-软间隔\"><a href=\"#4-软间隔\" class=\"headerlink\" title=\"4 软间隔\"></a>4 软间隔</h2><p>数据中有时候会有一些噪音点，如果考虑它们结果可能不会很好。</p>\n<p>为解决该问题，引入松弛因子：$y_i(w \\cdot x_i + b) \\geq 1 - \\xi_i$</p>\n<p>新的目标函数：<br>$$<br>min \\frac{1}{2} |w|^2 + C \\sum \\limits _{i = 1}^n \\xi_i<br>$$</p>\n<blockquote>\n<p>C是我们需要指定的一个参数</p>\n<p>当C趋近于很大时：意味着分类严格不能有错误</p>\n<p>当C趋近于很小时：意味着可以由更大的错误容忍</p>\n</blockquote>\n<p>解法基本一样：</p>\n<p><img src=\"808139430/image-20230103153918323.png\" alt=\"解法\"></p>\n<h2 id=\"5-SVM核变换\"><a href=\"#5-SVM核变换\" class=\"headerlink\" title=\"5 SVM核变换\"></a>5 SVM核变换</h2><p>将低维不可分映射到高维，找到一种变换方法，即为$\\phi(x)$</p>\n<p>高斯核函数：<br>$$<br>K(X, Y) =  exp \\bigg\\{ -\\frac{||X-Y||^2}{2\\sigma^2} \\bigg\\}<br>$$</p>\n<h2 id=\"6-基于sklearn求解SVM\"><a href=\"#6-基于sklearn求解SVM\" class=\"headerlink\" title=\"6 基于sklearn求解SVM\"></a>6 基于sklearn求解SVM</h2><p>参考 <a href=\"https://blog.csdn.net/weixin_42600072/article/details/88644229\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42600072/article/details/88644229</a></p>\n<h1 id=\"K-MEANS算法\"><a href=\"#K-MEANS算法\" class=\"headerlink\" title=\"K-MEANS算法\"></a>K-MEANS算法</h1><h2 id=\"1-概述-4\"><a href=\"#1-概述-4\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>聚类概念：这是个无监督问题（没有标签数据），目的是将相似的东西分到一组。</p>\n<p>通常使用的算法是K-MEANS算法</p>\n<blockquote>\n<p>K-MEANS算法：</p>\n<ul>\n<li>需要指定簇的个数，即K值</li>\n<li>质心：数据的均值，即向量各维取平均即可</li>\n<li>距离的度量：常用欧几里得距离和余弦相似度（先标准化，让数据基本都是在一个比较小的范围内浮动）</li>\n<li>优化目标：$min\\sum \\limits_{i = 1}^K \\sum \\limits_{x \\in C_i} dist(c_i, x)^2$ （对于每一个簇让每一个样本到中心点的距离越小越好，$c_i$代表中心点）</li>\n</ul>\n</blockquote>\n<h2 id=\"2-K-MEANS流程\"><a href=\"#2-K-MEANS流程\" class=\"headerlink\" title=\"2 K-MEANS流程\"></a>2 K-MEANS流程</h2><p>假设平面上有一系列样本点，现在需要将其进行分组。</p>\n<p>选定<code>K=2</code>，即将这些数据点分成两个组别。</p>\n<ul>\n<li>随机选择两个质心（分别代表两个簇），计算所有样本点到两个质心的距离。每个样本点会计算出到两个质心的距离，那么选择最小的距离，这个样本点就归属于哪个簇。</li>\n<li>然后对于两个簇的所有样本点分别算出对应的质心（这两个质心便充当新的质心），再对所有样本点计算到两个新的质心的距离，还是选择最小的距离，那么这个样本点就归属于哪个簇。</li>\n<li>最终直到两个簇所属的样本点不在发生变化。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://www.bilibili.com/video/BV1bt411i77G?p=101&vd_source=bb4ca29d8dfb2e3c28c10bb09f4b962e\" target=\"_blank\" rel=\"noopener\">K-MEANS工作流程视频参考</a></p>\n</blockquote>\n<h2 id=\"3-优缺点\"><a href=\"#3-优缺点\" class=\"headerlink\" title=\"3 优缺点\"></a>3 优缺点</h2><p>优点：</p>\n<ul>\n<li>简单快速，适合常规数据集</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>K值难以确定</li>\n<li>复杂度与样本呈线性关系</li>\n<li>很难发现任意形状的簇</li>\n<li>初始的点影响很大</li>\n</ul>\n<blockquote>\n<p> <a href=\"https://www.naftaliharris.com/blog/visualizing-k-means-clustering/\" target=\"_blank\" rel=\"noopener\">K-MEANS可视化演示</a></p>\n</blockquote>\n<h2 id=\"4-K-MEANS进行图像压缩\"><a href=\"#4-K-MEANS进行图像压缩\" class=\"headerlink\" title=\"4 K-MEANS进行图像压缩\"></a>4 K-MEANS进行图像压缩</h2><pre><code class=\"python\">from skimage import io\nfrom sklearn.cluster import KMeans\nimport numpy as np\n\nimage = io.imread(&quot;1.jpg&quot;)\nio.imshow(image)\n# io.show()  # 显示图片\n\nrows = image.shape[0]\ncols = image.shape[1]\nprint(image.shape)\n\nimage = image.reshape(rows * cols, 3)\nkmeans = KMeans(n_clusters=128, n_init=10, max_iter=100)  # 簇128, 最大迭代次数100\nkmeans.fit(image)\n\nclusters = np.asarray(kmeans.cluster_centers_, dtype=np.uint8)\nlabels = np.asarray(kmeans.labels_, dtype=np.uint8)\nlabels = labels.reshape(rows, cols)\n\nprint(clusters.shape)\nnp.save(&#39;test.npy&#39;, clusters)\nio.imsave(&#39;compressed.jpg&#39;, labels)</code></pre>\n<h1 id=\"DBSCAN算法\"><a href=\"#DBSCAN算法\" class=\"headerlink\" title=\"DBSCAN算法\"></a>DBSCAN算法</h1><h2 id=\"1-概述-5\"><a href=\"#1-概述-5\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种<strong>基于密度的空间聚类算法</strong>。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间<a href=\"https://cloud.tencent.com/solution/database?from=10680\" target=\"_blank\" rel=\"noopener\">数据库</a>中发现任意形状的簇，DBSCAN算法将<code>簇</code>定义为密度相连的点的最大集合。</p>\n<p>核心对象：若某个点的密度达到算法设定的阈值则称其为核心点。（即<code>r</code>邻域内的点的数量不小于<code>minPts</code>）</p>\n<p>基于以上密度的定义，我们可以将样本集中的点划分为以下三类：</p>\n<ul>\n<li><strong>核心点</strong>：在半径r区域内，含有超过MinPts数目（最小数目）的点，称为核心点；</li>\n<li><strong>边界点</strong>：在半径r区域内，点的数量小于MinPts数目，但是是核心点的直接邻居；</li>\n<li><strong>噪声点</strong>：既不是核心点也不是边界点的点</li>\n</ul>\n<blockquote>\n<p>噪声点是不会被聚类纳入的点，边界点与核心点组成聚类的“簇”。</p>\n</blockquote>\n<p>一些概念：</p>\n<ul>\n<li><strong>直接密度可达</strong>：在给定一个对象集合D，如果p在q的r领域内，且<strong>q是一个核心点对象</strong>，则称对象p从对象q出发时是直接密度可达的</li>\n<li><strong>密度可达</strong>：在给定对象集合D中，如果存在一个对象链q–&gt;e–&gt;a–&gt;k–&gt;l–&gt;p，任意相邻两个对象间都是直接密度可达的，则称对象p是对象q关于r邻域内、MinPts数目下，是密度可达的；</li>\n<li><strong>密度相连</strong>：如果在对象集合D中存在一个对象O，使得对象p和q都是从O关于r邻域内、MinPts数目下，是密度相连的。</li>\n</ul>\n<blockquote>\n<p>核心点能够连通（密度可达），它们构成的以r为半径的圆形邻域相互连接或重叠，这些连通的核心点及其所处的邻域内的全部点构成一个簇。</p>\n</blockquote>\n<h2 id=\"2-原理\"><a href=\"#2-原理\" class=\"headerlink\" title=\"2 原理\"></a>2 原理</h2><ol>\n<li>DBSCAN通过检查数据集中每个点的r邻域来搜索簇，如果点p的r邻域包含多于MinPts个点，则创建一个以p为核心对象的簇；</li>\n<li>然后， DBSCAN迭代的聚集从这些核心对象直接密度可达的对象，这个过程可能涉及一些密度可达簇的合并；</li>\n<li>当没有新的带你添加到任何簇时，迭代过程结束。</li>\n</ol>\n<p>优缺点：</p>\n<ul>\n<li><p>优点：基于密度定义，可以对抗噪声，能处理任意形状和大小的簇</p>\n</li>\n<li><p>缺点：当簇的密度变化太大时候，聚类得到的结果会不理想；对于高维问题，密度定义也是一个比较麻烦的问题。</p>\n</li>\n</ul>\n<h2 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3 实现\"></a>3 实现</h2><pre><code class=\"python\">import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\nimport matplotlib.colors\n\n# 创建Figure\nfig = plt.figure()\n# 用来正常显示中文标签\nmatplotlib.rcParams[&#39;font.sans-serif&#39;] = [u&#39;SimHei&#39;]\n# 用来正常显示负号\nmatplotlib.rcParams[&#39;axes.unicode_minus&#39;] = False\n\nX1, y1 = datasets.make_circles(n_samples=5000, factor=.6,\n                                      noise=.05)\nX2, y2 = datasets.make_blobs(n_samples=1000, n_features=2,\n                             centers=[[1.2,1.2]], cluster_std=[[.1]],random_state=9)\n\n# 原始点的分布\nax1 = fig.add_subplot(311)\nX = np.concatenate((X1, X2))\nplt.scatter(X[:, 0], X[:, 1], marker=&#39;o&#39;)\nplt.title(u&#39;原始数据分布&#39;)\nplt.sca(ax1)\n\n# K-means聚类\nfrom sklearn.cluster import KMeans\nax2 = fig.add_subplot(312)\ny_pred = KMeans(n_clusters=3, random_state=9).fit_predict(X)\nplt.scatter(X[:, 0], X[:, 1], c=y_pred)\nplt.title(u&#39;K-means聚类&#39;)\nplt.sca(ax2)\n\n# DBSCAN聚类\nfrom sklearn.cluster import DBSCAN\nax3 = fig.add_subplot(313)\ny_pred = DBSCAN(eps = 0.1, min_samples = 10).fit_predict(X)\nplt.scatter(X[:, 0], X[:, 1], c=y_pred)\nplt.title(u&#39;DBSCAN聚类&#39;)\nplt.sca(ax3)\n\nplt.show()</code></pre>\n<h1 id=\"PCA主成分分析\"><a href=\"#PCA主成分分析\" class=\"headerlink\" title=\"PCA主成分分析\"></a>PCA主成分分析</h1><p>Principal Component Analysis：降维中最常用的一种手段</p>\n<h2 id=\"1-基变换\"><a href=\"#1-基变换\" class=\"headerlink\" title=\"1 基变换\"></a>1 基变换</h2><p>目标：提取最有价值的信息（基于方差）</p>\n<ul>\n<li><p>基概念：例如在二维坐标系中，向量（3，4）也可表示为线性组合$x(1, 0) + y(0, 1)$，而$(0,1)(1,0)$叫做二维空间的一组基。</p>\n</li>\n<li><p>基变换</p>\n<ul>\n<li><p>要求：基是正交的（内积/点积为0，或者说互相垂直，线性无关）</p>\n</li>\n<li><p>变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量；数据与第二个基做内积运算，结果作为第二个新的坐标分量。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>比如$(3,2)$映射到基的坐标：<br>$$<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt{2}} &amp; \\frac{1}{\\sqrt{2}} \\\\<br>-\\frac{1}{\\sqrt{2}} &amp; \\frac{1}{\\sqrt{2}}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>3 \\\\<br>2<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>\\frac{5}{\\sqrt 2} \\\\<br>-\\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>$$</p>\n<ul>\n<li>基变换一般公式：</li>\n</ul>\n<p>$$<br>\\begin{pmatrix}<br>p_1 \\\\<br>p_2 \\\\<br>\\vdots \\\\<br>p_n<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \\cdots &amp;a_m<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>p_1a_1 &amp; p_1a_2 &amp; \\cdots &amp; p_1a_m \\\\<br>p_2a_1 &amp; p_2a_2 &amp; \\cdots &amp; p_2a_m \\\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\<br>p_na_1 &amp; p_na_2 &amp; \\cdots &amp; p_na_m \\\\<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>等式左边的两个矩阵中，左边是基，右边是数据。</p>\n<p>两个矩阵相乘的意义是将右边的矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。</p>\n</blockquote>\n<h2 id=\"2-协方差矩阵\"><a href=\"#2-协方差矩阵\" class=\"headerlink\" title=\"2 协方差矩阵\"></a>2 协方差矩阵</h2><p>我们希望选择一个方向（基）：数据能够保留更多的原始信息，也可以说希望经过某个基投影后的投影值尽可能分散。（雾</p>\n<p>方差：<br>$$<br>Var(a) = \\frac{1}{m} \\sum \\limits_{i = 1}^m (a_i - \\mu)^2<br>$$<br>寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，<strong>方差值最大</strong>（分散）。</p>\n<p>协方差：（假设均值为0时）（对于标签$a_i, b_i$，如果两个相似度越大，协方差越大）<br>$$<br>Cov(a, b) = \\frac{1}{m} \\sum \\limits_{i = 1}^m a_ib_i<br>$$</p>\n<blockquote>\n<p>如果单纯选择方差最大的方向，后续方向应该会和方差最大的方向接近重合。</p>\n<p>解决方案：为了让两个子段尽可能表示更多的原始信息，我们是不希望他们之间存在（线性）相关性的。</p>\n<p>可以用两个字段的协方差表示相关性，当协方差为0时，代表两个字段是相互独立的。</p>\n</blockquote>\n<p>题意：将一组N维向量降为K维，目标是选择K个单位的正交基，使原始数据变换到这组基上面后，各字段两两之间协方差为0，字段方差尽可能大。</p>\n<p>$$<br>\\text{特征数据}X =<br>\\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \\cdots &amp; a_m \\\\<br>b_1 &amp; b_2 &amp; \\cdots &amp; b_m<br>\\end{pmatrix}<br>$$<br>协方差矩阵：<br>$$<br>\\frac{1}{m}XX^T =<br>\\begin{pmatrix}<br>\\frac{1}{m}\\sum \\limits_{i = 1}^m a_i^2  &amp; \\frac{1}{m}\\sum \\limits_{i = 1}^ma_ib_i \\\\<br>\\frac{1}{m}\\sum \\limits_{i = 1}^m a_ib_i &amp; \\frac{1}{m}\\sum \\limits_{i = 1}^mb_i^2<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>矩阵对角线上的两个元素分别为两个字段的方差（假设均值为0），而其他元素是a和b的协方差。</p>\n</blockquote>\n<h2 id=\"3-优化\"><a href=\"#3-优化\" class=\"headerlink\" title=\"3 优化\"></a>3 优化</h2><p>接下来就是希望让协方差矩阵的除对角线位置的元素为0（协方差为0），就是进行对角化操作。</p>\n<p>协方差矩阵对角化：<br>$$<br>PCP^T = \\Lambda =<br>\\begin{pmatrix}<br>\\lambda_1 \\\\<br>&amp; \\lambda_2 \\\\<br>&amp; &amp; \\ddots \\\\<br>&amp; &amp; &amp; \\lambda_n<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>结论：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量<br>$$<br>E = \\begin{pmatrix} e_1 &amp; e_2 &amp; \\cdots &amp; e_n\\end{pmatrix}<br>$$<br>实对称矩阵可以进行对角化：<br>$$<br>ECE^T = \\Lambda =<br>\\begin{pmatrix}<br>\\lambda_1 \\\\<br>&amp; \\lambda_2 \\\\<br>&amp; &amp; \\ddots \\\\<br>&amp; &amp; &amp; \\lambda_n<br>\\end{pmatrix}<br>$$</p>\n</blockquote>\n<p>将特征值从大到小排列，用前K行组成的矩阵乘原始数据矩阵X，就得到降维后的数据矩阵Y。</p>\n<h2 id=\"4-示例\"><a href=\"#4-示例\" class=\"headerlink\" title=\"4 示例\"></a>4 示例</h2><p>数据（共5个数据，每个数据2个特征点）<br>$$<br>\\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\\end{pmatrix}<br>$$<br>协方差矩阵<br>$$<br>C = \\frac{1}{5}<br>\\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>-1 &amp; -2 \\\\<br>-1 &amp; 0 \\\\<br>0 &amp; 0 \\\\<br>2 &amp; 1 \\\\<br>0 &amp; 1<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>\\frac{6}{5} &amp; \\frac{4}{5} \\\\<br>\\frac{4}{5} &amp; \\frac{6}{5}<br>\\end{pmatrix}<br>$$<br>特征值<br>$$<br>\\lambda_1 = 2, \\lambda_2 = \\frac{2}{5}<br>$$<br>特征向量<br>$$<br>c_1<br>\\begin{pmatrix}<br>1 \\\\<br>1<br>\\end{pmatrix} ,<br>c_2<br>\\begin{pmatrix}<br>-1 \\\\<br>1<br>\\end{pmatrix}<br>$$<br>对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量$c_1$这个<br>$$<br>PCP^T =<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2} \\\\<br>-\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>\\frac{6}{5} &amp; \\frac{4}{5} \\\\<br>\\frac{4}{5} &amp; \\frac{6}{5}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt 2} &amp; -\\frac{1}{\\sqrt 2} \\\\<br>\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>2 &amp; 0 \\\\<br>0 &amp; \\frac{2}{5}<br>\\end{pmatrix}<br>$$<br>降维<br>$$<br>Y =<br>\\begin{pmatrix}<br>\\frac{1}{\\sqrt 2} &amp; \\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>-\\frac{3}{\\sqrt 2} &amp; -\\frac{1}{\\sqrt 2} &amp; 0 &amp; \\frac{3}{\\sqrt 2} &amp; -\\frac{1}{\\sqrt 2}<br>\\end{pmatrix}<br>$$</p>\n<blockquote>\n<p>机器学习实战参考：<a href=\"https://blog.csdn.net/weixin_42600072/category_8751294.html\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42600072/category_8751294.html</a></p>\n</blockquote>\n"},{"title":"容斥定理","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":1292892888,"date":"2022-06-25T09:36:11.000Z","password":null,"summary":null,"_content":"\n﻿﻿# 容斥定理\n\n## 简单版本：\n\n![简单版本](1292892888/a188f738744e4afb8c5f7e745640cdd9.png)\n对于上述图片，求$|A\\cup B \\cup C|$\n结果为$|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|B\\cap C|-|C\\cap A|+|A\\cap B\\cap C|$\n\n## 一般情况\n\n公式：$\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i<a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right|$\n\n大家应该是看不懂吧，反正我是看不懂\n\n我理解的通俗的意思就是：\n\n`n`个集合的并集**等于**`n`个集合选择一个的情况中所有情况的交-`n`个集合中选择两个所有情况中两两的交+`n`个集合中选择三个中所有情况三个的交-选择四种的交+选择五种的交-......\n\n稍微用公式表示一下：\n$|A_1\\cup...\\cup A_n| = \\\\\n|A_1|+|A_2|+...+|A_n|\\\\\n-(|A_1 \\cap A_2|+...+|A_i \\cap A_j|)\\\\\n+(|A_1 \\cap A_2 \\cap A_3|+...+|A_i \\cap A_j \\cap A_k|)\\\\\n-(四个之间的交)\\\\\n+(五个之间的交)\\\\\n......$\n\n大概就是这个意思。\n\n - 选择的个数为偶数次，前面符号为负\n- 选择的个数为奇数次，前面符号为正\n\n\n参考链接：\n[https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)\n\n## 例题1 能被整除的数\n\n题目链接：[https://www.acwing.com/problem/content/892/](https://www.acwing.com/problem/content/892/)\n\n>给定一个整数 `n`和 `m` 个不同的质数 $p_1,p_2,…,p_m$。\n>请你求出 1∼n 中能被 $p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。\n\n---\n\n**思路：**\n\n>先简单的举个例子：\n>质数有2，3，5，7，11五个\n>能被2整除的有2，4，6，8 ....\n>能被3整除的有3，6，9，12....\n>...\n>问的是被至少一个整除就行，那么上述例子中6是重复的\n>也就是我们可以把能被**一个质数整除的个数**当作**一个集合**，这么多质数组成的集合有重合的，我们要求的是这么多集合的并集，满足容斥定理\n\n在`1-n`中能被`x`整除的个数：$\\lfloor \\frac{n}{x}\\rfloor$\n在`1-n`中能被`x,y`整除的个数：$\\lfloor \\frac{n}{xy}\\rfloor$\n在`1-n`中能被`x,y,z`整除的个数：$\\lfloor \\frac{n}{xyz}\\rfloor$\n......\n然后就可以根据公式求结果，有`m`个质数，共有`m`个集合，每次会选中若干个集合，代表几个之间的交集（参照上面容斥定理公式）\n\n>几个集合之间的交集：就是一个数能**同时**被这选中的几个质数整除\n\n选中集合个数为偶数，前面符号为**负**\n选中集合个数为奇数，前面符号为**正**\n\n>枚举所有的集合：\n>我们采用二进制的方法，枚举$[1,2^{m}-1]$,统计其中`1`的个数即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 20;\nint p[N];\nint n,m;\n\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++) cin>>p[i];\n\t\n\tll res = 0;\n\tfor(int i=1;i< 1<<m ;i++)\n\t{\n\t\tint cnt = 0;\n\t\tll t = 1;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif( i>>j & 1)\n\t\t\t{\n\t\t\t\tcnt ++ ;//统计选中的个数\n\t\t\t\tif(t * p[j] > n)//不满足条件，因为大于n了\n\t\t\t\t{\n\t\t\t\t\tt = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt *= p[j];\n\t\t\t}\n\t\t}\n\t\tif(t!=-1)\n\t\t{\n\t\t\tif(cnt%2) res += n/t;\n\t\t\telse res -= n/t; \n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n---\n\n## 例题2 \n\n题目链接:[https://www.acwing.com/problem/content/216/](https://www.acwing.com/problem/content/216/)\n\n>Devu 有 `N` 个盒子，第 `i` 个盒子中有 $A_i$ 枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu 要从这些盒子中选出 `m` 枝花组成一束，求共有多少种方案。若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。结果需对 $10^9+7$ 取模之后方可输出\n\n---\n\n**思路**\n\n\n- 理想情况\n\n首先去掉限制考虑理想情况，即每个盒子的花的个数有无限个，设第$i$个盒子取出$x_i$朵花\n\n则$x_1+x_2+x_3+...+x_n=  m,x_i \\geq 0$,总方案数为$C_{n+m-1}^{n-1}$种\n\n可以参考链接查看如何计算 :\n[https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)\n\n---\n\n- 有限制的情况\n\n限制条件下：\n$x_1+x_2+x_3+...+x_n=  m,x_1<=A_1,x_2<=A_2,x_3<=A_3……x_n<=A_n$\n\n$x_1,x_2,...,x_n$同时满足限制条件才可，我们考虑从补集去求（总情况数减去相反的情况）\n\n补集情况下：\n\n$x_1+x_2+x_3+...+x_n=  m,x_1>A_1,x_2>A_2,x_3>A_3……x_n>A_n$\n第`i`个限制（$x_i>A_i$）的情况满足个数我们当作一个集合$s_i$\n\n- 总数：$C_{n+m-1}^{n-1}$\n- 题目的补集：$|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$\n- 结果为：$C_{m+n-1}^{n-1}-|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$\n\n考虑求满足$s_1$的情况数\n即第一个必须取至少$A_i+1$支花，那么接下来就化为从`n`组里面选花，$x_1>=A_1+1,x_2>=0,x_3>=0,...,x_n>=0$的情况，可以直接取出$A_i+1$支花放在第一组，那么总数就变成$m-(A_1+1)$支花，就化为**理想情况**(见上文)下的问题了，总数为$C_{m+n-1-(A_1+1)}^{n-1}$\n\n$s_1\\cap s_2$同理\n答案为$C_{m+n-1-(A_1+1)-(A_2+1)}^{n-1}$\n\n最后枚举所有的情况数，使用二进制方法进行枚举，枚举$[0,2^n-1]$,统计二进制位`1`的个数\n\n奇数个`1`符号为负\n偶数个`1`符号位正\n\n```cpp\n#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N = 20,mod = 1e9+7;\n\nll a[N];\nll d = 1;\n\nll fast(ll a,ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll C(ll x,ll y)\n{\n\tif(x < y) return 0;\n\tll u = 1;\n\tfor(ll i = x;i>x-y;i--) u = i % mod * u % mod;\n\treturn u * d % mod;\n}\n\nint main()\n{\n\tll n,m;\n\tcin >> n >> m;\n\tfor ( int i=0;i<n;i++) cin>>a[i];\n\t\n\tfor(ll i=1;i<=n-1;i++) d = d * i % mod;\n\td = fast(d,mod-2);\n\t\n\tll res = 0 ;\n\tfor(int i=0; i< 1<<n;i++)\n\t{\n\t\t//组合数的下角标   上角标\n\t\tll down = n + m -1,up = n-1;\n\t\tint sign = 1;//标记的符号位\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i>>j&1)\n\t\t\t{\n\t\t\t\tdown -= a[j]+1;//下角标减去对应的个数\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t}\n\t\tres = (res + C(down,up) * sign)%mod; //计算组合数，统计答案\n\t}\n\tcout<<(res + mod) % mod<<endl; \n\treturn 0;\n}\n\n```\n","source":"_posts/容斥定理.md","raw":"---\ntitle: 容斥定理\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags: 数论\ncategories: 数论\nabbrlink: 1292892888\ndate: 2022-06-25 17:36:11\npassword:\nsummary:\n---\n\n﻿﻿# 容斥定理\n\n## 简单版本：\n\n![简单版本](1292892888/a188f738744e4afb8c5f7e745640cdd9.png)\n对于上述图片，求$|A\\cup B \\cup C|$\n结果为$|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|B\\cap C|-|C\\cap A|+|A\\cap B\\cap C|$\n\n## 一般情况\n\n公式：$\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i<a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right|$\n\n大家应该是看不懂吧，反正我是看不懂\n\n我理解的通俗的意思就是：\n\n`n`个集合的并集**等于**`n`个集合选择一个的情况中所有情况的交-`n`个集合中选择两个所有情况中两两的交+`n`个集合中选择三个中所有情况三个的交-选择四种的交+选择五种的交-......\n\n稍微用公式表示一下：\n$|A_1\\cup...\\cup A_n| = \\\\\n|A_1|+|A_2|+...+|A_n|\\\\\n-(|A_1 \\cap A_2|+...+|A_i \\cap A_j|)\\\\\n+(|A_1 \\cap A_2 \\cap A_3|+...+|A_i \\cap A_j \\cap A_k|)\\\\\n-(四个之间的交)\\\\\n+(五个之间的交)\\\\\n......$\n\n大概就是这个意思。\n\n - 选择的个数为偶数次，前面符号为负\n- 选择的个数为奇数次，前面符号为正\n\n\n参考链接：\n[https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)\n\n## 例题1 能被整除的数\n\n题目链接：[https://www.acwing.com/problem/content/892/](https://www.acwing.com/problem/content/892/)\n\n>给定一个整数 `n`和 `m` 个不同的质数 $p_1,p_2,…,p_m$。\n>请你求出 1∼n 中能被 $p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。\n\n---\n\n**思路：**\n\n>先简单的举个例子：\n>质数有2，3，5，7，11五个\n>能被2整除的有2，4，6，8 ....\n>能被3整除的有3，6，9，12....\n>...\n>问的是被至少一个整除就行，那么上述例子中6是重复的\n>也就是我们可以把能被**一个质数整除的个数**当作**一个集合**，这么多质数组成的集合有重合的，我们要求的是这么多集合的并集，满足容斥定理\n\n在`1-n`中能被`x`整除的个数：$\\lfloor \\frac{n}{x}\\rfloor$\n在`1-n`中能被`x,y`整除的个数：$\\lfloor \\frac{n}{xy}\\rfloor$\n在`1-n`中能被`x,y,z`整除的个数：$\\lfloor \\frac{n}{xyz}\\rfloor$\n......\n然后就可以根据公式求结果，有`m`个质数，共有`m`个集合，每次会选中若干个集合，代表几个之间的交集（参照上面容斥定理公式）\n\n>几个集合之间的交集：就是一个数能**同时**被这选中的几个质数整除\n\n选中集合个数为偶数，前面符号为**负**\n选中集合个数为奇数，前面符号为**正**\n\n>枚举所有的集合：\n>我们采用二进制的方法，枚举$[1,2^{m}-1]$,统计其中`1`的个数即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 20;\nint p[N];\nint n,m;\n\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++) cin>>p[i];\n\t\n\tll res = 0;\n\tfor(int i=1;i< 1<<m ;i++)\n\t{\n\t\tint cnt = 0;\n\t\tll t = 1;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif( i>>j & 1)\n\t\t\t{\n\t\t\t\tcnt ++ ;//统计选中的个数\n\t\t\t\tif(t * p[j] > n)//不满足条件，因为大于n了\n\t\t\t\t{\n\t\t\t\t\tt = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt *= p[j];\n\t\t\t}\n\t\t}\n\t\tif(t!=-1)\n\t\t{\n\t\t\tif(cnt%2) res += n/t;\n\t\t\telse res -= n/t; \n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n```\n\n---\n\n## 例题2 \n\n题目链接:[https://www.acwing.com/problem/content/216/](https://www.acwing.com/problem/content/216/)\n\n>Devu 有 `N` 个盒子，第 `i` 个盒子中有 $A_i$ 枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu 要从这些盒子中选出 `m` 枝花组成一束，求共有多少种方案。若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。结果需对 $10^9+7$ 取模之后方可输出\n\n---\n\n**思路**\n\n\n- 理想情况\n\n首先去掉限制考虑理想情况，即每个盒子的花的个数有无限个，设第$i$个盒子取出$x_i$朵花\n\n则$x_1+x_2+x_3+...+x_n=  m,x_i \\geq 0$,总方案数为$C_{n+m-1}^{n-1}$种\n\n可以参考链接查看如何计算 :\n[https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)\n\n---\n\n- 有限制的情况\n\n限制条件下：\n$x_1+x_2+x_3+...+x_n=  m,x_1<=A_1,x_2<=A_2,x_3<=A_3……x_n<=A_n$\n\n$x_1,x_2,...,x_n$同时满足限制条件才可，我们考虑从补集去求（总情况数减去相反的情况）\n\n补集情况下：\n\n$x_1+x_2+x_3+...+x_n=  m,x_1>A_1,x_2>A_2,x_3>A_3……x_n>A_n$\n第`i`个限制（$x_i>A_i$）的情况满足个数我们当作一个集合$s_i$\n\n- 总数：$C_{n+m-1}^{n-1}$\n- 题目的补集：$|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$\n- 结果为：$C_{m+n-1}^{n-1}-|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$\n\n考虑求满足$s_1$的情况数\n即第一个必须取至少$A_i+1$支花，那么接下来就化为从`n`组里面选花，$x_1>=A_1+1,x_2>=0,x_3>=0,...,x_n>=0$的情况，可以直接取出$A_i+1$支花放在第一组，那么总数就变成$m-(A_1+1)$支花，就化为**理想情况**(见上文)下的问题了，总数为$C_{m+n-1-(A_1+1)}^{n-1}$\n\n$s_1\\cap s_2$同理\n答案为$C_{m+n-1-(A_1+1)-(A_2+1)}^{n-1}$\n\n最后枚举所有的情况数，使用二进制方法进行枚举，枚举$[0,2^n-1]$,统计二进制位`1`的个数\n\n奇数个`1`符号为负\n偶数个`1`符号位正\n\n```cpp\n#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N = 20,mod = 1e9+7;\n\nll a[N];\nll d = 1;\n\nll fast(ll a,ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b&1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll C(ll x,ll y)\n{\n\tif(x < y) return 0;\n\tll u = 1;\n\tfor(ll i = x;i>x-y;i--) u = i % mod * u % mod;\n\treturn u * d % mod;\n}\n\nint main()\n{\n\tll n,m;\n\tcin >> n >> m;\n\tfor ( int i=0;i<n;i++) cin>>a[i];\n\t\n\tfor(ll i=1;i<=n-1;i++) d = d * i % mod;\n\td = fast(d,mod-2);\n\t\n\tll res = 0 ;\n\tfor(int i=0; i< 1<<n;i++)\n\t{\n\t\t//组合数的下角标   上角标\n\t\tll down = n + m -1,up = n-1;\n\t\tint sign = 1;//标记的符号位\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i>>j&1)\n\t\t\t{\n\t\t\t\tdown -= a[j]+1;//下角标减去对应的个数\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t}\n\t\tres = (res + C(down,up) * sign)%mod; //计算组合数，统计答案\n\t}\n\tcout<<(res + mod) % mod<<endl; \n\treturn 0;\n}\n\n```\n","slug":"容斥定理","published":1,"updated":"2022-08-04T07:14:07.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhw001z6kuhvwd9yn6l","content":"<p>﻿﻿# 容斥定理</p>\n<h2 id=\"简单版本：\"><a href=\"#简单版本：\" class=\"headerlink\" title=\"简单版本：\"></a>简单版本：</h2><p><img src=\"1292892888/a188f738744e4afb8c5f7e745640cdd9.png\" alt=\"简单版本\"><br>对于上述图片，求$|A\\cup B \\cup C|$<br>结果为$|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|B\\cap C|-|C\\cap A|+|A\\cap B\\cap C|$</p>\n<h2 id=\"一般情况\"><a href=\"#一般情况\" class=\"headerlink\" title=\"一般情况\"></a>一般情况</h2><p>公式：$\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right|$</p>\n<p>大家应该是看不懂吧，反正我是看不懂</p>\n<p>我理解的通俗的意思就是：</p>\n<p><code>n</code>个集合的并集<strong>等于</strong><code>n</code>个集合选择一个的情况中所有情况的交-<code>n</code>个集合中选择两个所有情况中两两的交+<code>n</code>个集合中选择三个中所有情况三个的交-选择四种的交+选择五种的交-……</p>\n<p>稍微用公式表示一下：<br>$|A_1\\cup…\\cup A_n| = \\<br>|A_1|+|A_2|+…+|A_n|\\<br>-(|A_1 \\cap A_2|+…+|A_i \\cap A_j|)\\<br>+(|A_1 \\cap A_2 \\cap A_3|+…+|A_i \\cap A_j \\cap A_k|)\\<br>-(四个之间的交)\\<br>+(五个之间的交)\\<br>……$</p>\n<p>大概就是这个意思。</p>\n<ul>\n<li>选择的个数为偶数次，前面符号为负<ul>\n<li>选择的个数为奇数次，前面符号为正</li>\n</ul>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/\" target=\"_blank\" rel=\"noopener\">https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/</a></p>\n<h2 id=\"例题1-能被整除的数\"><a href=\"#例题1-能被整除的数\" class=\"headerlink\" title=\"例题1 能被整除的数\"></a>例题1 能被整除的数</h2><p>题目链接：<a href=\"https://www.acwing.com/problem/content/892/\" target=\"_blank\" rel=\"noopener\">https://www.acwing.com/problem/content/892/</a></p>\n<blockquote>\n<p>给定一个整数 <code>n</code>和 <code>m</code> 个不同的质数 $p_1,p_2,…,p_m$。<br>请你求出 1∼n 中能被 $p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。</p>\n</blockquote>\n<hr>\n<p><strong>思路：</strong></p>\n<blockquote>\n<p>先简单的举个例子：<br>质数有2，3，5，7，11五个<br>能被2整除的有2，4，6，8 ….<br>能被3整除的有3，6，9，12….<br>…<br>问的是被至少一个整除就行，那么上述例子中6是重复的<br>也就是我们可以把能被<strong>一个质数整除的个数</strong>当作<strong>一个集合</strong>，这么多质数组成的集合有重合的，我们要求的是这么多集合的并集，满足容斥定理</p>\n</blockquote>\n<p>在<code>1-n</code>中能被<code>x</code>整除的个数：$\\lfloor \\frac{n}{x}\\rfloor$<br>在<code>1-n</code>中能被<code>x,y</code>整除的个数：$\\lfloor \\frac{n}{xy}\\rfloor$<br>在<code>1-n</code>中能被<code>x,y,z</code>整除的个数：$\\lfloor \\frac{n}{xyz}\\rfloor$<br>……<br>然后就可以根据公式求结果，有<code>m</code>个质数，共有<code>m</code>个集合，每次会选中若干个集合，代表几个之间的交集（参照上面容斥定理公式）</p>\n<blockquote>\n<p>几个集合之间的交集：就是一个数能<strong>同时</strong>被这选中的几个质数整除</p>\n</blockquote>\n<p>选中集合个数为偶数，前面符号为<strong>负</strong><br>选中集合个数为奇数，前面符号为<strong>正</strong></p>\n<blockquote>\n<p>枚举所有的集合：<br>我们采用二进制的方法，枚举$[1,2^{m}-1]$,统计其中<code>1</code>的个数即可</p>\n</blockquote>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> ll<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> p<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    cin<span class=\"token operator\">>></span>n<span class=\"token operator\">>></span>m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>m<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> cin<span class=\"token operator\">>></span>p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    ll res <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span>m <span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> cnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        ll t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>m<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> i<span class=\"token operator\">>></span>j <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                cnt <span class=\"token operator\">++</span> <span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//统计选中的个数</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span> p<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> n<span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//不满足条件，因为大于n了</span>\n                <span class=\"token punctuation\">{</span>\n                    t <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                t <span class=\"token operator\">*</span><span class=\"token operator\">=</span> p<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">!=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cnt<span class=\"token operator\">%</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> res <span class=\"token operator\">+</span><span class=\"token operator\">=</span> n<span class=\"token operator\">/</span>t<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> res <span class=\"token operator\">-</span><span class=\"token operator\">=</span> n<span class=\"token operator\">/</span>t<span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> res <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p>题目链接:<a href=\"https://www.acwing.com/problem/content/216/\" target=\"_blank\" rel=\"noopener\">https://www.acwing.com/problem/content/216/</a></p>\n<blockquote>\n<p>Devu 有 <code>N</code> 个盒子，第 <code>i</code> 个盒子中有 $A_i$ 枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu 要从这些盒子中选出 <code>m</code> 枝花组成一束，求共有多少种方案。若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。结果需对 $10^9+7$ 取模之后方可输出</p>\n</blockquote>\n<hr>\n<p><strong>思路</strong></p>\n<ul>\n<li>理想情况</li>\n</ul>\n<p>首先去掉限制考虑理想情况，即每个盒子的花的个数有无限个，设第$i$个盒子取出$x_i$朵花</p>\n<p>则$x_1+x_2+x_3+…+x_n=  m,x_i \\geq 0$,总方案数为$C_{n+m-1}^{n-1}$种</p>\n<p>可以参考链接查看如何计算 :<br><a href=\"https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/\" target=\"_blank\" rel=\"noopener\">https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/</a></p>\n<hr>\n<ul>\n<li>有限制的情况</li>\n</ul>\n<p>限制条件下：<br>$x_1+x_2+x_3+…+x_n=  m,x_1&lt;=A_1,x_2&lt;=A_2,x_3&lt;=A_3……x_n&lt;=A_n$</p>\n<p>$x_1,x_2,…,x_n$同时满足限制条件才可，我们考虑从补集去求（总情况数减去相反的情况）</p>\n<p>补集情况下：</p>\n<p>$x_1+x_2+x_3+…+x_n=  m,x_1&gt;A_1,x_2&gt;A_2,x_3&gt;A_3……x_n&gt;A_n$<br>第<code>i</code>个限制（$x_i&gt;A_i$）的情况满足个数我们当作一个集合$s_i$</p>\n<ul>\n<li>总数：$C_{n+m-1}^{n-1}$</li>\n<li>题目的补集：$|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$</li>\n<li>结果为：$C_{m+n-1}^{n-1}-|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$</li>\n</ul>\n<p>考虑求满足$s_1$的情况数<br>即第一个必须取至少$A_i+1$支花，那么接下来就化为从<code>n</code>组里面选花，$x_1&gt;=A_1+1,x_2&gt;=0,x_3&gt;=0,…,x_n&gt;=0$的情况，可以直接取出$A_i+1$支花放在第一组，那么总数就变成$m-(A_1+1)$支花，就化为<strong>理想情况</strong>(见上文)下的问题了，总数为$C_{m+n-1-(A_1+1)}^{n-1}$</p>\n<p>$s_1\\cap s_2$同理<br>答案为$C_{m+n-1-(A_1+1)-(A_2+1)}^{n-1}$</p>\n<p>最后枚举所有的情况数，使用二进制方法进行枚举，枚举$[0,2^n-1]$,统计二进制位<code>1</code>的个数</p>\n<p>奇数个<code>1</code>符号为负<br>偶数个<code>1</code>符号位正</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> ll<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>mod <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span><span class=\"token operator\">+</span><span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\nll a<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nll d <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\nll <span class=\"token function\">fast</span><span class=\"token punctuation\">(</span>ll a<span class=\"token punctuation\">,</span>ll b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>b<span class=\"token operator\">&amp;</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> res <span class=\"token operator\">=</span> res <span class=\"token operator\">*</span> a <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> a <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nll <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>ll x<span class=\"token punctuation\">,</span>ll y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    ll u <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>ll i <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>i<span class=\"token operator\">></span>x<span class=\"token operator\">-</span>y<span class=\"token punctuation\">;</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> u <span class=\"token operator\">=</span> i <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> u <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> u <span class=\"token operator\">*</span> d <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ll n<span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> m<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> cin<span class=\"token operator\">>></span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>ll i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> d <span class=\"token operator\">=</span> d <span class=\"token operator\">*</span> i <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    d <span class=\"token operator\">=</span> <span class=\"token function\">fast</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">,</span>mod<span class=\"token number\">-2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ll res <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//组合数的下角标   上角标</span>\n        ll down <span class=\"token operator\">=</span> n <span class=\"token operator\">+</span> m <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>up <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> sign <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//标记的符号位</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">>></span>j<span class=\"token operator\">&amp;</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                down <span class=\"token operator\">-</span><span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//下角标减去对应的个数</span>\n                sign <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        res <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">+</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>down<span class=\"token punctuation\">,</span>up<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> sign<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>mod<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//计算组合数，统计答案</span>\n    <span class=\"token punctuation\">}</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">+</span> mod<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<p>﻿﻿# 容斥定理</p>\n<h2 id=\"简单版本：\"><a href=\"#简单版本：\" class=\"headerlink\" title=\"简单版本：\"></a>简单版本：</h2><p><img src=\"1292892888/a188f738744e4afb8c5f7e745640cdd9.png\" alt=\"简单版本\"><br>对于上述图片，求$|A\\cup B \\cup C|$<br>结果为$|A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|B\\cap C|-|C\\cap A|+|A\\cap B\\cap C|$</p>\n<h2 id=\"一般情况\"><a href=\"#一般情况\" class=\"headerlink\" title=\"一般情况\"></a>一般情况</h2><p>公式：$\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_i&lt;a_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right|$</p>\n<p>大家应该是看不懂吧，反正我是看不懂</p>\n<p>我理解的通俗的意思就是：</p>\n<p><code>n</code>个集合的并集<strong>等于</strong><code>n</code>个集合选择一个的情况中所有情况的交-<code>n</code>个集合中选择两个所有情况中两两的交+<code>n</code>个集合中选择三个中所有情况三个的交-选择四种的交+选择五种的交-……</p>\n<p>稍微用公式表示一下：<br>$|A_1\\cup…\\cup A_n| = \\<br>|A_1|+|A_2|+…+|A_n|\\<br>-(|A_1 \\cap A_2|+…+|A_i \\cap A_j|)\\<br>+(|A_1 \\cap A_2 \\cap A_3|+…+|A_i \\cap A_j \\cap A_k|)\\<br>-(四个之间的交)\\<br>+(五个之间的交)\\<br>……$</p>\n<p>大概就是这个意思。</p>\n<ul>\n<li>选择的个数为偶数次，前面符号为负<ul>\n<li>选择的个数为奇数次，前面符号为正</li>\n</ul>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/\" target=\"_blank\" rel=\"noopener\">https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/</a></p>\n<h2 id=\"例题1-能被整除的数\"><a href=\"#例题1-能被整除的数\" class=\"headerlink\" title=\"例题1 能被整除的数\"></a>例题1 能被整除的数</h2><p>题目链接：<a href=\"https://www.acwing.com/problem/content/892/\" target=\"_blank\" rel=\"noopener\">https://www.acwing.com/problem/content/892/</a></p>\n<blockquote>\n<p>给定一个整数 <code>n</code>和 <code>m</code> 个不同的质数 $p_1,p_2,…,p_m$。<br>请你求出 1∼n 中能被 $p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。</p>\n</blockquote>\n<hr>\n<p><strong>思路：</strong></p>\n<blockquote>\n<p>先简单的举个例子：<br>质数有2，3，5，7，11五个<br>能被2整除的有2，4，6，8 ….<br>能被3整除的有3，6，9，12….<br>…<br>问的是被至少一个整除就行，那么上述例子中6是重复的<br>也就是我们可以把能被<strong>一个质数整除的个数</strong>当作<strong>一个集合</strong>，这么多质数组成的集合有重合的，我们要求的是这么多集合的并集，满足容斥定理</p>\n</blockquote>\n<p>在<code>1-n</code>中能被<code>x</code>整除的个数：$\\lfloor \\frac{n}{x}\\rfloor$<br>在<code>1-n</code>中能被<code>x,y</code>整除的个数：$\\lfloor \\frac{n}{xy}\\rfloor$<br>在<code>1-n</code>中能被<code>x,y,z</code>整除的个数：$\\lfloor \\frac{n}{xyz}\\rfloor$<br>……<br>然后就可以根据公式求结果，有<code>m</code>个质数，共有<code>m</code>个集合，每次会选中若干个集合，代表几个之间的交集（参照上面容斥定理公式）</p>\n<blockquote>\n<p>几个集合之间的交集：就是一个数能<strong>同时</strong>被这选中的几个质数整除</p>\n</blockquote>\n<p>选中集合个数为偶数，前面符号为<strong>负</strong><br>选中集合个数为奇数，前面符号为<strong>正</strong></p>\n<blockquote>\n<p>枚举所有的集合：<br>我们采用二进制的方法，枚举$[1,2^{m}-1]$,统计其中<code>1</code>的个数即可</p>\n</blockquote>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N = 20;\nint p[N];\nint n,m;\n\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=0;i&lt;m;i++) cin&gt;&gt;p[i];\n\n    ll res = 0;\n    for(int i=1;i&lt; 1&lt;&lt;m ;i++)\n    {\n        int cnt = 0;\n        ll t = 1;\n        for(int j=0;j&lt;m;j++)\n        {\n            if( i&gt;&gt;j &amp; 1)\n            {\n                cnt ++ ;//统计选中的个数\n                if(t * p[j] &gt; n)//不满足条件，因为大于n了\n                {\n                    t = -1;\n                    break;\n                }\n                t *= p[j];\n            }\n        }\n        if(t!=-1)\n        {\n            if(cnt%2) res += n/t;\n            else res -= n/t; \n        }\n    }\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}</code></pre>\n<hr>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p>题目链接:<a href=\"https://www.acwing.com/problem/content/216/\" target=\"_blank\" rel=\"noopener\">https://www.acwing.com/problem/content/216/</a></p>\n<blockquote>\n<p>Devu 有 <code>N</code> 个盒子，第 <code>i</code> 个盒子中有 $A_i$ 枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu 要从这些盒子中选出 <code>m</code> 枝花组成一束，求共有多少种方案。若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。结果需对 $10^9+7$ 取模之后方可输出</p>\n</blockquote>\n<hr>\n<p><strong>思路</strong></p>\n<ul>\n<li>理想情况</li>\n</ul>\n<p>首先去掉限制考虑理想情况，即每个盒子的花的个数有无限个，设第$i$个盒子取出$x_i$朵花</p>\n<p>则$x_1+x_2+x_3+…+x_n=  m,x_i \\geq 0$,总方案数为$C_{n+m-1}^{n-1}$种</p>\n<p>可以参考链接查看如何计算 :<br><a href=\"https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/\" target=\"_blank\" rel=\"noopener\">https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/</a></p>\n<hr>\n<ul>\n<li>有限制的情况</li>\n</ul>\n<p>限制条件下：<br>$x_1+x_2+x_3+…+x_n=  m,x_1&lt;=A_1,x_2&lt;=A_2,x_3&lt;=A_3……x_n&lt;=A_n$</p>\n<p>$x_1,x_2,…,x_n$同时满足限制条件才可，我们考虑从补集去求（总情况数减去相反的情况）</p>\n<p>补集情况下：</p>\n<p>$x_1+x_2+x_3+…+x_n=  m,x_1&gt;A_1,x_2&gt;A_2,x_3&gt;A_3……x_n&gt;A_n$<br>第<code>i</code>个限制（$x_i&gt;A_i$）的情况满足个数我们当作一个集合$s_i$</p>\n<ul>\n<li>总数：$C_{n+m-1}^{n-1}$</li>\n<li>题目的补集：$|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$</li>\n<li>结果为：$C_{m+n-1}^{n-1}-|s_1\\bigcup s_2\\bigcup s_3……\\bigcup s_n|$</li>\n</ul>\n<p>考虑求满足$s_1$的情况数<br>即第一个必须取至少$A_i+1$支花，那么接下来就化为从<code>n</code>组里面选花，$x_1&gt;=A_1+1,x_2&gt;=0,x_3&gt;=0,…,x_n&gt;=0$的情况，可以直接取出$A_i+1$支花放在第一组，那么总数就变成$m-(A_1+1)$支花，就化为<strong>理想情况</strong>(见上文)下的问题了，总数为$C_{m+n-1-(A_1+1)}^{n-1}$</p>\n<p>$s_1\\cap s_2$同理<br>答案为$C_{m+n-1-(A_1+1)-(A_2+1)}^{n-1}$</p>\n<p>最后枚举所有的情况数，使用二进制方法进行枚举，枚举$[0,2^n-1]$,统计二进制位<code>1</code>的个数</p>\n<p>奇数个<code>1</code>符号为负<br>偶数个<code>1</code>符号位正</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nconst int N = 20,mod = 1e9+7;\n\nll a[N];\nll d = 1;\n\nll fast(ll a,ll b)\n{\n    ll res = 1;\n    while(b)\n    {\n        if(b&amp;1) res = res * a % mod;\n        a = a * a % mod;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n\nll C(ll x,ll y)\n{\n    if(x &lt; y) return 0;\n    ll u = 1;\n    for(ll i = x;i&gt;x-y;i--) u = i % mod * u % mod;\n    return u * d % mod;\n}\n\nint main()\n{\n    ll n,m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for ( int i=0;i&lt;n;i++) cin&gt;&gt;a[i];\n\n    for(ll i=1;i&lt;=n-1;i++) d = d * i % mod;\n    d = fast(d,mod-2);\n\n    ll res = 0 ;\n    for(int i=0; i&lt; 1&lt;&lt;n;i++)\n    {\n        //组合数的下角标   上角标\n        ll down = n + m -1,up = n-1;\n        int sign = 1;//标记的符号位\n        for(int j=0;j&lt;n;j++)\n        {\n            if(i&gt;&gt;j&amp;1)\n            {\n                down -= a[j]+1;//下角标减去对应的个数\n                sign *= -1;\n            }\n        }\n        res = (res + C(down,up) * sign)%mod; //计算组合数，统计答案\n    }\n    cout&lt;&lt;(res + mod) % mod&lt;&lt;endl; \n    return 0;\n}\n</code></pre>\n"},{"title":"阶乘逆元和线性逆元","top":false,"cover":false,"toc":true,"mathjax":true,"abbrlink":652576208,"date":"2022-06-25T11:27:26.000Z","password":null,"summary":null,"_content":"\n# 逆元简介\n\n$a \\times b \\equiv  1 ( mod\\,\\,p)$,可以称`a`是`b`在模`p`情况下的逆元.\n逆元其实就是可以看作倒数\n\n# 阶乘逆元\n\n**方式一:**\n通过费马小定理求逆元：\n当`p`为素数，并且`gcd(a,p)=1`时，我们有$a^{p−1}≡1(mod\\ p)$。那么就有$a^{p−2}×a≡1(mod\\ p)$，则`a`的逆元就是$a^{p−2}$\n下面`ksm`函数为快速幂\n\n```cpp\nfact[0] = 1;\nfor(int i = 1; i < N; i++)\n{\n\tfact[i] = fact[i - 1] * i % mod;\n\tinv[i] = ksm(fact[i], mod - 2);\n}\n```\n\n---\n\n**方式二：**\n\n通过式子$\\frac{1}{(n+1)!}\\times (n+1)=\\frac{1}{n!}$倒推接近线性求阶乘逆元\n\n$\\frac{1}{(n+1)!}$其实就可以看作${(n+1)!}$的逆元\n\n```cpp\nfor(int i = 1; i <= n; i++)\n\tfact[i] = fact[i - 1] * i % mod;\ninv[n] = ksm(fact[n], mod - 2);\nfor(int i = n - 1; i >= 1; i--)\n\tinv[i] = inv[i + 1] * (i + 1) % mod;\n```\n\n---\n\n\n\n# 线性求逆元\n\n求$[1,N-1]$关于`mod`的逆元时，可以做到在$O(N)$时间内解决\n\n设模数为`p`\n对于当前的`i`，设$p=k×i+r$,则\n\n$\\begin{aligned}\nk \\times i + r & \\equiv   0  &\\,\\,(mod \\,\\, p) \\\\\\\nk \\times i \\times ( i^{-1} \\times r ^{-1}) + r \\times (i^{-1} \\times r^{-1}) &\\equiv 0 &\\,\\,( mod \\,\\, p) \\\\\\\nk \\times r^{-1} + i ^ {-1} & \\equiv 0 &\\,\\, (mod \\,\\, p)\\\\\\\ni^{-1} & \\equiv -k \\times r^{-1} &\\,\\, (mod \\,\\, p) \\\\\\\ni^{-1} & \\equiv - \\left \\lfloor \\frac{p}{i}\\right \\rfloor \\times r^{-1} &\\,\\,(mod\\,\\,p)\n\\end{aligned}$\n注意：\n$inv[1]$一定要初始化为1，需要从2开始递推，不能从1开始递推\n\n```cpp\ninv[0] = inv[1] = 1;\nfor(int i = 2; i < N; i++)\n\tinv[i] = inv[mod % i] * (mod - mod / i) % mod;\n```\n\n同时可以通过线性求逆元求**阶乘逆元**：\n只需要再将逆元用类似阶乘的形式乘起来即可，求得的`inv[i]`即为$i!$的逆元\n\n```cpp\nfor(int i = 2; i < N; i++)\n\tinv[i] = inv[i - 1] * inv[i] % mod;\n```\n\n---\n\n# 组合数计算\n\n$C_n^m$计算\n\n- 方式一：公式计算\n  计算都是在逆元或者阶乘基础上计算的\n  $C_n^m = \\frac{n!}{m!*(n-m)!}$\n\n```cpp\nll C(ll n, ll m)\n{\n\tif(n < m) return 0;\n\treturn fact[n] * inv[m] % mod * inv[n - m] % mod;\n}\n```\n\n- 方式二：递推方式\n  需要建表,所以如果计算范围比较大时需要的空间也大\n  递推公式 ： $C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}$\n\n```cpp\nfor(int i = 1; i <= n; i++)\n\tfor(int j = 0; j <= i; j++)\n\t{\n\t\tif(i == j || j == 0) c[i][j] = 1;\n\t\telse c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n\t}\n```\n\n---\n\n# 题目\n\n链接：\n[https://ac.nowcoder.com/acm/contest/23481/J](https://ac.nowcoder.com/acm/contest/23481/J)\n![在这里插入图片描述](652576208/67dacbcfb1d0428e874f2faff1a0a75a.png)\n\n>就是在数组中选中k个值相乘，最后把结果相加即可\n\n---\n\n因为数组中的数大小只有三种情况。所以可以根据这个进行切入口。\n\n\n\n首先$0$可以不用考虑，接下考虑有$n$个$1$和$m$个$2$，如果上述和式中$1$出现了$i$个，那么$2$需要出现$k-i$个，于是答案为\n\n$\\sum \\limits_{i=0}^k C_n^i C_m^{k-i}2^{k-i}$\n\n---\n\n代码中注意各种初始化\n线性求逆元中初始化：`inv[1] = 1`\n`fac[i]`:$2^i$\n`fact[i]`:$i!$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst int N = 1e7 + 5, mod = 998244353;\n\nll fac[N], fact[N], inv[N];\n\nll C(ll n, ll m)\n{\n\tif(n < m) return 0;\n\treturn fact[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nvoid solve()\n{\n\tfac[1] = 2;\n\tfac[0] = fact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor(int i = 2; i < N; i++)\n\t{\n\t\tfac[i] = fac[i - 1] * 2 % mod;\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinv[i] = inv[mod % i] * (mod - mod / i) % mod; \n\t}\n\tfor(int i = 2; i < N; i++)\n\t\tinv[i] = inv[i - 1] * inv[i] % mod;\n\t\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tint o = 0, t = 0;\n\t\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tcin >> a[i];\n\t\tif(a[i] == 1) o ++;\n\t\telse if(a[i] == 2) t ++;\n\t}\t\n\tll res = 0;\n\tfor(int i = 0; i <= k; i++)\n\t{\n\t\tres += C(o, i) * C(t, k - i) % mod * fac[k - i] % mod;\n\t\tres %= mod;\n\t}\n\tcout << res << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint t;\n//\tcin >> t;\n\tt = 1;\n\twhile(t--) solve();\n\treturn 0;\n}\n\n```\n","source":"_posts/阶乘逆元和线性逆元.md","raw":"---\ntitle: 阶乘逆元和线性逆元\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - 逆元\n  - 组合数学\ncategories:\n  - 数论\nabbrlink: 652576208\ndate: 2022-06-25 19:27:26\npassword:\nsummary:\n---\n\n# 逆元简介\n\n$a \\times b \\equiv  1 ( mod\\,\\,p)$,可以称`a`是`b`在模`p`情况下的逆元.\n逆元其实就是可以看作倒数\n\n# 阶乘逆元\n\n**方式一:**\n通过费马小定理求逆元：\n当`p`为素数，并且`gcd(a,p)=1`时，我们有$a^{p−1}≡1(mod\\ p)$。那么就有$a^{p−2}×a≡1(mod\\ p)$，则`a`的逆元就是$a^{p−2}$\n下面`ksm`函数为快速幂\n\n```cpp\nfact[0] = 1;\nfor(int i = 1; i < N; i++)\n{\n\tfact[i] = fact[i - 1] * i % mod;\n\tinv[i] = ksm(fact[i], mod - 2);\n}\n```\n\n---\n\n**方式二：**\n\n通过式子$\\frac{1}{(n+1)!}\\times (n+1)=\\frac{1}{n!}$倒推接近线性求阶乘逆元\n\n$\\frac{1}{(n+1)!}$其实就可以看作${(n+1)!}$的逆元\n\n```cpp\nfor(int i = 1; i <= n; i++)\n\tfact[i] = fact[i - 1] * i % mod;\ninv[n] = ksm(fact[n], mod - 2);\nfor(int i = n - 1; i >= 1; i--)\n\tinv[i] = inv[i + 1] * (i + 1) % mod;\n```\n\n---\n\n\n\n# 线性求逆元\n\n求$[1,N-1]$关于`mod`的逆元时，可以做到在$O(N)$时间内解决\n\n设模数为`p`\n对于当前的`i`，设$p=k×i+r$,则\n\n$\\begin{aligned}\nk \\times i + r & \\equiv   0  &\\,\\,(mod \\,\\, p) \\\\\\\nk \\times i \\times ( i^{-1} \\times r ^{-1}) + r \\times (i^{-1} \\times r^{-1}) &\\equiv 0 &\\,\\,( mod \\,\\, p) \\\\\\\nk \\times r^{-1} + i ^ {-1} & \\equiv 0 &\\,\\, (mod \\,\\, p)\\\\\\\ni^{-1} & \\equiv -k \\times r^{-1} &\\,\\, (mod \\,\\, p) \\\\\\\ni^{-1} & \\equiv - \\left \\lfloor \\frac{p}{i}\\right \\rfloor \\times r^{-1} &\\,\\,(mod\\,\\,p)\n\\end{aligned}$\n注意：\n$inv[1]$一定要初始化为1，需要从2开始递推，不能从1开始递推\n\n```cpp\ninv[0] = inv[1] = 1;\nfor(int i = 2; i < N; i++)\n\tinv[i] = inv[mod % i] * (mod - mod / i) % mod;\n```\n\n同时可以通过线性求逆元求**阶乘逆元**：\n只需要再将逆元用类似阶乘的形式乘起来即可，求得的`inv[i]`即为$i!$的逆元\n\n```cpp\nfor(int i = 2; i < N; i++)\n\tinv[i] = inv[i - 1] * inv[i] % mod;\n```\n\n---\n\n# 组合数计算\n\n$C_n^m$计算\n\n- 方式一：公式计算\n  计算都是在逆元或者阶乘基础上计算的\n  $C_n^m = \\frac{n!}{m!*(n-m)!}$\n\n```cpp\nll C(ll n, ll m)\n{\n\tif(n < m) return 0;\n\treturn fact[n] * inv[m] % mod * inv[n - m] % mod;\n}\n```\n\n- 方式二：递推方式\n  需要建表,所以如果计算范围比较大时需要的空间也大\n  递推公式 ： $C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}$\n\n```cpp\nfor(int i = 1; i <= n; i++)\n\tfor(int j = 0; j <= i; j++)\n\t{\n\t\tif(i == j || j == 0) c[i][j] = 1;\n\t\telse c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n\t}\n```\n\n---\n\n# 题目\n\n链接：\n[https://ac.nowcoder.com/acm/contest/23481/J](https://ac.nowcoder.com/acm/contest/23481/J)\n![在这里插入图片描述](652576208/67dacbcfb1d0428e874f2faff1a0a75a.png)\n\n>就是在数组中选中k个值相乘，最后把结果相加即可\n\n---\n\n因为数组中的数大小只有三种情况。所以可以根据这个进行切入口。\n\n\n\n首先$0$可以不用考虑，接下考虑有$n$个$1$和$m$个$2$，如果上述和式中$1$出现了$i$个，那么$2$需要出现$k-i$个，于是答案为\n\n$\\sum \\limits_{i=0}^k C_n^i C_m^{k-i}2^{k-i}$\n\n---\n\n代码中注意各种初始化\n线性求逆元中初始化：`inv[1] = 1`\n`fac[i]`:$2^i$\n`fact[i]`:$i!$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst int N = 1e7 + 5, mod = 998244353;\n\nll fac[N], fact[N], inv[N];\n\nll C(ll n, ll m)\n{\n\tif(n < m) return 0;\n\treturn fact[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nvoid solve()\n{\n\tfac[1] = 2;\n\tfac[0] = fact[0] = fact[1] = inv[0] = inv[1] = 1;\n\tfor(int i = 2; i < N; i++)\n\t{\n\t\tfac[i] = fac[i - 1] * 2 % mod;\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinv[i] = inv[mod % i] * (mod - mod / i) % mod; \n\t}\n\tfor(int i = 2; i < N; i++)\n\t\tinv[i] = inv[i - 1] * inv[i] % mod;\n\t\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tint o = 0, t = 0;\n\t\n\tfor(int i = 0; i < n; i++) \n\t{\n\t\tcin >> a[i];\n\t\tif(a[i] == 1) o ++;\n\t\telse if(a[i] == 2) t ++;\n\t}\t\n\tll res = 0;\n\tfor(int i = 0; i <= k; i++)\n\t{\n\t\tres += C(o, i) * C(t, k - i) % mod * fac[k - i] % mod;\n\t\tres %= mod;\n\t}\n\tcout << res << \"\\n\";\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint t;\n//\tcin >> t;\n\tt = 1;\n\twhile(t--) solve();\n\treturn 0;\n}\n\n```\n","slug":"阶乘逆元和线性逆元","published":1,"updated":"2023-02-03T15:44:58.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldwkolhx00226kuhcxe58y2j","content":"<h1 id=\"逆元简介\"><a href=\"#逆元简介\" class=\"headerlink\" title=\"逆元简介\"></a>逆元简介</h1><p>$a \\times b \\equiv  1 ( mod\\,\\,p)$,可以称<code>a</code>是<code>b</code>在模<code>p</code>情况下的逆元.<br>逆元其实就是可以看作倒数</p>\n<h1 id=\"阶乘逆元\"><a href=\"#阶乘逆元\" class=\"headerlink\" title=\"阶乘逆元\"></a>阶乘逆元</h1><p><strong>方式一:</strong><br>通过费马小定理求逆元：<br>当<code>p</code>为素数，并且<code>gcd(a,p)=1</code>时，我们有$a^{p−1}≡1(mod\\ p)$。那么就有$a^{p−2}×a≡1(mod\\ p)$，则<code>a</code>的逆元就是$a^{p−2}$<br>下面<code>ksm</code>函数为快速幂</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">fact<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    fact<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fact<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n    inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">ksm</span><span class=\"token punctuation\">(</span>fact<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<p><strong>方式二：</strong></p>\n<p>通过式子$\\frac{1}{(n+1)!}\\times (n+1)=\\frac{1}{n!}$倒推接近线性求阶乘逆元</p>\n<p>$\\frac{1}{(n+1)!}$其实就可以看作${(n+1)!}$的逆元</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    fact<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fact<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\ninv<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">ksm</span><span class=\"token punctuation\">(</span>fact<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h1 id=\"线性求逆元\"><a href=\"#线性求逆元\" class=\"headerlink\" title=\"线性求逆元\"></a>线性求逆元</h1><p>求$[1,N-1]$关于<code>mod</code>的逆元时，可以做到在$O(N)$时间内解决</p>\n<p>设模数为<code>p</code><br>对于当前的<code>i</code>，设$p=k×i+r$,则</p>\n<p>$\\begin{aligned}<br>k \\times i + r &amp; \\equiv   0  &amp;\\,\\,(mod \\,\\, p) \\\\<br>k \\times i \\times ( i^{-1} \\times r ^{-1}) + r \\times (i^{-1} \\times r^{-1}) &amp;\\equiv 0 &amp;\\,\\,( mod \\,\\, p) \\\\<br>k \\times r^{-1} + i ^ {-1} &amp; \\equiv 0 &amp;\\,\\, (mod \\,\\, p)\\\\<br>i^{-1} &amp; \\equiv -k \\times r^{-1} &amp;\\,\\, (mod \\,\\, p) \\\\<br>i^{-1} &amp; \\equiv - \\left \\lfloor \\frac{p}{i}\\right \\rfloor \\times r^{-1} &amp;\\,\\,(mod\\,\\,p)<br>\\end{aligned}$<br>注意：<br>$inv[1]$一定要初始化为1，需要从2开始递推，不能从1开始递推</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">inv<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span>mod <span class=\"token operator\">%</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>mod <span class=\"token operator\">-</span> mod <span class=\"token operator\">/</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>同时可以通过线性求逆元求<strong>阶乘逆元</strong>：<br>只需要再将逆元用类似阶乘的形式乘起来即可，求得的<code>inv[i]</code>即为$i!$的逆元</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<h1 id=\"组合数计算\"><a href=\"#组合数计算\" class=\"headerlink\" title=\"组合数计算\"></a>组合数计算</h1><p>$C_n^m$计算</p>\n<ul>\n<li>方式一：公式计算<br>计算都是在逆元或者阶乘基础上计算的<br>$C_n^m = \\frac{n!}{m!*(n-m)!}$</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">ll <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>ll n<span class=\"token punctuation\">,</span> ll m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> fact<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> m<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>方式二：递推方式<br>需要建表,所以如果计算范围比较大时需要的空间也大<br>递推公式 ： $C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}$</li>\n</ul>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> j <span class=\"token operator\">||</span> j <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>链接：<br><a href=\"https://ac.nowcoder.com/acm/contest/23481/J\" target=\"_blank\" rel=\"noopener\">https://ac.nowcoder.com/acm/contest/23481/J</a><br><img src=\"652576208/67dacbcfb1d0428e874f2faff1a0a75a.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>就是在数组中选中k个值相乘，最后把结果相加即可</p>\n</blockquote>\n<hr>\n<p>因为数组中的数大小只有三种情况。所以可以根据这个进行切入口。</p>\n<p>首先$0$可以不用考虑，接下考虑有$n$个$1$和$m$个$2$，如果上述和式中$1$出现了$i$个，那么$2$需要出现$k-i$个，于是答案为</p>\n<p>$\\sum \\limits_{i=0}^k C_n^i C_m^{k-i}2^{k-i}$</p>\n<hr>\n<p>代码中注意各种初始化<br>线性求逆元中初始化：<code>inv[1] = 1</code><br><code>fac[i]</code>:$2^i$<br><code>fact[i]</code>:$i!$</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;bits/stdc++.h></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">using</span> ll <span class=\"token operator\">=</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> N <span class=\"token operator\">=</span> <span class=\"token number\">1e7</span> <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> mod <span class=\"token operator\">=</span> <span class=\"token number\">998244353</span><span class=\"token punctuation\">;</span>\n\nll fac<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> fact<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> inv<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nll <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>ll n<span class=\"token punctuation\">,</span> ll m<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> fact<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> m<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    fac<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    fac<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fact<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fact<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        fac<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fac<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        fact<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fact<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span>mod <span class=\"token operator\">%</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>mod <span class=\"token operator\">-</span> mod <span class=\"token operator\">/</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> N<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> inv<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> inv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">;</span>\n    cin <span class=\"token operator\">>></span> n <span class=\"token operator\">>></span> k<span class=\"token punctuation\">;</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> o <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> t <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">{</span>\n        cin <span class=\"token operator\">>></span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> o <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> t <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>    \n    ll res <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        res <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> k <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> mod <span class=\"token operator\">*</span> fac<span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span> <span class=\"token operator\">%</span> mod<span class=\"token punctuation\">;</span>\n        res <span class=\"token operator\">%</span><span class=\"token operator\">=</span> mod<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> res <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    ios<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cin<span class=\"token punctuation\">.</span><span class=\"token function\">tie</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//    cin >> t;</span>\n    t <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"行码棋","url":"https://wyqz.top","title":"访问主页","introduction":"蒟蒻一个","avatar":"/medias/avatars/me.png"},{"name":"WAWA鱼","url":"https://blog.csdn.net/qq_51282224","title":"访问主页","introduction":"算法大佬","avatar":"/medias/avatars/wawayu.jpg"},{"name":"猿知","url":"https://blog.csdn.net/Magic_Zsir","title":"访问主页","introduction":"物联网开发玩家","avatar":"/medias/avatars/yuanzhi.jpg"},{"name":"小极客","url":"http://blog.tkcraft.cn/","title":"访问主页","introduction":"爱玩的小极客，有许多有意思的想法。","avatar":"/medias/avatars/xiaojike.jpg"},{"name":"幼稚园园长","url":"https://yzyyz.top","title":"访问主页","introduction":"学无止境 知行合一","avatar":"https://cdn.staticaly.com/gh/yzyyz1387/blogimages/master/img/bloger.jpeg"}]}},"excerpt":"","more":"<h1 id=\"逆元简介\"><a href=\"#逆元简介\" class=\"headerlink\" title=\"逆元简介\"></a>逆元简介</h1><p>$a \\times b \\equiv  1 ( mod\\,\\,p)$,可以称<code>a</code>是<code>b</code>在模<code>p</code>情况下的逆元.<br>逆元其实就是可以看作倒数</p>\n<h1 id=\"阶乘逆元\"><a href=\"#阶乘逆元\" class=\"headerlink\" title=\"阶乘逆元\"></a>阶乘逆元</h1><p><strong>方式一:</strong><br>通过费马小定理求逆元：<br>当<code>p</code>为素数，并且<code>gcd(a,p)=1</code>时，我们有$a^{p−1}≡1(mod\\ p)$。那么就有$a^{p−2}×a≡1(mod\\ p)$，则<code>a</code>的逆元就是$a^{p−2}$<br>下面<code>ksm</code>函数为快速幂</p>\n<pre><code class=\"cpp\">fact[0] = 1;\nfor(int i = 1; i &lt; N; i++)\n{\n    fact[i] = fact[i - 1] * i % mod;\n    inv[i] = ksm(fact[i], mod - 2);\n}</code></pre>\n<hr>\n<p><strong>方式二：</strong></p>\n<p>通过式子$\\frac{1}{(n+1)!}\\times (n+1)=\\frac{1}{n!}$倒推接近线性求阶乘逆元</p>\n<p>$\\frac{1}{(n+1)!}$其实就可以看作${(n+1)!}$的逆元</p>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++)\n    fact[i] = fact[i - 1] * i % mod;\ninv[n] = ksm(fact[n], mod - 2);\nfor(int i = n - 1; i &gt;= 1; i--)\n    inv[i] = inv[i + 1] * (i + 1) % mod;</code></pre>\n<hr>\n<h1 id=\"线性求逆元\"><a href=\"#线性求逆元\" class=\"headerlink\" title=\"线性求逆元\"></a>线性求逆元</h1><p>求$[1,N-1]$关于<code>mod</code>的逆元时，可以做到在$O(N)$时间内解决</p>\n<p>设模数为<code>p</code><br>对于当前的<code>i</code>，设$p=k×i+r$,则</p>\n<p>$\\begin{aligned}<br>k \\times i + r &amp; \\equiv   0  &amp;\\,\\,(mod \\,\\, p) \\\\<br>k \\times i \\times ( i^{-1} \\times r ^{-1}) + r \\times (i^{-1} \\times r^{-1}) &amp;\\equiv 0 &amp;\\,\\,( mod \\,\\, p) \\\\<br>k \\times r^{-1} + i ^ {-1} &amp; \\equiv 0 &amp;\\,\\, (mod \\,\\, p)\\\\<br>i^{-1} &amp; \\equiv -k \\times r^{-1} &amp;\\,\\, (mod \\,\\, p) \\\\<br>i^{-1} &amp; \\equiv - \\left \\lfloor \\frac{p}{i}\\right \\rfloor \\times r^{-1} &amp;\\,\\,(mod\\,\\,p)<br>\\end{aligned}$<br>注意：<br>$inv[1]$一定要初始化为1，需要从2开始递推，不能从1开始递推</p>\n<pre><code class=\"cpp\">inv[0] = inv[1] = 1;\nfor(int i = 2; i &lt; N; i++)\n    inv[i] = inv[mod % i] * (mod - mod / i) % mod;</code></pre>\n<p>同时可以通过线性求逆元求<strong>阶乘逆元</strong>：<br>只需要再将逆元用类似阶乘的形式乘起来即可，求得的<code>inv[i]</code>即为$i!$的逆元</p>\n<pre><code class=\"cpp\">for(int i = 2; i &lt; N; i++)\n    inv[i] = inv[i - 1] * inv[i] % mod;</code></pre>\n<hr>\n<h1 id=\"组合数计算\"><a href=\"#组合数计算\" class=\"headerlink\" title=\"组合数计算\"></a>组合数计算</h1><p>$C_n^m$计算</p>\n<ul>\n<li>方式一：公式计算<br>计算都是在逆元或者阶乘基础上计算的<br>$C_n^m = \\frac{n!}{m!*(n-m)!}$</li>\n</ul>\n<pre><code class=\"cpp\">ll C(ll n, ll m)\n{\n    if(n &lt; m) return 0;\n    return fact[n] * inv[m] % mod * inv[n - m] % mod;\n}</code></pre>\n<ul>\n<li>方式二：递推方式<br>需要建表,所以如果计算范围比较大时需要的空间也大<br>递推公式 ： $C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}$</li>\n</ul>\n<pre><code class=\"cpp\">for(int i = 1; i &lt;= n; i++)\n    for(int j = 0; j &lt;= i; j++)\n    {\n        if(i == j || j == 0) c[i][j] = 1;\n        else c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n    }</code></pre>\n<hr>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>链接：<br><a href=\"https://ac.nowcoder.com/acm/contest/23481/J\" target=\"_blank\" rel=\"noopener\">https://ac.nowcoder.com/acm/contest/23481/J</a><br><img src=\"652576208/67dacbcfb1d0428e874f2faff1a0a75a.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>就是在数组中选中k个值相乘，最后把结果相加即可</p>\n</blockquote>\n<hr>\n<p>因为数组中的数大小只有三种情况。所以可以根据这个进行切入口。</p>\n<p>首先$0$可以不用考虑，接下考虑有$n$个$1$和$m$个$2$，如果上述和式中$1$出现了$i$个，那么$2$需要出现$k-i$个，于是答案为</p>\n<p>$\\sum \\limits_{i=0}^k C_n^i C_m^{k-i}2^{k-i}$</p>\n<hr>\n<p>代码中注意各种初始化<br>线性求逆元中初始化：<code>inv[1] = 1</code><br><code>fac[i]</code>:$2^i$<br><code>fact[i]</code>:$i!$</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nusing ll = long long;\nconst int N = 1e7 + 5, mod = 998244353;\n\nll fac[N], fact[N], inv[N];\n\nll C(ll n, ll m)\n{\n    if(n &lt; m) return 0;\n    return fact[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nvoid solve()\n{\n    fac[1] = 2;\n    fac[0] = fact[0] = fact[1] = inv[0] = inv[1] = 1;\n    for(int i = 2; i &lt; N; i++)\n    {\n        fac[i] = fac[i - 1] * 2 % mod;\n        fact[i] = fact[i - 1] * i % mod;\n        inv[i] = inv[mod % i] * (mod - mod / i) % mod; \n    }\n    for(int i = 2; i &lt; N; i++)\n        inv[i] = inv[i - 1] * inv[i] % mod;\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;int&gt; a(n);\n    int o = 0, t = 0;\n\n    for(int i = 0; i &lt; n; i++) \n    {\n        cin &gt;&gt; a[i];\n        if(a[i] == 1) o ++;\n        else if(a[i] == 2) t ++;\n    }    \n    ll res = 0;\n    for(int i = 0; i &lt;= k; i++)\n    {\n        res += C(o, i) * C(t, k - i) % mod * fac[k - i] % mod;\n        res %= mod;\n    }\n    cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n//    cin &gt;&gt; t;\n    t = 1;\n    while(t--) solve();\n    return 0;\n}\n</code></pre>\n"}],"PostAsset":[{"_id":"source/_posts/机器学习基础知识总结/image-20221230142020907.png","slug":"image-20221230142020907.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20221227173755095.png","slug":"image-20221227173755095.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20230102144808362.png","slug":"image-20230102144808362.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20221231110929844.png","slug":"image-20221231110929844.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20221231110826312.png","slug":"image-20221231110826312.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/2022杭电Static Query on Tree树链剖分/image-20220722223108042.png","post":"cldwkolgj000a6kuhtk625wpe","slug":"image-20220722223108042.png","modified":1,"renderable":1},{"_id":"source/_posts/2022牛客多校1/image-20220821221513603.png","post":"cldwkolgv000g6kuh8j4lomii","slug":"image-20220821221513603.png","modified":1,"renderable":1},{"_id":"source/_posts/CF1181C-Flag-子矩阵数量统计/image-20220629160509729.png","post":"cldwkolh8000t6kuhppn3mw48","slug":"image-20220629160509729.png","modified":1,"renderable":1},{"_id":"source/_posts/树链剖分模板/f09feafcf66f44c0b0e215ff94c1ca40.png","post":"cldwkolhp001j6kuhwmxf08z8","slug":"f09feafcf66f44c0b0e215ff94c1ca40.png","modified":1,"renderable":1},{"_id":"source/_posts/组合数学常用公式/image-20230209115625513.png","slug":"image-20230209115625513.png","post":"cldwkolhr001m6kuhsetta4zm","modified":1,"renderable":0},{"_id":"source/_posts/容斥定理/a188f738744e4afb8c5f7e745640cdd9.png","post":"cldwkolhw001z6kuhvwd9yn6l","slug":"a188f738744e4afb8c5f7e745640cdd9.png","modified":1,"renderable":1},{"_id":"source/_posts/2022牛客多校补题3/image-20220907221918311.png","post":"cldwkolh0000n6kuhcaerbdt4","slug":"image-20220907221918311.png","modified":1,"renderable":1},{"_id":"source/_posts/2022牛客多校补题3/image-20220907222225218.png","post":"cldwkolh0000n6kuhcaerbdt4","slug":"image-20220907222225218.png","modified":1,"renderable":1},{"_id":"source/_posts/阶乘逆元和线性逆元/2c464c75c8094783bf3d3099ab888e3b.png","post":"cldwkolhx00226kuhcxe58y2j","slug":"2c464c75c8094783bf3d3099ab888e3b.png","modified":1,"renderable":1},{"_id":"source/_posts/阶乘逆元和线性逆元/67dacbcfb1d0428e874f2faff1a0a75a.png","post":"cldwkolhx00226kuhcxe58y2j","slug":"67dacbcfb1d0428e874f2faff1a0a75a.png","modified":1,"renderable":1},{"_id":"source/_posts/2022年度总结/image-20230101121342445.png","post":"cldwkolge00046kuhpt5phobb","slug":"image-20230101121342445.png","modified":1,"renderable":1},{"_id":"source/_posts/2022年度总结/image-20230101121415331.png","post":"cldwkolge00046kuhpt5phobb","slug":"image-20230101121415331.png","modified":1,"renderable":1},{"_id":"source/_posts/2022年度总结/image-20230101121441216.png","post":"cldwkolge00046kuhpt5phobb","slug":"image-20230101121441216.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/1.jpg","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/1203675-20180109152428254-718844217.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"1203675-20180109152428254-718844217.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/2.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20221227173603912.png","slug":"image-20221227173603912.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20221228161134519.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20221228161134519.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20221228161724190.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20221228161724190.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20221228164952743.png","slug":"image-20221228164952743.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20221228171310763.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20221228171310763.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20221230143921870.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20221230143921870.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20221230161807567.png","slug":"image-20221230161807567.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20221230164038527.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20221230164038527.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20230102153203878.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20230102153203878.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20230102153230935.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20230102153230935.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20230102154354917.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20230102154354917.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20230102224841617.png","slug":"image-20230102224841617.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20230102225344026.png","slug":"image-20230102225344026.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20230102225422893.png","slug":"image-20230102225422893.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20230103144319179.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20230103144319179.png","modified":1,"renderable":1},{"_id":"source/_posts/机器学习基础知识总结/image-20230103153918323.png","slug":"image-20230103153918323.png","post":"cldwkolhu001u6kuh4zkvf1ms","modified":1,"renderable":0},{"_id":"source/_posts/机器学习基础知识总结/image-20230208111655893.png","post":"cldwkolhu001u6kuh4zkvf1ms","slug":"image-20230208111655893.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cldwkolg800026kuh1ybr093s","category_id":"cldwkolgf00056kuh8nv6nswj","_id":"cldwkolgx000i6kuhhvz581ev"},{"post_id":"cldwkolge00046kuhpt5phobb","category_id":"cldwkolgr000d6kuhomzwzke7","_id":"cldwkolh1000q6kuhkq5f5k5x"},{"post_id":"cldwkolgh00086kuhguj6i9th","category_id":"cldwkolgr000d6kuhomzwzke7","_id":"cldwkolh9000u6kuhiofjm1h1"},{"post_id":"cldwkolgj000a6kuhtk625wpe","category_id":"cldwkolh1000p6kuh00grwhtv","_id":"cldwkolhd00106kuhsyza72kx"},{"post_id":"cldwkolgq000c6kuh3l1pp7mx","category_id":"cldwkolha000w6kuhzs70gnyd","_id":"cldwkolhf00156kuh25mpfc1i"},{"post_id":"cldwkolhc000z6kuhf8w59a4h","category_id":"cldwkolgf00056kuh8nv6nswj","_id":"cldwkolhm001a6kuhjggm1fcz"},{"post_id":"cldwkolhe00136kuhpapkpswn","category_id":"cldwkolgf00056kuh8nv6nswj","_id":"cldwkolhn001d6kuhuhmdsd09"},{"post_id":"cldwkolhf00146kuhufrikt56","category_id":"cldwkolgf00056kuh8nv6nswj","_id":"cldwkolhp001i6kuhw3674t0o"},{"post_id":"cldwkolgv000g6kuh8j4lomii","category_id":"cldwkolhd00126kuh8hyxrkc4","_id":"cldwkolhq001l6kuhaap0mmwo"},{"post_id":"cldwkolhm001b6kuhj64wlu4g","category_id":"cldwkolgf00056kuh8nv6nswj","_id":"cldwkolhs001q6kuhq5bv59qh"},{"post_id":"cldwkolgw000h6kuh21sjz81r","category_id":"cldwkolhd00126kuh8hyxrkc4","_id":"cldwkolhu001t6kuhcg0b1iry"},{"post_id":"cldwkolhp001j6kuhwmxf08z8","category_id":"cldwkolh1000p6kuh00grwhtv","_id":"cldwkolhw001y6kuhihmtk1fa"},{"post_id":"cldwkolgy000m6kuhr4hoineg","category_id":"cldwkolho001f6kuhgnqoda3c","_id":"cldwkolhx00216kuhwtdsmo4g"},{"post_id":"cldwkolhr001m6kuhsetta4zm","category_id":"cldwkolho001f6kuhgnqoda3c","_id":"cldwkolhz00266kuh6x1wmtom"},{"post_id":"cldwkolht001r6kuhhm1bkcx1","category_id":"cldwkolha000w6kuhzs70gnyd","_id":"cldwkoli100286kuh7k3njqhp"},{"post_id":"cldwkolh0000n6kuhcaerbdt4","category_id":"cldwkolhd00126kuh8hyxrkc4","_id":"cldwkoli2002c6kuhe9fuj0pd"},{"post_id":"cldwkolhu001u6kuh4zkvf1ms","category_id":"cldwkolgf00056kuh8nv6nswj","_id":"cldwkoli2002e6kuhpzglqtdb"},{"post_id":"cldwkolhw001z6kuhvwd9yn6l","category_id":"cldwkolho001f6kuhgnqoda3c","_id":"cldwkoli3002g6kuhokx69k75"},{"post_id":"cldwkolh5000s6kuhm8od29ji","category_id":"cldwkolhv001v6kuhnm49cn54","_id":"cldwkoli4002k6kuhx4p2fwew"},{"post_id":"cldwkolhx00226kuhcxe58y2j","category_id":"cldwkolho001f6kuhgnqoda3c","_id":"cldwkoli4002l6kuhzwhcy721"},{"post_id":"cldwkolh8000t6kuhppn3mw48","category_id":"cldwkolhy00236kuh04pp5yrh","_id":"cldwkoli5002o6kuh3vau6acz"},{"post_id":"cldwkolhb000x6kuh9meduo20","category_id":"cldwkoli2002b6kuh7v1n4r6a","_id":"cldwkoli5002p6kuhooj4n4zb"},{"post_id":"cldwkolhg00176kuhmja4ax2i","category_id":"cldwkoli3002i6kuhl2yb61qe","_id":"cldwkoli6002r6kuh5kzouon3"},{"post_id":"cldwkolhn001e6kuhodav1uw2","category_id":"cldwkoli5002n6kuhgpx86rjf","_id":"cldwkoli7002u6kuhgms1y31s"}],"PostTag":[{"post_id":"cldwkolg800026kuh1ybr093s","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolgu000f6kuhei7818di"},{"post_id":"cldwkolge00046kuhpt5phobb","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolgy000l6kuh8obebzep"},{"post_id":"cldwkolgh00086kuhguj6i9th","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolh3000r6kuht0adsdhv"},{"post_id":"cldwkolgj000a6kuhtk625wpe","tag_id":"cldwkolh0000o6kuhyjeinrha","_id":"cldwkolhb000y6kuhktbo9sro"},{"post_id":"cldwkolgq000c6kuh3l1pp7mx","tag_id":"cldwkolh9000v6kuh72pkwsgs","_id":"cldwkolhm00196kuhg1jbi3jx"},{"post_id":"cldwkolgq000c6kuh3l1pp7mx","tag_id":"cldwkolhd00116kuhlhb61uc7","_id":"cldwkolhn001c6kuhzjyjqzf7"},{"post_id":"cldwkolgq000c6kuh3l1pp7mx","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolhp001h6kuh0s611no9"},{"post_id":"cldwkolhf00146kuhufrikt56","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolhq001k6kuhhqs8kvzj"},{"post_id":"cldwkolgv000g6kuh8j4lomii","tag_id":"cldwkolhg00166kuhp4ugh7nm","_id":"cldwkolhs001p6kuhi0i48agi"},{"post_id":"cldwkolgw000h6kuh21sjz81r","tag_id":"cldwkolhg00166kuhp4ugh7nm","_id":"cldwkolht001s6kuhexdkifh3"},{"post_id":"cldwkolht001r6kuhhm1bkcx1","tag_id":"cldwkolh9000v6kuh72pkwsgs","_id":"cldwkolhw001x6kuh88nmjehq"},{"post_id":"cldwkolht001r6kuhhm1bkcx1","tag_id":"cldwkolhd00116kuhlhb61uc7","_id":"cldwkolhx00206kuheehqm81n"},{"post_id":"cldwkolht001r6kuhhm1bkcx1","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolhz00256kuh6dsst59h"},{"post_id":"cldwkolhw001z6kuhvwd9yn6l","tag_id":"cldwkolhr001n6kuh1zivx5vf","_id":"cldwkoli100276kuh0bqexqsi"},{"post_id":"cldwkolgy000m6kuhr4hoineg","tag_id":"cldwkolhr001n6kuh1zivx5vf","_id":"cldwkoli2002a6kuhtif5r9b5"},{"post_id":"cldwkolgy000m6kuhr4hoineg","tag_id":"cldwkolhv001w6kuh8craqxcn","_id":"cldwkoli2002d6kuhbq0npbqy"},{"post_id":"cldwkolh0000n6kuhcaerbdt4","tag_id":"cldwkolhg00166kuhp4ugh7nm","_id":"cldwkoli3002f6kuh2l92lwkx"},{"post_id":"cldwkolh5000s6kuhm8od29ji","tag_id":"cldwkoli100296kuhfmgysmqy","_id":"cldwkoli4002j6kuhvccnic89"},{"post_id":"cldwkolh8000t6kuhppn3mw48","tag_id":"cldwkoli3002h6kuhzah6jhnm","_id":"cldwkoli6002s6kuhpoeytgfm"},{"post_id":"cldwkolh8000t6kuhppn3mw48","tag_id":"cldwkoli4002m6kuhcmid0s0v","_id":"cldwkoli7002t6kuhinheekfb"},{"post_id":"cldwkolhb000x6kuh9meduo20","tag_id":"cldwkoli6002q6kuhujsuv0g4","_id":"cldwkolie002y6kuhvvsd9ju6"},{"post_id":"cldwkolhb000x6kuh9meduo20","tag_id":"cldwkoli7002v6kuhmf45p8io","_id":"cldwkolie002z6kuh1p2k55e6"},{"post_id":"cldwkolhb000x6kuh9meduo20","tag_id":"cldwkoli3002h6kuhzah6jhnm","_id":"cldwkolie00316kuh08zjpfgt"},{"post_id":"cldwkolhc000z6kuhf8w59a4h","tag_id":"cldwkolie002x6kuh0on91ucl","_id":"cldwkolif00336kuh3m0wts39"},{"post_id":"cldwkolhc000z6kuhf8w59a4h","tag_id":"cldwkolie00306kuh5jxhfrxs","_id":"cldwkolif00346kuhgv8lr8lm"},{"post_id":"cldwkolhe00136kuhpapkpswn","tag_id":"cldwkolif00326kuhqfi86kwl","_id":"cldwkolig00366kuhnwnfrxin"},{"post_id":"cldwkolhg00176kuhmja4ax2i","tag_id":"cldwkolif00356kuh6f201d1r","_id":"cldwkolih00386kuh6fp2w4ri"},{"post_id":"cldwkolhm001b6kuhj64wlu4g","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolih003a6kuhhjpobtn6"},{"post_id":"cldwkolhm001b6kuhj64wlu4g","tag_id":"cldwkolig00376kuhyglftg7v","_id":"cldwkolii003b6kuhgvu90mfw"},{"post_id":"cldwkolhn001e6kuhodav1uw2","tag_id":"cldwkolih00396kuhj4j7cydo","_id":"cldwkolik003e6kuhxraearvr"},{"post_id":"cldwkolhn001e6kuhodav1uw2","tag_id":"cldwkolii003c6kuh3oph2o5z","_id":"cldwkolik003f6kuhjtqehmfz"},{"post_id":"cldwkolhp001j6kuhwmxf08z8","tag_id":"cldwkolh0000o6kuhyjeinrha","_id":"cldwkolil003h6kuhhe2mr9s2"},{"post_id":"cldwkolhp001j6kuhwmxf08z8","tag_id":"cldwkoli6002q6kuhujsuv0g4","_id":"cldwkolil003i6kuh3f7yyise"},{"post_id":"cldwkolhr001m6kuhsetta4zm","tag_id":"cldwkolii003c6kuh3oph2o5z","_id":"cldwkolim003k6kuh4ugovdpg"},{"post_id":"cldwkolhu001u6kuh4zkvf1ms","tag_id":"cldwkolgg00066kuhu1s8crib","_id":"cldwkolim003m6kuh485qnzqg"},{"post_id":"cldwkolhu001u6kuh4zkvf1ms","tag_id":"cldwkolil003j6kuhbfmeqplu","_id":"cldwkolim003n6kuhv0km8qdm"},{"post_id":"cldwkolhx00226kuhcxe58y2j","tag_id":"cldwkolim003l6kuhzdhx1ppf","_id":"cldwkolin003p6kuhcd4ugr0a"},{"post_id":"cldwkolhx00226kuhcxe58y2j","tag_id":"cldwkolii003c6kuh3oph2o5z","_id":"cldwkolin003q6kuhwp4soz1e"}],"Tag":[{"name":"学习总结","_id":"cldwkolgg00066kuhu1s8crib"},{"name":"树链剖分","_id":"cldwkolh0000o6kuhyjeinrha"},{"name":"C++","_id":"cldwkolh9000v6kuh72pkwsgs"},{"name":"STL","_id":"cldwkolhd00116kuhlhb61uc7"},{"name":"多校","_id":"cldwkolhg00166kuhp4ugh7nm"},{"name":"数论","_id":"cldwkolhr001n6kuh1zivx5vf"},{"name":"裴蜀定理","_id":"cldwkolhv001w6kuh8craqxcn"},{"name":"AT","_id":"cldwkoli100296kuhfmgysmqy"},{"name":"CF","_id":"cldwkoli3002h6kuhzah6jhnm"},{"name":"DP","_id":"cldwkoli4002m6kuhcmid0s0v"},{"name":"DFS","_id":"cldwkoli6002q6kuhujsuv0g4"},{"name":"树","_id":"cldwkoli7002v6kuhmf45p8io"},{"name":"docker","_id":"cldwkolie002x6kuh0on91ucl"},{"name":"linux","_id":"cldwkolie00306kuh5jxhfrxs"},{"name":"git","_id":"cldwkolif00326kuhqfi86kwl"},{"name":"nginx","_id":"cldwkolif00356kuh6f201d1r"},{"name":"DeepLearning","_id":"cldwkolig00376kuhyglftg7v"},{"name":"树形DP","_id":"cldwkolih00396kuhj4j7cydo"},{"name":"组合数学","_id":"cldwkolii003c6kuh3oph2o5z"},{"name":"MachineLearning","_id":"cldwkolil003j6kuhbfmeqplu"},{"name":"逆元","_id":"cldwkolim003l6kuhzdhx1ppf"}]}}