---
title: 【Mit6.s081】课程记录
top: false
cover: false
toc: true
mathjax: true
tags:
  - 学习总结
categories:
  - 课程记录
abbrlink: 2589851505
date: 2023-11-14 20:28:19
password:
summary:
---

> 实验代码记录：https://github.com/anda522/LabCode/tree/main/Mit6.S081 

# 1 Unix utilities

## Knowledge

### 操作系统结构

用户空间程序：正在运行的程序，他们处于同一个空间

Kernel：Kernel程序只有一个，维护数据管理每一个用户空间进程，维护硬件资源

> Kernel中存在各种服务：文件系统、进程管理系统、访问控制等等
>

应用程序访问Kernel通过 **系统调用** 来完成，Kernel具有对硬件操作的特殊权限。

### fork系统调用

作用：用于创建子进程

- fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。

之后，就有了两个拥有完全一样内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。

- 如果 `pid` 等于0，那么这必然是子进程。调用进程通常称为父进程，父进程看到的 `pid` 必然大于0。

除了拷贝内存以外，fork还会拷贝文件描述符表单。

### exec,wait系统调用

exec：用于执行新程序

exec系统调用：

- exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。
- 通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。

wait会等待之前创建的子进程退出。当我在命令行执行一个指令时，我们一般会希望Shell等待指令执行完成。不可能让子进程等待父进程退出。

wait的工作原理是，如果当前进程有任何子进程，并且其中一个已经退出了，那么wait会返回。

管道 `pipe` 特性：

- 管道具有先进先出(FIFO)的特性。数据写入管道的一端，从管道的另一端读出时是按写入顺序读取的。
- 父进程在写入管道后,会通过 read 操作等待子进程的响应。该 read 操作会被阻塞，直到有数据可读。

> 参考：
>
> [1] [MIT 6.S081 Lab Util 实验](https://blog.rayzhang.top/2022/06/27/mit-6.s081-lab-util/)

# 2 System calls

# 3 Page tables

## Knowledge

`argaddr()` 和 `argint()` 函数都是从用户栈空间中提取参数。当用户调用系统调用时，需要将参数传给内核。参数通常会放到用户的栈中。

`walk` 函数在操作系统中通常用于页表的遍历和访问。在虚拟内存管理中，页表是一种数据结构，用于将虚拟地址映射到物理地址。`walk` 函数的主要作用是在给定的页表中查找特定虚拟地址对应的页表项。

`copyout` 函数通常用于从内核空间将数据复制到用户空间。

`PTE_A` 的默认值是第六位

## Lab



> 参考：
>
> [1] [MIT 6.S081 2021: Lab page tables](https://zhuanlan.zhihu.com/p/429304672) 
>
> [2] [MIT 6.S081 Lab Pgtbl 实验](https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/) （非常详细）
