---
title: 阶乘逆元和线性逆元
top: false
cover: false
toc: true
mathjax: true
tags:
  - 逆元
  - 组合数学
categories:
  - 数论
abbrlink: 652576208
date: 2022-06-25 19:27:26
password:
summary:
---

# 逆元简介

$a \times b \equiv  1 ( mod\,\,p)$,可以称`a`是`b`在模`p`情况下的逆元.
逆元其实就是可以看作倒数

# 阶乘逆元

**方式一:**
通过费马小定理求逆元：
当`p`为素数，并且`gcd(a,p)=1`时，我们有$a^{p−1}≡1(mod\ p)$。那么就有$a^{p−2}×a≡1(mod\ p)$，则`a`的逆元就是$a^{p−2}$
下面`ksm`函数为快速幂

```cpp
fact[0] = 1;
for(int i = 1; i < N; i++)
{
	fact[i] = fact[i - 1] * i % mod;
	inv[i] = ksm(fact[i], mod - 2);
}
```

---

**方式二：**

通过式子$\frac{1}{(n+1)!}\times (n+1)=\frac{1}{n!}$倒推接近线性求阶乘逆元

$\frac{1}{(n+1)!}$其实就可以看作${(n+1)!}$的逆元

```cpp
for(int i = 1; i <= n; i++)
	fact[i] = fact[i - 1] * i % mod;
inv[n] = ksm(fact[n], mod - 2);
for(int i = n - 1; i >= 1; i--)
	inv[i] = inv[i + 1] * (i + 1) % mod;
```

---



# 线性求逆元

求$[1,N-1]$关于`mod`的逆元时，可以做到在$O(N)$时间内解决

设模数为`p`
对于当前的`i`，设$p=k×i+r$,则

$\begin{aligned}
k \times i + r & \equiv   0  &\,\,(mod \,\, p) \\\
k \times i \times ( i^{-1} \times r ^{-1}) + r \times (i^{-1} \times r^{-1}) &\equiv 0 &\,\,( mod \,\, p) \\\
k \times r^{-1} + i ^ {-1} & \equiv 0 &\,\, (mod \,\, p)\\\
i^{-1} & \equiv -k \times r^{-1} &\,\, (mod \,\, p) \\\
i^{-1} & \equiv - \left \lfloor \frac{p}{i}\right \rfloor \times r^{-1} &\,\,(mod\,\,p)
\end{aligned}$
注意：
$inv[1]$一定要初始化为1，需要从2开始递推，不能从1开始递推

```cpp
inv[0] = inv[1] = 1;
for(int i = 2; i < N; i++)
	inv[i] = inv[mod % i] * (mod - mod / i) % mod;
```

同时可以通过线性求逆元求**阶乘逆元**：
只需要再将逆元用类似阶乘的形式乘起来即可，求得的`inv[i]`即为$i!$的逆元

```cpp
for(int i = 2; i < N; i++)
	inv[i] = inv[i - 1] * inv[i] % mod;
```

---

# 组合数计算

$C_n^m$计算

- 方式一：公式计算
  计算都是在逆元或者阶乘基础上计算的
  $C_n^m = \frac{n!}{m!*(n-m)!}$

```cpp
ll C(ll n, ll m)
{
	if(n < m) return 0;
	return fact[n] * inv[m] % mod * inv[n - m] % mod;
}
```

- 方式二：递推方式
  需要建表,所以如果计算范围比较大时需要的空间也大
  递推公式 ： $C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}$

```cpp
for(int i = 1; i <= n; i++)
	for(int j = 0; j <= i; j++)
	{
		if(i == j || j == 0) c[i][j] = 1;
		else c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
	}
```

---

# 题目

链接：
[https://ac.nowcoder.com/acm/contest/23481/J](https://ac.nowcoder.com/acm/contest/23481/J)
![在这里插入图片描述](652576208/67dacbcfb1d0428e874f2faff1a0a75a.png)

>就是在数组中选中k个值相乘，最后把结果相加即可

---

因为数组中的数大小只有三种情况。所以可以根据这个进行切入口。



首先$0$可以不用考虑，接下考虑有$n$个$1$和$m$个$2$，如果上述和式中$1$出现了$i$个，那么$2$需要出现$k-i$个，于是答案为

$\sum \limits_{i=0}^k C_n^i C_m^{k-i}2^{k-i}$

---

代码中注意各种初始化
线性求逆元中初始化：`inv[1] = 1`
`fac[i]`:$2^i$
`fact[i]`:$i!$

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
const int N = 1e7 + 5, mod = 998244353;

ll fac[N], fact[N], inv[N];

ll C(ll n, ll m)
{
	if(n < m) return 0;
	return fact[n] * inv[m] % mod * inv[n - m] % mod;
}

void solve()
{
	fac[1] = 2;
	fac[0] = fact[0] = fact[1] = inv[0] = inv[1] = 1;
	for(int i = 2; i < N; i++)
	{
		fac[i] = fac[i - 1] * 2 % mod;
		fact[i] = fact[i - 1] * i % mod;
		inv[i] = inv[mod % i] * (mod - mod / i) % mod; 
	}
	for(int i = 2; i < N; i++)
		inv[i] = inv[i - 1] * inv[i] % mod;
		
	int n, k;
	cin >> n >> k;
	vector<int> a(n);
	int o = 0, t = 0;
	
	for(int i = 0; i < n; i++) 
	{
		cin >> a[i];
		if(a[i] == 1) o ++;
		else if(a[i] == 2) t ++;
	}	
	ll res = 0;
	for(int i = 0; i <= k; i++)
	{
		res += C(o, i) * C(t, k - i) % mod * fac[k - i] % mod;
		res %= mod;
	}
	cout << res << "\n";
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int t;
//	cin >> t;
	t = 1;
	while(t--) solve();
	return 0;
}

```
